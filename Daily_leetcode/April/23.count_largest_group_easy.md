# ğŸ” Count Largest Group - Digit Sum Frequency Analysis

## ğŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/count-largest-group/description/?envType=daily-question&envId=2025-04-23)

Given an integer `n`, group numbers from 1 to `n` by the sum of their digits. Return the number of groups that contain the maximum amount of numbers.

**Constraints:**
- 1 â‰¤ n â‰¤ 10â´

**Example:**
```text
Input: n = 13
Output: 4
Explanation: 
Groups are:
1 â†’ [1,10]
2 â†’ [2,11]
3 â†’ [3,12]
4 â†’ [4,13]
5 â†’ [5]
6 â†’ [6]
7 â†’ [7]
8 â†’ [8]
9 â†’ [9]
Largest groups (size 2): 4 groups
```

---

## ğŸ§  Intuition
The solution uses:
1. **Digit Sum Calculation**: Computes sum of digits for each number
2. **Frequency Tracking**: Counts numbers per digit sum group
3. **Max Group Identification**: Finds and counts largest groups

Key Insights:
- Maximum digit sum for n=10â´ is 36 (9999 â†’ 9+9+9+9)
- Array size can be fixed at 37 (0-36)
- O(n) time complexity with constant space

---

## âš™ï¸ Approach
### **1ï¸âƒ£ Frequency Array Initialization**
1. Create array to store group sizes (indices = digit sums)

### **2ï¸âƒ£ Digit Sum Calculation**
1. For each number 1 to n:
   - Calculate digit sum
   - Increment corresponding frequency count

### **3ï¸âƒ£ Max Group Counting**
1. Track maximum group size during iteration
2. Count how many groups reach this size

---

## âœ… Optimized Solution
```java
class Solution {
    public int countLargestGroup(int n) {
        int[] freq = new int[37]; // Max digit sum for n=10^4 is 36
        int maxSize = 0, groupCount = 0;
        
        for (int i = 1; i <= n; i++) {
            int digitSum = calculateDigitSum(i);
            freq[digitSum]++;
            
            // Update max group tracking
            if (freq[digitSum] > maxSize) {
                maxSize = freq[digitSum];
                groupCount = 1;
            } else if (freq[digitSum] == maxSize) {
                groupCount++;
            }
        }
        return groupCount;
    }
    
    private int calculateDigitSum(int num) {
        int sum = 0;
        while (num > 0) {
            sum += num % 10;
            num /= 10;
        }
        return sum;
    }
}
```

Key Features:
- **Efficient Digit Sum**: Simple modulo/division loop
- **Single Pass**: Tracks max groups during iteration
- **Optimal Storage**: Fixed-size frequency array
- **Early Termination**: Could exit early if possible

---

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Processes each number once |
| **Space**       | O(1)       | Fixed-size frequency array |

---

## ğŸ“Š Example Walkthrough

**Input:** n = 13

**Execution:**
1. **Digit Sums**:
   - 1â†’1, 2â†’2, ..., 9â†’9
   - 10â†’1, 11â†’2, 12â†’3, 13â†’4
2. **Frequency Update**:
   - freq[1]=2, freq[2]=2, freq[3]=2, freq[4]=2
   - Others freq[i]=1
3. **Max Tracking**:
   - maxSize=2, groupCount=4 (sums 1-4)

**Result:** 4

---

## ğŸ’¡ Key Features
- **Digit Sum Efficiency**: Simple calculation
- **Group Counting**: Simultaneous max tracking
- **Constraint Handling**: Works for upper limit
- **Clear Logic**: Easy to understand flow

---

## ğŸš€ When to Use
- Number grouping problems
- Digit property analysis
- Frequency counting scenarios
- Problems requiring digit operations

## âš ï¸ Edge Cases
- **n=1**: Single group
- **n=9**: All single-element groups
- **Large n**: Handles maximum constraint
- **Uniform groups**: All groups same size

## ğŸ›  Variations
1. **Memoization**:
```java
// Cache digit sums for repeated calculations
```

2. **Parallel Processing**:
```java
// Process number ranges concurrently
```

3. **Extended Analysis**:
```java
// Track multiple group size thresholds
```