# ğŸ” Count Good Triplets - Efficient Triple Loop Approach

## ğŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/count-good-triplets/?envType=daily-question&envId=2025-04-14)

Given an array `arr` and three integers `a`, `b`, `c`, count the number of good triplets (i, j, k) where:
1. 0 â‰¤ i < j < k < arr.length
2. |arr[i] - arr[j]| â‰¤ a
3. |arr[j] - arr[k]| â‰¤ b
4. |arr[i] - arr[k]| â‰¤ c

**Constraints:**
- 3 â‰¤ arr.length â‰¤ 100
- 0 â‰¤ arr[i] â‰¤ 1000
- 0 â‰¤ a, b, c â‰¤ 1000

**Example:**
```text
Input: arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3
Output: 4
Explanation: Triplets (0,1,2), (0,1,3), (0,2,3), (1,2,3)
```

---

## ğŸ§  Intuition
The solution uses three nested loops to:
1. **Generate Triplets**: Check all possible (i,j,k) combinations
2. **Early Pruning**: Skip invalid pairs early to optimize
3. **Condition Checking**: Verify all three constraints

Key Observations:
- O(nÂ³) time complexity (acceptable given n â‰¤ 100)
- No extra space needed
- Simple and straightforward implementation

---

## âš™ï¸ Approach
### **1ï¸âƒ£ Triple Loop Structure**
1. Outer loop (i): First element of triplet
2. Middle loop (j): Second element (must be after i)
3. Inner loop (k): Third element (must be after j)

### **2ï¸âƒ£ Early Termination**
1. Skip j-loop if |arr[i]-arr[j]| > a
2. Skip k-loop if |arr[j]-arr[k]| > b

### **3ï¸âƒ£ Condition Verification**
1. Check all three conditions for valid triplets
2. Increment count when all conditions are met

---

## âœ… Optimized Solution
```java
class Solution {
    public int countGoodTriplets(int[] arr, int a, int b, int c) {
        int count = 0;
        int n = arr.length;
        
        for (int i = 0; i < n - 2; i++) {
            for (int j = i + 1; j < n - 1; j++) {
                // Early check for first condition
                if (Math.abs(arr[i] - arr[j]) <= a) {
                    for (int k = j + 1; k < n; k++) {
                        // Check remaining conditions
                        if (Math.abs(arr[j] - arr[k]) <= b && 
                            Math.abs(arr[i] - arr[k]) <= c) {
                            count++;
                        }
                    }
                }
            }
        }
        return count;
    }
}
```
---

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(nÂ³)      | Three nested loops |
| **Space**       | O(1)       | Constant extra space |

---

## ğŸ“Š Example Walkthrough

**Input:** arr = [3,0,1,1,9,7], a=7, b=2, c=3

**Execution:**
1. i=0 (3), j=1 (0):
   - |3-0|=3 â‰¤7 â†’ check k:
     - k=2: |0-1|=1â‰¤2, |3-1|=2â‰¤3 â†’ count=1
     - k=3: |0-1|=1â‰¤2, |3-1|=2â‰¤3 â†’ count=2
     - k=4: |0-9|=9>2 â†’ skip
     - k=5: |0-7|=7>2 â†’ skip
2. i=0, j=2 (1):
   - |3-1|=2â‰¤7 â†’ check k:
     - k=3: |1-1|=0â‰¤2, |3-1|=2â‰¤3 â†’ count=3
     - k=4: |1-9|=8>2 â†’ skip
     - k=5: |1-7|=6>2 â†’ skip
3. i=1 (0), j=2 (1):
   - |0-1|=1â‰¤7 â†’ check k:
     - k=3: |1-1|=0â‰¤2, |0-1|=1â‰¤3 â†’ count=4
     - ... (other combinations don't satisfy)

**Result:** 4

---

## ğŸ’¡ Key Features
- **Complete Triplet Check**: Verifies all three conditions
- **Early Pruning**: Skips invalid combinations quickly
- **Simple Implementation**: Easy to understand and verify
- **Constraint Handling**: Works within given limits

---

## ğŸš€ When to Use
- Small array problems (n â‰¤ 100)
- When brute-force is acceptable
- Problems requiring all possible combinations

## âš ï¸ Edge Cases
- **Minimum array**: 3 elements (only one triplet)
- **All identical elements**: All triplets valid if constraints allow
- **Zero constraints**: Only identical elements satisfy
- **Maximum values**: Handles upper limits of constraints

## ğŸ›  Variations
1. **Different Constraint Orders**:
```java
// Reorder condition checks for better pruning
```

2. **Count Quadruplets**:
```java
// Extend to four nested loops
```

3. **Memoization**:
```java
// Cache intermediate results if constraints allow
```