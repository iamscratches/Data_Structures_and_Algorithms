# üîç Count and Say - Recursive Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/count-and-say/description/?envType=daily-question&envId=2025-04-18)

The count-and-say sequence is generated by:
1. Starting with "1"
2. Each subsequent term is generated by reading the previous term
   - Count the number of same consecutive digits
   - Say the digit followed by its count

Given an integer `n`, return the nth term of the count-and-say sequence.

**Constraints:**
- 1 ‚â§ n ‚â§ 30

**Example:**
```text
Input: n = 4
Output: "1211"
Explanation:
1. "1"
2. "11" (one 1)
3. "21" (two 1s)
4. "1211" (one 2, then one 1)
```

---

## üß† Intuition
The solution uses:
1. **Recursive Generation**: Builds sequence step-by-step
2. **String Processing**: Counts consecutive digits
3. **StringBuilder**: Efficient string construction

Key Insights:
- Each term depends only on the previous term
- Recursion naturally models the sequence generation
- O(n * m) time complexity (where m is string length)

---

## ‚öôÔ∏è Approach
### **1Ô∏è‚É£ Base Case**
1. Returns "1" for n=1

### **2Ô∏è‚É£ Recursive Step**
1. Appends delimiter to current string
2. Processes string to count consecutive digits
3. Builds next term using digit counts
4. Recurses with n-1

### **3Ô∏è‚É£ String Construction**
1. Uses StringBuilder for efficient concatenation
2. Tracks current digit and its count
3. Resets count when digit changes

---

## ‚úÖ Optimized Solution
```java
class Solution {
    String str = "1";
    
    public String countAndSay(int n) {
        if (n == 1) {
            return str;
        }
        
        // Add delimiter for easier processing
        str += " ";
        StringBuilder sb = new StringBuilder();
        int count = 1;
        
        // Process current string to generate next term
        for (int i = 0; i < str.length() - 1; i++) {
            if (str.charAt(i) != str.charAt(i + 1)) {
                sb.append(count).append(str.charAt(i));
                count = 1;
            } else {
                count++;
            }
        }
        
        // Update string and recurse
        str = sb.toString();
        return countAndSay(n - 1);
    }
}
```
---

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n * m)   | n recursive calls, m string length |
| **Space**       | O(n)       | Recursion stack depth |

---

## üìä Example Walkthrough

**Input:** n = 4

**Execution:**
1. **n=4**:
   - str = "1" ‚Üí "1 " ‚Üí processed to "11"
2. **n=3**:
   - str = "11" ‚Üí "11 " ‚Üí processed to "21"
3. **n=2**:
   - str = "21" ‚Üí "21 " ‚Üí processed to "1211"
4. **n=1**:
   - Returns "1211"

**Result:** "1211"

---

## üí° Key Features
- **Recursive Generation**: Natural sequence modeling
- **Efficient Processing**: StringBuilder usage
- **Clear Logic**: Simple digit counting
- **Constraint Handling**: Works within problem limits

---

## üöÄ When to Use
- Sequence generation problems
- When each step depends on previous
- Problems with recursive structure
- String transformation tasks

## ‚ö†Ô∏è Edge Cases
- **n=1**: Always returns "1"
- **Maximum n=30**: Handles longest possible sequence
- **Single digit runs**: Properly counts repeats
- **Digit transitions**: Correctly detects changes

## üõ† Variations
1. **Iterative Approach**:
```java
// Replace recursion with loop
```

2. **Memoization**:
```java
// Store previously computed terms
```

3. **Parallel Processing**:
```java
// Process string segments concurrently
```