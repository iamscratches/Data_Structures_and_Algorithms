# ğŸ” Count the Number of Fair Pairs - Two Pointers Approach

## ğŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/count-the-number-of-fair-pairs/description/?envType=daily-question&envId=2025-04-19)

Given an array `nums` and two integers `lower` and `upper`, count the number of fair pairs (i,j) where:
1. 0 â‰¤ i < j < nums.length
2. lower â‰¤ nums[i] + nums[j] â‰¤ upper

**Constraints:**
- 1 â‰¤ nums.length â‰¤ 10âµ
- -10â¹ â‰¤ nums[i] â‰¤ 10â¹
- -10â¹ â‰¤ lower â‰¤ upper â‰¤ 10â¹

**Example:**
```text
Input: nums = [0,1,4,4,5,7], lower = 3, upper = 6
Output: 6
Explanation: Pairs (0,1)=1, (0,2)=4, (0,3)=4, (1,2)=5, (1,3)=5, (2,3)=8 â†’ 4 valid pairs
```

---

## ğŸ§  Intuition
The solution uses:
1. **Sorting**: Enables efficient pair counting
2. **Two Pointers**: Counts pairs in O(n) time per bound
3. **Inclusion-Exclusion**: Calculates range counts via upper-lower bounds

Key Insights:
- Sorting enables two-pointer technique
- Count(upper) - Count(lower-1) gives range count
- O(n log n) time dominates from sorting

---

## âš™ï¸ Approach
### **1ï¸âƒ£ Sorting**
1. Sort array to enable two-pointer technique

### **2ï¸âƒ£ Range Counting**
1. Count pairs with sum â‰¤ upper
2. Count pairs with sum â‰¤ (lower-1)
3. Subtract to get pairs in [lower, upper]

### **3ï¸âƒ£ Two-Pointer Technique**
1. Start with pointers at array ends
2. Move inward counting valid pairs
3. Linear scan for each bound

---

## âœ… Optimized Solution
```java
class Solution {
    public long countFairPairs(int[] nums, int lower, int upper) {
        if (nums.length == 1) {
            return 0;
        }
        Arrays.sort(nums);
        
        return count(nums, upper) - count(nums, lower - 1);
    }
    
    private long count(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        long result = 0;
        
        while (left < right) {
            int sum = nums[left] + nums[right];
            if (sum <= target) {
                result += right - left;
                left++;
            } else {
                right--;
            }
        }
        return result;
    }
}
```

---

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n log n) | Dominated by sorting |
| **Space**       | O(1)       | In-place sorting |

---

## ğŸ“Š Example Walkthrough

**Input:** nums = [0,1,4,4,5,7], lower = 3, upper = 6

**Execution:**
1. **Sorting**: Array remains [0,1,4,4,5,7]
2. **Count(upper=6)**:
   - (0,5)=7, (0,4)=5 â†’ 4 pairs (0,1-4)
   - (1,4)=6 â†’ 2 pairs (1,2-3)
   - Total: 6 pairs â‰¤6
3. **Count(lower-1=2)**:
   - (0,1)=1 â†’ 1 pair (0,1)
   - Total: 1 pair â‰¤2
4. **Result**: 6 - 1 = 5 valid pairs

**Correction:** Actual valid pairs are (0,1)=1, (0,2)=4, (0,3)=4, (1,2)=5, (1,3)=5 â†’ 5 pairs

---

## ğŸ’¡ Key Features
- **Range Optimization**: Efficiently counts in bounds
- **Sorting Benefit**: Enables linear-time counting
- **Clean Subtraction**: Upper-lower gives exact count
- **Large Input Handling**: Works within constraints

---

## ğŸš€ When to Use
- Range-based pair counting
- When sorting enables better algorithms
- Problems with sum constraints
- Two-pointer applicable scenarios

## âš ï¸ Edge Cases
- **Single element**: Always 0 pairs
- **All identical elements**: Special counting
- **Extreme values**: Handles large numbers
- **Empty range**: When lower > upper

## ğŸ›  Variations
1. **Alternative Sorting**:
```java
// Use counting sort for limited ranges
```

2. **Different Bounds**:
```java
// Handle multiple range queries
```

3. **Parallel Processing**:
```java
// Process bounds concurrently
```