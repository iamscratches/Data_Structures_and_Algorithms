# üçº Water Bottles II - Dynamic Exchange Rate Simulation

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/water-bottles-ii/description/?envType=daily-question&envId=2025-10-02)

Given:
- `numBottles`: initial number of full water bottles
- `numExchange`: initial number of empty bottles needed to exchange for one full bottle

Find:
- The maximum number of water bottles you can drink
- Special rule: Each time you exchange, the exchange rate increases by 1

**Rules:**
- Drink a bottle ‚Üí becomes empty
- Exchange `x` empty bottles ‚Üí get 1 full bottle, then `x` increases by 1
- Process continues until you can't exchange anymore

**Constraints:**
- 1 ‚â§ numBottles, numExchange ‚â§ 100

**Example:**
```text
Input: numBottles = 13, numExchange = 6
Output: 15
Explanation:
Drink 13 bottles ‚Üí 13 empty
Exchange 6 empty ‚Üí get 1 full, rate becomes 7 ‚Üí drink 1 ‚Üí 8 empty
Exchange 7 empty ‚Üí get 1 full, rate becomes 8 ‚Üí drink 1 ‚Üí 2 empty
Total: 13 + 1 + 1 = 15

Input: numBottles = 10, numExchange = 3
Output: 13
```

## üß† Intuition
The solution uses:
1. **Iterative Simulation**: Simulate drinking and exchanging process
2. **Dynamic Exchange Rate**: Exchange rate increases after each exchange
3. **Net Bottle Consumption**: Each exchange consumes (x-1) empty bottles net
4. **Cumulative Counting**: Track total bottles drunk

Key Insights:
- Each exchange: consume x bottles to get 1 back ‚Üí net loss of (x-1) bottles
- Exchange rate increases by 1 after each successful exchange
- Continue until insufficient bottles for next exchange

## ‚öôÔ∏è Approach
1. **Initialize**: Start with total = initial bottles
2. **Simulation Loop**:
   - While current bottles ‚â• current exchange rate
   - Reduce bottles by (x-1) [net consumption]
   - Increase exchange rate by 1
   - Increase total drunk by 1 [the new bottle]
3. **Return Result**: Total bottles drunk

## ‚úÖ Optimized Solution
```java
class Solution {
    public int maxBottlesDrunk(int numBottles, int numExchange) {
        int totalDrunk = numBottles;
        int currentBottles = numBottles;
        int currentExchangeRate = numExchange;
        
        while (currentBottles >= currentExchangeRate) {
            // Exchange: consume currentExchangeRate bottles, get 1 back
            currentBottles -= (currentExchangeRate - 1);
            currentExchangeRate++;
            totalDrunk++;
        }
        
        return totalDrunk;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(‚àön)      | Exchange rate grows, reducing iterations |
| **Space**       | O(1)       | Constant extra variables |

## üìä Example Walkthrough
**Input:** numBottles = 13, numExchange = 6

**Initial:** total=13, bottles=13, rate=6

**Iteration 1:**
- bottles=13 ‚â• rate=6 ‚úì
- bottles = 13 - (6-1) = 13 - 5 = 8
- rate = 6 + 1 = 7
- total = 13 + 1 = 14

**Iteration 2:**
- bottles=8 ‚â• rate=7 ‚úì
- bottles = 8 - (7-1) = 8 - 6 = 2
- rate = 7 + 1 = 8
- total = 14 + 1 = 15

**Iteration 3:**
- bottles=2 < rate=8 ‚úó ‚Üí stop

**Result:** 15

## üí° Key Features
- **Efficient Simulation**: Minimal variable tracking
- **Net Consumption**: Uses (x-1) for cleaner calculation
- **Dynamic Rate**: Exchange rate increases each iteration
- **Early Termination**: Stops when exchange impossible

## üöÄ When to Use
- Simulation problems with changing rules
- When exchange rates evolve over time
- Problems with state-dependent transitions
- Educational examples of dynamic systems

## ‚ö†Ô∏è Edge Cases
- **numBottles < numExchange**: Return numBottles (no exchange possible)
- **Large initial gap**: May never reach exchange threshold
- **Rapid rate growth**: Exchange becomes impossible quickly
- **Minimum values**: Handles edge constraints properly

## üõ† Variations
1. **Mathematical Analysis**:
```java
// Find closed-form formula for specific cases
```

2. **Different Progression**:
```java
// Exchange rate grows by different patterns
```

3. **Multiple Exchanges**:
```java
// Allow multiple exchanges per iteration
```

4. **Visualization**:
```java
// Show bottle count and exchange rate over time
```

5. **Generalization**:
```java
// Arbitrary exchange rate progression functions
```

## Mathematical Insight
The solution leverages:
- Arithmetic progression of exchange rates
- The inequality: bottles ‚â• exchange_rate
- The recurrence: bottles_{i+1} = bottles_i - (rate_i - 1)
- Triangular number properties for rate progression

## Alternative Implementation (Explicit Empty Bottles)
```java
class Solution {
    public int maxBottlesDrunk(int numBottles, int numExchange) {
        int total = numBottles;
        int empty = numBottles;
        int rate = numExchange;
        
        while (empty >= rate) {
            // Exchange empty bottles
            empty -= rate;
            rate++;
            
            // Drink the new bottle
            total++;
            empty++;
        }
        
        return total;
    }
}
```
Note: This alternative explicitly tracks empty bottles and shows the exchange process more literally. The original solution is more optimized by using net consumption. Both approaches have the same time complexity, but the original is slightly more efficient in terms of operations.