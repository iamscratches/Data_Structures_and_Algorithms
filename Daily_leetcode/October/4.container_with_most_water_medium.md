# üíß Container With Most Water - Two Pointer Approach
## üß† Intuition
The solution uses:
1. **Two Pointers**: Start from both ends and move towards center
2. **Greedy Selection**: Always move the pointer with smaller height
3. **Area Maximization**: Track maximum area encountered
4. **Early Optimization**: Skip lines that can't improve the area

Key Insights:
- Start with widest possible container (first and last lines)
- The limiting factor is always the shorter line
- Moving the shorter pointer may find a taller line and increase area
- Width decreases as pointers move inward, so we need taller lines to compensate

## ‚öôÔ∏è Approach
1. **Initialize Pointers**: i=0 (left), j=n-1 (right)
2. **Calculate Area**: min(height[i], height[j]) √ó (j-i)
3. **Update Maximum**: Track largest area found
4. **Move Pointers**:
   - If height[i] < height[j]: move i right (skip shorter lines)
   - If height[i] > height[j]: move j left (skip shorter lines)
   - If equal: move both pointers
5. **Terminate**: When pointers meet

## ‚úÖ Optimized Solution
```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int maxArea = 0;
        
        while (left < right) {
            // Calculate current area
            int currentHeight = Math.min(height[left], height[right]);
            int currentWidth = right - left;
            int currentArea = currentHeight * currentWidth;
            
            // Update maximum area
            maxArea = Math.max(maxArea, currentArea);
            
            // Move the pointer with smaller height
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        
        return maxArea;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass with two pointers |
| **Space**       | O(1)       | Constant extra variables |

## üìä Example Walkthrough
**Input:** height = [1,8,6,2,5,4,8,3,7]

**Initial:** left=0 (height=1), right=8 (height=7)
- Area = min(1,7) √ó 8 = 1 √ó 8 = 8
- maxArea = 8
- Move left (smaller height)

**Step 2:** left=1 (height=8), right=8 (height=7)
- Area = min(8,7) √ó 7 = 7 √ó 7 = 49
- maxArea = 49
- Move right (smaller height)

**Step 3:** left=1 (height=8), right=7 (height=3)
- Area = min(8,3) √ó 6 = 3 √ó 6 = 18
- maxArea remains 49
- Move right (smaller height)

**Continue until pointers meet...**

## üí° Key Features
- **Optimal Strategy**: Always moves the limiting pointer
- **Efficiency**: Linear time complexity
- **Simplicity**: Easy to understand and implement
- **No Extra Space**: Uses only a few variables

## üöÄ When to Use
- Array optimization problems
- When two pointers can converge from ends
- Problems involving maximizing area/volume
- Greedy algorithm applications

## ‚ö†Ô∏è Edge Cases
- **All equal heights**: Area decreases as width decreases
- **Two elements**: Direct calculation
- **Zero heights**: Area will be zero
- **Large array**: Handles maximum constraints efficiently

## üõ† Variations
1. **Alternative Movement**:
```java
// Move both pointers when heights are equal
```

2. **Early Termination**:
```java
// Stop if maximum possible area can't exceed current max
```

3. **Multiple Containers**:
```java
// Find top k containers with most water
```

4. **Visualization**:
```java
// Show pointer movement and area calculations
```

5. **Generalization**:
```java
// 3D container problem or different shapes
```

## Mathematical Insight
The solution leverages:
- Properties of the min function in area calculation
- The trade-off between width and height
- Greedy choice property (moving smaller pointer is optimal)
- Monotonicity in pointer movement

## Alternative Implementation (Original Optimized)
```java
class Solution {
    public int maxArea(int[] height) {
        int i = 0, j = height.length - 1, max = 0;
        
        while (i < j) {
            max = Math.max(max, Math.min(height[i], height[j]) * (j - i));
            
            if (height[i] > height[j]) {
                int temp = height[j];
                while (j > i && height[j] <= temp) j--;
            } else {
                int temp = height[i];
                while (i < j && height[i] <= temp) i++;
            }
        }
        return max;
    }
}
```
Note: This version includes additional optimization by skipping lines that are shorter than the current line, but the basic two-pointer approach is sufficient and more readable. The additional skipping provides minor performance improvements for certain input patterns.