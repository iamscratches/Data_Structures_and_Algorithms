# üìä Maximum Frequency of an Element After Performing Operations II - Advanced Binary Search Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/description/?envType=daily-question&envId=2025-10-22)

Given:
- An array `nums` of integers
- An integer `k` representing the operation range
- An integer `numOperations` representing the number of operations allowed

**Operations:**
- You can change any element to any value in the range `[nums[i]-k, nums[i]+k]`
- Each operation can be applied to any element
- You have `numOperations` operations available

Find:
- The **maximum frequency** any element can achieve after performing at most `numOperations` operations

**Key Difference from Version I:**
- This is a more complex version that requires careful handling of ranges and binary search
- Larger constraints or more complex scenarios

**Constraints:**
- Similar to Version I but potentially with larger input sizes or additional complexity

**Example:**
```text
Input: nums = [1,2,4,5], k = 1, numOperations = 2
Output: 3

Explanation:
We can change elements to get frequency 3:
- Change 2 to 1 and 5 to 4 ‚Üí [1,1,4,4] (freq 2)
- Or change 2 and 5 to 4 ‚Üí [1,4,4,4] (freq 3)
```

## üß† Intuition
The solution uses:
1. **Sorting + Frequency Counting**: Process sorted array and count frequencies
2. **Candidate Generation**: Identify potential target values (modes)
3. **Binary Search Bounds**: Find left and right boundaries for each candidate range
4. **Range Analysis**: Calculate achievable frequency considering operations

Key Insights:
- Potential target values include original numbers and their ¬±k boundaries
- Use binary search to efficiently find convertible ranges
- Consider both existing frequency and convertible elements
- Balance between operations available and elements in range

## ‚öôÔ∏è Approach
1. **Sort and Count**: Sort array and count frequencies of each number
2. **Generate Candidates**: Identify potential target values (original numbers ¬± k)
3. **Binary Search**: For each candidate, find range `[mode-k, mode+k]` in sorted array
4. **Calculate Frequency**: Determine maximum achievable frequency considering:
   - Existing frequency of target
   - Available operations
   - Total elements in convertible range

## ‚úÖ Optimized Solution
```java
class Solution {
    public int maxFrequency(int[] nums, int k, int numOperations) {
        // Step 1: Sort the array
        Arrays.sort(nums);
        int ans = 0;
        
        // Step 2: Count frequencies and identify candidate modes
        Map<Integer, Integer> numCount = new HashMap<>();
        Set<Integer> modes = new TreeSet<>();  // Sorted candidate targets
        
        // Helper to add candidate target values
        Consumer<Integer> addMode = value -> {
            modes.add(value);
            if (value - k >= nums[0]) {
                modes.add(value - k);
            }
            if (value + k <= nums[nums.length - 1]) {
                modes.add(value + k);
            }
        };
        
        // Count frequencies and populate candidates
        int lastNumIndex = 0;
        for (int i = 0; i < nums.length; ++i) {
            if (nums[i] != nums[lastNumIndex]) {
                numCount.put(nums[lastNumIndex], i - lastNumIndex);
                ans = Math.max(ans, i - lastNumIndex);
                addMode.accept(nums[lastNumIndex]);
                lastNumIndex = i;
            }
        }
        // Handle last group
        numCount.put(nums[lastNumIndex], nums.length - lastNumIndex);
        ans = Math.max(ans, nums.length - lastNumIndex);
        addMode.accept(nums[lastNumIndex]);
        
        // Step 3: Binary search functions for range boundaries
        IntUnaryOperator leftBound = value -> {
            int left = 0;
            int right = nums.length - 1;
            while (left < right) {
                int mid = (left + right) / 2;
                if (nums[mid] < value) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            return left;
        };
        
        IntUnaryOperator rightBound = value -> {
            int left = 0;
            int right = nums.length - 1;
            while (left < right) {
                int mid = (left + right + 1) / 2;
                if (nums[mid] > value) {
                    right = mid - 1;
                } else {
                    left = mid;
                }
            }
            return left;
        };
        
        // Step 4: Evaluate each candidate mode
        for (int mode : modes) {
            int left = leftBound.applyAsInt(mode - k);
            int right = rightBound.applyAsInt(mode + k);
            int totalInRange = right - left + 1;
            
            int tempAns;
            if (numCount.containsKey(mode)) {
                // Mode exists in original array
                tempAns = Math.min(
                    totalInRange,                    // Limited by range size
                    numCount.get(mode) + numOperations // Limited by ops + existing
                );
            } else {
                // Mode doesn't exist, need to create it
                tempAns = Math.min(totalInRange, numOperations); // Limited by ops
            }
            ans = Math.max(ans, tempAns);
        }
        
        return ans;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n log n + m log n) | Sorting + m candidates √ó binary search |
| **Space**       | O(n)       | Frequency map and candidate set |

Where:
- `n = nums.length`
- `m = number of candidate modes` (‚â§ 3n)

## üìä Example Walkthrough
**Input:** nums = [1,2,4,5], k = 1, numOperations = 2

**Step 1 - Sort:** [1,2,4,5]

**Step 2 - Frequency Counting:**
- numCount: {1:1, 2:1, 4:1, 5:1}
- Candidates: 1,0,2, 2,1,3, 4,3,5, 5,4,6

**Step 3 - Evaluate Candidates:**

**Candidate mode = 4:**
- Range: [3,5] ‚Üí indices: leftBound(3)=2, rightBound(5)=3
- Total in range: 2 elements (4,5)
- Existing frequency: 1
- Max achievable: min(2, 1+2) = 2

**Candidate mode = 3:**
- Range: [2,4] ‚Üí indices: leftBound(2)=1, rightBound(4)=2  
- Total in range: 2 elements (2,4)
- Existing frequency: 0 (but can convert)
- Max achievable: min(2, 2) = 2

**Candidate mode = 2:**
- Range: [1,3] ‚Üí indices: leftBound(1)=0, rightBound(3)=2
- Total in range: 3 elements (1,2,4)
- Existing frequency: 1
- Max achievable: min(3, 1+2) = 3 ‚úì

**Output:** 3 ‚úì

## üí° Key Features
- **Candidate Generation**: Considers original values and their ¬±k boundaries
- **Binary Search Optimization**: Efficient range boundary finding
- **Frequency Awareness**: Leverages existing frequencies when available
- **Operation Budgeting**: Balances conversions with available operations

## üöÄ When to Use
- Advanced frequency maximization problems
- When target values aren't limited to original numbers
- Problems requiring precise range boundary detection
- Scenarios with mixed conversion strategies

## ‚ö†Ô∏è Edge Cases
- **k = 0**: Only original numbers as candidates
- **numOperations = 0**: Cannot create new values
- **All values same**: Maximum frequency = n
- **Large ranges**: May cover entire array
- **Non-existent targets**: Require operations to create

## üõ† Variations
1. **Sliding Window Approach**:
```java
// Use sliding window to find best convertible range
```

2. **Priority Queue**:
```java
// Track best candidates with priority
```

3. **Dynamic Programming**:
```java
// DP with state tracking for complex scenarios
```

## Mathematical Insight
The solution leverages:
- **Range Coverage**: Elements in `[mode-k, mode+k]` can become `mode`
- **Binary Search Efficiency**: O(log n) range boundary detection
- **Candidate Optimization**: Only evaluate promising target values
- **Operation Economics**: Balance between creating new values and enhancing existing ones

**Key Formulas:**
- Convertible range for mode `m`: `[m-k, m+k]`
- Achievable frequency = `min(elements_in_range, existing_freq + operations)`
- Candidate generation: original values and their `¬±k` boundaries

The algorithm provides an efficient solution by strategically limiting the search space to promising candidate values and using binary search for precise range calculations, making it suitable for larger input sizes and more complex scenarios than Version I.