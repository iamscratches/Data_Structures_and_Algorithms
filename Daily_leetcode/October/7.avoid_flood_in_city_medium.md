# 🏊 Avoid Flood in The City - Union-Find Greedy Approach

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/avoid-flood-in-the-city/description/?envType=daily-question&envId=2025-10-07)

Given:
- An array `rain` where `rain[i]` represents the lake that gets rained on at day `i`
- `rain[i] > 0` means lake `rain[i]` gets rain
- `rain[i] == 0` means no rain (you can dry one lake of your choice)

Objective:
- Prevent any lake from flooding (becoming full and then receiving more rain)
- When a lake gets rain and is already full, it floods

Rules:
- Initially all lakes are empty
- If lake gets rain and is empty → becomes full
- If lake gets rain and is full → floods (invalid)
- On dry days (`rain[i] = 0`), you can dry one full lake

Find:
- A valid sequence of actions, or empty array if impossible
- For dry days, specify which lake to dry
- For rainy days, must be -1

**Constraints:**
- `1 <= rain.length <= 10^5`
- `0 <= rain[i] <= 10^9`

**Example:**
```text
Input: rain = [1,2,0,0,2,1]
Output: [-1,-1,2,1,-1,-1]
Explanation:
Day 0: Rain on lake 1 → [-1,?,?,?,?,?]
Day 1: Rain on lake 2 → [-1,-1,?,?,?,?]  
Day 2: Dry day - choose to dry lake 2 → [-1,-1,2,?,?,?]
Day 3: Dry day - choose to dry lake 1 → [-1,-1,2,1,?,?]
Day 4: Rain on lake 2 (was dried) → [-1,-1,2,1,-1,?]
Day 5: Rain on lake 1 (was dried) → [-1,-1,2,1,-1,-1]
```

## 🧠 Intuition
The solution uses:
1. **Union-Find for Dry Days**: Efficiently find next available dry day
2. **Greedy Strategy**: Dry lakes just before they would flood
3. **Lake Tracking**: Remember last rain day for each lake
4. **Dry Day Allocation**: Assign dry days to prevent imminent floods

Key Insights:
- When a lake gets rain again, we must have dried it between rains
- Dry days should be allocated to lakes that will flood soonest
- Union-Find helps efficiently find the earliest available dry day after last rain
- Greedy approach: dry the lake that's about to flood

## ⚙️ Approach
1. **Initialize**:
   - Result array filled with 1s (default dry choice)
   - Union-Find to manage available dry days
   - HashMap to track last rain day for each lake

2. **Process Each Day**:
   - **Rainy day**: 
     - Mark result as -1
     - If lake was seen before, find dry day between last rain and current day
     - If no dry day available → return empty array
     - Assign that dry day to dry this lake
   - **Dry day**:
     - Union-Find marks this day as available for future use

3. **Union-Find Strategy**:
   - `unite(i)` connects day `i` to next available day
   - `find(i)` finds earliest available dry day ≥ i

## ✅ Optimized Solution
```java
class Solution {
    public int[] avoidFlood(int[] rain) {
        int n = rain.length;
        UnionFind uf = new UnionFind(n + 1);
        Map<Integer, Integer> map = new HashMap<>();
        int[] res = new int[n];
        Arrays.fill(res, 1); // Default dry day choice

        for (int i = 0; i < n; i++) {
            int lake = rain[i];

            if (lake != 0) {
                // Rainy day - must be -1 in result
                res[i] = -1;
                uf.unite(i); // Mark current day as used

                if (map.containsKey(lake)) {
                    // This lake rained before - need to dry it between rains
                    int prev = map.get(lake);
                    int dry = uf.find(prev + 1); // Find earliest dry day after last rain

                    if (dry >= i) // No dry day available between rains
                        return new int[0];

                    res[dry] = lake; // Dry this lake on that day
                    uf.unite(dry); // Mark dry day as used
                    map.put(lake, i); // Update last rain day
                } else {
                    // First time this lake rains
                    map.put(lake, i);
                }
            }
        }

        return res;
    }
}

class UnionFind {
    int[] parent;

    public UnionFind(int size) {
        parent = new int[size + 1];
        for (int i = 0; i <= size; i++) {
            parent[i] = i;
        }
    }

    public int find(int i) {
        if (parent[i] == i)
            return i;
        parent[i] = find(parent[i]); // Path compression
        return parent[i];
    }

    public void unite(int i) {
        parent[i] = find(i + 1); // Connect to next available day
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n α(n))  | Near-linear with Union-Find path compression |
| **Space**       | O(n)       | Union-Find array + HashMap |

## 📊 Example Walkthrough
**Input:** rain = [1,2,0,0,2,1]

**Processing:**
- **Day 0**: Lake 1 rains → res[0]=-1, map{1:0}
- **Day 1**: Lake 2 rains → res[1]=-1, map{1:0, 2:1}
- **Day 2**: Dry day → available, res[2]=1 (default)
- **Day 3**: Dry day → available, res[3]=1 (default)
- **Day 4**: Lake 2 rains again → 
  - Last rain at day 1, find dry day after day 1
  - Earliest available is day 2 → assign res[2]=2
  - Update map{1:0, 2:4}
- **Day 5**: Lake 1 rains again →
  - Last rain at day 0, find dry day after day 0  
  - Earliest available is day 3 → assign res[3]=1

**Result:** [-1,-1,2,1,-1,-1]

## 💡 Key Features
- **Union-Find Innovation**: Used to find available dry days efficiently
- **Greedy Optimal**: Always dry the lake that's about to flood
- **Online Processing**: Handles input in single pass
- **Early Termination**: Detects impossibility quickly

## 🚀 When to Use
- Scheduling problems with constraints
- When you need to find available slots between events
- Greedy allocation problems
- Problems with "use between two events" pattern

## ⚠️ Edge Cases
- **All rainy days**: Impossible if any lake rains twice
- **All dry days**: Can dry any lakes (default to 1)
- **Large lake numbers**: Up to 10^9, but sparse
- **No floods possible**: When lakes rain only once
- **Immediate consecutive rains**: Need dry day in between

## 🛠 Variations
1. **TreeSet Approach**:
```java
// Use TreeSet to store available dry days
```

2. **Priority Queue**:
```java
// Store future flood events in priority queue
```

3. **Binary Search**:
```java
// Binary search on available dry days
```

## Alternative Implementation (TreeSet)
```java
class Solution {
    public int[] avoidFlood(int[] rains) {
        int n = rains.length;
        int[] result = new int[n];
        Arrays.fill(result, 1);
        
        Map<Integer, Integer> lastRain = new HashMap<>();
        TreeSet<Integer> dryDays = new TreeSet<>();
        
        for (int i = 0; i < n; i++) {
            if (rains[i] == 0) {
                dryDays.add(i);
            } else {
                result[i] = -1;
                int lake = rains[i];
                
                if (lastRain.containsKey(lake)) {
                    Integer dryDay = dryDays.higher(lastRain.get(lake));
                    if (dryDay == null) return new int[0];
                    
                    result[dryDay] = lake;
                    dryDays.remove(dryDay);
                }
                lastRain.put(lake, i);
            }
        }
        return result;
    }
}
```

**Comparison:**
- **Union-Find**: More efficient for dense dry day usage
- **TreeSet**: More intuitive, easier to understand  
- **Union-Find**: Better worst-case performance
- **TreeSet**: Built-in higher() function convenient

## Mathematical Insight
The solution leverages:
- **Greedy Choice Property**: Optimal to dry most urgent lake
- **Union-Find Adaptation**: Innovative use for slot finding
- **Online Algorithm**: Processes input sequentially
- **Amortized Complexity**: Union-Find provides efficient operations

The Union-Find approach creatively adapts the data structure to find the earliest available dry day, making it highly efficient for this constraint satisfaction problem.