# âš¡ Successful Pairs of Spells and Potions - Binary Search Approach

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/?envType=daily-question&envId=2025-10-08)

Given:
- Two integer arrays: `spells` and `potions`
- A `long` integer `success`
- A pair is **successful** if: `spell[i] * potions[j] >= success`

Find:
- For each spell, the number of potions that form successful pairs

**Formula:**
- Successful pair: `spell * potion >= success`
- For each `spell[i]`, count how many `potions[j]` satisfy the condition

**Constraints:**
- `n == spells.length`
- `m == potions.length`
- `1 <= n, m <= 10^5`
- `1 <= spells[i], potions[i] <= 10^5`
- `1 <= success <= 10^10`

**Example:**
```text
Input: spells = [5,1,3], potions = [1,2,3,4,5], success = 7
Output: [4,0,3]

Explanation:
- Spell 5: pairs with potions [2,3,4,5] â†’ 4 successful
- Spell 1: pairs with no potions â†’ 0 successful  
- Spell 3: pairs with potions [3,4,5] â†’ 3 successful
```

## ðŸ§  Intuition
The solution uses:
1. **Sorting + Binary Search**: Preprocess potions for efficient querying
2. **Mathematical Transformation**: Convert multiplication condition to division
3. **Lower Bound Search**: Find first potion that meets success threshold
4. **Count Calculation**: Use array length to count remaining elements

Key Insights:
- Sort potions once, then answer each spell query efficiently
- Transform: `spell * potion >= success` â†’ `potion >= success / spell`
- Find the first potion â‰¥ required minimum value
- All potions from that index onward will be successful

## âš™ï¸ Approach
1. **Preprocessing**:
   - Sort the potions array in non-decreasing order

2. **For Each Spell**:
   - Calculate minimum potion value needed: `ceil(success / spell)`
   - Use binary search to find first potion â‰¥ minimum value
   - Count = total potions - found index

3. **Binary Search Details**:
   - Standard lower bound search
   - Returns first index where potion â‰¥ threshold
   - All elements from this index satisfy the condition

## âœ… Optimized Solution
```java
class Solution {
    public int[] successfulPairs(int[] spells, int[] potions, long success) {
        int[] result = new int[spells.length];
        int n = potions.length;
        
        // Pre-sort potions for efficient binary search
        Arrays.sort(potions);
        
        int index = 0;
        for (int spell : spells) {
            // Calculate minimum potion value needed for success
            // Using ceiling division: ceil(success / spell)
            long minPotion = (success + spell - 1) / spell;
            
            // Binary search for first potion >= minPotion
            int low = 0;
            int high = n;
            while (low < high) {
                int mid = low + (high - low) / 2;
                if (potions[mid] < minPotion) {
                    low = mid + 1;
                } else {
                    high = mid;
                }
            }
            
            // All potions from 'low' to end are successful
            result[index++] = n - low;
        }
        
        return result;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(m log m + n log m) | Sort potions + binary search for each spell |
| **Space**       | O(1)       | Only output array (ignoring input storage) |

Where:
- `n = spells.length`
- `m = potions.length`

## ðŸ“Š Example Walkthrough
**Input:** spells = [5,1,3], potions = [1,2,3,4,5], success = 7

**Sorted Potions:** [1,2,3,4,5]

**Spell 5:**
- Min potion needed = ceil(7/5) = ceil(1.4) = 2
- Binary search finds first potion â‰¥ 2 at index 1
- Successful pairs = 5 - 1 = 4

**Spell 1:**
- Min potion needed = ceil(7/1) = 7
- Binary search finds no potion â‰¥ 7, returns index 5
- Successful pairs = 5 - 5 = 0

**Spell 3:**
- Min potion needed = ceil(7/3) = ceil(2.33) = 3
- Binary search finds first potion â‰¥ 3 at index 2
- Successful pairs = 5 - 2 = 3

**Output:** [4,0,3]

## ðŸ’¡ Key Features
- **Mathematical Optimization**: Ceiling division avoids floating point
- **Single Sort**: Potions sorted once for all queries
- **Efficient Binary Search**: O(log m) per spell query
- **Early Exit**: Binary search terminates quickly

## ðŸš€ When to Use
- Counting problems with threshold conditions
- When you have multiple queries on sorted data
- Problems involving pairs/products meeting criteria
- When preprocessing enables faster queries

## âš ï¸ Edge Cases
- **Large values**: Handles up to 10^10 success threshold
- **All failures**: When no potion meets requirement
- **All successes**: When all potions work
- **Single element**: Arrays with length 1
- **Integer overflow**: Uses long for calculations

## ðŸ›  Variations
1. **Two Pointers**:
```java
// If spells are also sorted, use two pointers
```

2. **Different Search**:
```java
// Use Arrays.binarySearch() built-in method
```

3. **Upper Bound**:
```java
// Find first element > threshold and adjust counting
```

## Mathematical Insight
The solution leverages:
- **Ceiling Division**: `(a + b - 1) / b` efficiently computes `ceil(a/b)`
- **Monotonicity**: Sorted array enables binary search
- **Lower Bound**: Finding first element satisfying condition
- **Complement Counting**: `n - index` counts remaining elements

## Alternative Implementation (Using Built-in Binary Search)
```java
class Solution {
    public int[] successfulPairs(int[] spells, int[] potions, long success) {
        int n = spells.length;
        int m = potions.length;
        int[] result = new int[n];
        
        Arrays.sort(potions);
        
        for (int i = 0; i < n; i++) {
            long minPotion = (success + spells[i] - 1) / spells[i];
            
            // Handle case where minPotion exceeds maximum potion value
            if (minPotion > potions[m - 1]) {
                result[i] = 0;
                continue;
            }
            
            int index = lowerBound(potions, minPotion);
            result[i] = m - index;
        }
        
        return result;
    }
    
    private int lowerBound(int[] arr, long target) {
        int left = 0, right = arr.length;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}
```

**Optimization Notes:**
- **Ceiling Division Trick**: Avoids floating point imprecision
- **Early Check**: Skip binary search if minPotion > max potion
- **Standard Lower Bound**: Clean, readable implementation

## Performance Comparison
| Approach | Time Complexity | Best For |
|----------|----------------|----------|
| **Binary Search** | O(m log m + n log m) | General case |
| **Two Pointers** | O(m log m + n log n + n + m) | When spells also sorted |
| **Brute Force** | O(n Ã— m) | Small inputs only |

The binary search approach provides the optimal balance between preprocessing and query efficiency for this problem structure.