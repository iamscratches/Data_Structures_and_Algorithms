# üìä Maximum Frequency of an Element After Performing Operations - Prefix Sum Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i/description/?envType=daily-question&envId=2025-10-21)

Given:
- An array `nums` of integers
- An integer `k` representing the operation range
- An integer `numOps` representing the number of operations allowed

**Operations:**
- You can change any element to any value in the range `[nums[i]-k, nums[i]+k]`
- Each operation can be applied to any element
- You have `numOps` operations available

Find:
- The **maximum frequency** any element can achieve after performing at most `numOps` operations

**Objective:**
- Maximize the count of the most frequent element after operations
- You can convert other elements to match your target element

**Constraints:**
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^5`
- `0 <= k <= 10^5`
- `0 <= numOps <= 10^5`

**Example:**
```text
Input: nums = [1,4,5], k = 1, numOps = 1
Output: 2

Explanation:
We can change one element:
- Change 4 to 1 ‚Üí array becomes [1,1,5] ‚Üí frequency of 1 is 2
- Or change 5 to 4 ‚Üí array becomes [1,4,4] ‚Üí frequency of 4 is 2
```

## üß† Intuition
The solution uses:
1. **Frequency Counting**: Count occurrences of each value
2. **Prefix Sum Array**: Efficient range sum queries
3. **Sliding Window Concept**: Find elements within range `[target-k, target+k]`
4. **Greedy Strategy**: Convert elements closest to target first

Key Insights:
- For a target value `i`, we can convert all elements in range `[i-k, i+k]` to `i`
- The number of convertible elements = total in range - already matching
- We're limited by both available operations and convertible elements
- Use prefix sums to quickly count elements in any range

## ‚öôÔ∏è Approach
1. **Count Frequencies**: Create frequency array for all possible values
2. **Build Prefix Sum**: Cumulative counts for range queries
3. **Evaluate Each Target**: For each possible target value:
   - Find range `[i-k, i+k]` of convertible elements
   - Calculate total elements in this range
   - Calculate how many can be converted (min of operations and available elements)
   - Update maximum frequency

## ‚úÖ Optimized Solution
```java
class Solution {
    public int maxFrequency(int[] nums, int k, int numOps) {
        // Find maximum possible value after operations
        int maxVal = Arrays.stream(nums).max().getAsInt() + k + 2;
        
        // Step 1: Count frequency of each value
        int[] count = new int[maxVal];
        for (int v : nums) {
            count[v]++;
        }
        
        // Step 2: Build prefix sum array for range queries
        for (int i = 1; i < maxVal; i++) {
            count[i] += count[i - 1];
        }
        
        // Step 3: Find maximum frequency for each possible target
        int res = 0;
        for (int i = 0; i < maxVal; i++) {
            // Define convertible range [left, right]
            int left = Math.max(0, i - k);
            int right = Math.min(maxVal - 1, i + k);
            
            // Total elements that can be converted to i
            int totalInRange = count[right] - (left > 0 ? count[left - 1] : 0);
            
            // Current frequency of target value i
            int currentFreq = count[i] - (i > 0 ? count[i - 1] : 0);
            
            // Maximum achievable frequency = current + min(operations, convertible elements)
            int maxAchievable = currentFreq + Math.min(numOps, totalInRange - currentFreq);
            res = Math.max(res, maxAchievable);
        }
        
        return res;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n + M)   | n = nums.length, M = max value range |
| **Space**       | O(M)       | Frequency and prefix sum arrays |

## üìä Example Walkthrough
**Input:** nums = [1,4,5], k = 1, numOps = 1

**Step 1 - Frequency Count:**
- Values: 1, 4, 5
- count[1]=1, count[4]=1, count[5]=1, others=0

**Step 2 - Prefix Sum:**
- count[0]=0, count[1]=1, count[2]=1, count[3]=1, count[4]=2, count[5]=3, count[6]=3...

**Step 3 - Evaluate Targets:**

**Target = 1:**
- Range: [0, 2] (1-1=0 to 1+1=2)
- Total in range: count[2] - count[-1] = 1 - 0 = 1
- Current freq: 1
- Max achievable: 1 + min(1, 1-1) = 1 + 0 = 1

**Target = 4:**
- Range: [3, 5] (4-1=3 to 4+1=5)
- Total in range: count[5] - count[2] = 3 - 1 = 2
- Current freq: 1
- Max achievable: 1 + min(1, 2-1) = 1 + 1 = 2 ‚úì

**Target = 5:**
- Range: [4, 6] (5-1=4 to 5+1=6)
- Total in range: count[6] - count[3] = 3 - 1 = 2
- Current freq: 1
- Max achievable: 1 + min(1, 2-1) = 2 ‚úì

**Output:** 2 ‚úì

## üí° Key Features
- **Prefix Sum Optimization**: O(1) range sum queries
- **Complete Search**: Evaluates all possible target values
- **Greedy Optimal**: Converts closest elements first
- **Efficient Range Handling**: Proper boundary checks

## üöÄ When to Use
- Frequency maximization problems
- When elements can be converted within ranges
- Problems requiring range sum queries
- Optimization with operation constraints

## ‚ö†Ô∏è Edge Cases
- **k = 0**: No conversions allowed, return maximum original frequency
- **numOps = 0**: No operations, return maximum original frequency  
- **All same elements**: Frequency = n
- **Large k**: Can convert many elements
- **Empty array**: Should return 0 (but constraints prevent)

## üõ† Variations
1. **Binary Search Approach**:
```java
// Binary search on the answer with feasibility check
```

2. **Two Pointer/Sliding Window**:
```java
// Use sliding window to find best target range
```

3. **Sorting + Greedy**:
```java
// Sort array and use greedy conversion
```

## Alternative Implementation (Sorting + Two Pointers)
```java
class Solution {
    public int maxFrequency(int[] nums, int k, int numOps) {
        Arrays.sort(nums);
        int n = nums.length;
        int left = 0;
        int maxFreq = 0;
        long operationsUsed = 0;
        
        for (int right = 0; right < n; right++) {
            // Calculate operations needed to convert all in window to nums[right]
            if (right > 0) {
                operationsUsed += (long)(nums[right] - nums[right - 1]) * (right - left);
            }
            
            // Shrink window if operations exceed available
            while (operationsUsed > numOps) {
                operationsUsed -= nums[right] - nums[left];
                left++;
            }
            
            maxFreq = Math.max(maxFreq, right - left + 1);
        }
        
        return maxFreq;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Range Transformation**: Elements in `[target-k, target+k]` can become `target`
- **Prefix Sum Property**: `count[r] - count[l-1]` gives elements in `[l, r]`
- **Greedy Principle**: Best to convert elements requiring fewest operations
- **Operation Budget**: Limited by both `numOps` and available convertible elements

**Key Formula:**
For target value `i`:
- Convertible range: `[i-k, i+k]`
- Total convertible elements: `prefix[i+k] - prefix[i-k-1]`
- Already matching: `freq[i]`
- Can convert: `min(numOps, total_convertible - already_matching)`
- Maximum frequency: `already_matching + can_convert`

The algorithm efficiently finds the optimal solution by leveraging prefix sums for fast range queries and systematically evaluating all possible target values within the convertible range.