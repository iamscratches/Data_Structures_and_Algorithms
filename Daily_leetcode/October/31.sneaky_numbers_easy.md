# ğŸ•µï¸ The Two Sneaky Numbers of Digitville - Frequency Counting Approach

## ğŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/the-two-sneaky-numbers-of-digitville/description/?envType=daily-question&envId=2025-10-31)

Given:
- An array `nums` of length `n + 2` containing numbers from `1` to `n`
- Exactly **two numbers appear twice**, all others appear exactly once
- The array contains all numbers from `1` to `n` plus two duplicates

Find:
- The **two numbers that appear twice** (the "sneaky numbers")

**Array Properties:**
- Length = `n + 2`
- Contains numbers from `1` to `n`
- Two numbers appear twice, rest appear once
- Need to find the two duplicates

**Constraints:**
- `2 <= n <= 100`
- `4 <= nums.length <= 102`
- `1 <= nums[i] <= n`

**Example:**
```text
Input: nums = [1,2,3,2,3]
Output: [2,3]

Explanation:
n = 3 (since array length is 5 = 3 + 2)
Numbers 1-3: 1 appears once, 2 appears twice, 3 appears twice
```

## ğŸ§  Intuition
The solution uses:
1. **Frequency Counting**: Track how many times each number appears
2. **Duplicate Detection**: Identify numbers that appear more than once
3. **Array Index Mapping**: Use the numbers themselves as indices
4. **Linear Scan**: Process array once to find duplicates

Key Insights:
- Since numbers range from 1 to n, we can use them as array indices
- The frequency array size is n (nums.length - 2)
- When we encounter a number for the second time, it's a duplicate
- We only need to track first occurrence vs duplicate

## âš™ï¸ Approach
1. **Initialize Frequency Array**: Size = n (nums.length - 2)
2. **Process Each Number**:
   - If number already seen (freq[num] == 1), it's a duplicate â†’ add to result
   - Otherwise, mark as seen (freq[num] = 1)
3. **Return Result**: Array containing the two duplicates

## âœ… Optimized Solution
```java
class Solution {
    public int[] getSneakyNumbers(int[] nums) {
        int n = nums.length - 2;  // Original range: 1 to n
        int[] freq = new int[n + 1];  // Frequency array (1-indexed for convenience)
        int[] result = new int[2];
        int index = 0;
        
        for (int num : nums) {
            if (freq[num] == 1) {
                // This is the second occurrence - it's a duplicate
                result[index++] = num;
            } else {
                // First occurrence - mark as seen
                freq[num] = 1;
            }
        }
        
        return result;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through the array |
| **Space**       | O(n)       | Frequency array of size n |

## ğŸ“Š Example Walkthrough
**Input:** nums = [1,2,3,2,3]

**Step-by-step:**
1. **n = 3** (array length 5 - 2 = 3)
2. **Initialize**: freq = [0,0,0,0] (1-indexed), result = [0,0], index=0

3. **Process nums[0]=1**:
   - freq[1] = 0 â†’ mark as seen: freq[1] = 1

4. **Process nums[1]=2**:
   - freq[2] = 0 â†’ mark as seen: freq[2] = 1

5. **Process nums[2]=3**:
   - freq[3] = 0 â†’ mark as seen: freq[3] = 1

6. **Process nums[3]=2**:
   - freq[2] = 1 â†’ duplicate! â†’ result[0] = 2, index=1

7. **Process nums[4]=3**:
   - freq[3] = 1 â†’ duplicate! â†’ result[1] = 3, index=2

**Output:** [2,3] âœ“

**Another Example:** nums = [4,3,2,4,1,3]
- n = 4 (length 6 - 2 = 4)
- Process: 4(seen), 3(seen), 2(seen), 4(duplicate!), 1(seen), 3(duplicate!)
- Result: [4,3]

## ğŸ’¡ Key Features
- **Efficient Detection**: Finds duplicates in single pass
- **Simple Logic**: Easy to understand and implement
- **Optimal Solution**: Linear time complexity
- **Memory Efficient**: Only O(n) extra space

## ğŸš€ When to Use
- Duplicate detection problems
- When input range is known and bounded
- Frequency counting scenarios
- Problems with exactly k duplicates

## âš ï¸ Edge Cases
- **n = 2**: Smallest possible case
- **Large n**: Up to 100, efficiently handled
- **Duplicates at beginning**: [2,2,1,3] â†’ [2,?]
- **Duplicates at end**: [1,2,3,3,2] â†’ [3,2]

## ğŸ›  Variations
1. **Sorting Approach**:
```java
public int[] getSneakyNumbers(int[] nums) {
    Arrays.sort(nums);
    int[] result = new int[2];
    int index = 0;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] == nums[i - 1]) {
            result[index++] = nums[i];
        }
    }
    return result;
}
```

2. **Bit Manipulation**:
```java
// Use bitmask to track seen numbers (for smaller n)
```

3. **Mathematical Approach**:
```java
// Use sum and sum of squares to find duplicates
```

## Alternative Implementation (In-place Marking)
```java
class Solution {
    public int[] getSneakyNumbers(int[] nums) {
        int[] result = new int[2];
        int index = 0;
        
        for (int i = 0; i < nums.length; i++) {
            int num = Math.abs(nums[i]);
            if (nums[num - 1] < 0) {
                // Already negative - this is a duplicate
                result[index++] = num;
            } else {
                // Mark as seen by making negative
                nums[num - 1] = -nums[num - 1];
            }
        }
        
        return result;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Pigeonhole Principle**: With n+2 slots for n distinct numbers, two must repeat
- **Frequency Analysis**: Track occurrences to identify duplicates
- **Index Mapping**: Direct addressing using number values
- **Early Termination**: Can stop once both duplicates are found

**Key Properties:**
- Array contains exactly n distinct numbers from 1 to n
- Two numbers appear twice, making total length n + 2
- This creates exactly two "extra" occurrences

The algorithm efficiently solves the problem by recognizing that we can use the numbers themselves as indices in a frequency array, allowing us to detect duplicates in linear time with a single pass through the input array.