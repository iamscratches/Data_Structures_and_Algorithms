# üçº Water Bottles - Bottle Exchange Simulation

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/water-bottles/description/?envType=daily-question&envId=2025-10-01)

Given:
- `numBottles`: initial number of full water bottles
- `numExchange`: number of empty bottles needed to exchange for one full bottle

Find:
- The maximum number of water bottles you can drink
- You can exchange empty bottles for new full bottles

**Rules:**
- Drink a bottle ‚Üí becomes empty
- Exchange `numExchange` empty bottles ‚Üí get 1 full bottle
- Process continues until you can't exchange anymore

**Constraints:**
- 1 ‚â§ numBottles ‚â§ 100
- 2 ‚â§ numExchange ‚â§ 100

**Example:**
```text
Input: numBottles = 9, numExchange = 3
Output: 13
Explanation:
Drink 9 bottles ‚Üí 9 empty ‚Üí exchange 9/3=3 full ‚Üí drink 3 ‚Üí 3 empty ‚Üí exchange 3/3=1 full ‚Üí drink 1
Total: 9 + 3 + 1 = 13

Input: numBottles = 15, numExchange = 4
Output: 19
Explanation: 15 + 3 + 1 = 19
```

## üß† Intuition
The solution uses:
1. **Iterative Simulation**: Simulate the drinking and exchange process
2. **Remainder Tracking**: Keep track of leftover empty bottles after each exchange
3. **Cumulative Counting**: Add newly obtained bottles to total count
4. **Loop Until Exhaustion**: Continue until no more exchanges possible

Key Insights:
- Each iteration: drink current bottles ‚Üí exchange empties for new bottles
- Remainder bottles carry over to next iteration
- Process stops when bottles < exchange rate

## ‚öôÔ∏è Approach
1. **Initialize**: Start with total = initial bottles
2. **Simulation Loop**:
   - Combine current bottles with previous remainder
   - Calculate new bottles from exchange: bottles / numExchange
   - Update remainder: bottles % numExchange
   - Add new bottles to total count
   - Repeat until no more exchanges possible
3. **Return Result**: Total bottles drunk

## ‚úÖ Optimized Solution
```java
class Solution {
    public int numWaterBottles(int numBottles, int numExchange) {
        int totalDrunk = numBottles;
        int emptyBottles = 0;
        
        while (numBottles > 0) {
            // Combine current empty bottles with newly emptied ones
            emptyBottles += numBottles;
            
            // Exchange empty bottles for new full ones
            numBottles = emptyBottles / numExchange;
            emptyBottles = emptyBottles % numExchange;
            
            // Add newly obtained bottles to total
            totalDrunk += numBottles;
        }
        
        return totalDrunk;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(log n)   | Bottles reduce exponentially |
| **Space**       | O(1)       | Constant extra variables |

## üìä Example Walkthrough
**Input:** numBottles = 9, numExchange = 3

**Iteration 1:**
- Start: total=9, empty=0, bottles=9
- Drink 9 ‚Üí empty=9
- Exchange: 9/3=3 new bottles, remainder=0
- total=9+3=12
- Continue with bottles=3

**Iteration 2:**
- Drink 3 ‚Üí empty=3
- Exchange: 3/3=1 new bottle, remainder=0
- total=12+1=13
- Continue with bottles=1

**Iteration 3:**
- Drink 1 ‚Üí empty=1
- Exchange: 1/3=0 ‚Üí stop
- Final total=13

## üí° Key Features
- **Efficient Simulation**: Minimal variables needed
- **Clear Logic**: Easy to follow the bottle flow
- **Early Termination**: Stops when no more exchanges
- **Remainder Handling**: Properly tracks leftover bottles

## üöÄ When to Use
- Simulation problems with state transitions
- When iterative processes need modeling
- Problems with exchange/convert rules
- Educational examples of while loops

## ‚ö†Ô∏è Edge Cases
- **numBottles < numExchange**: Return numBottles (no exchange possible)
- **numExchange = 1**: Infinite bottles (but constraints prevent this)
- **Remainder accumulation**: Multiple iterations may be needed
- **Large values**: Handles maximum constraints efficiently

## üõ† Variations
1. **Mathematical Formula**:
```java
// Direct calculation without loop
```

2. **Recursive Approach**:
```java
// Recursive simulation
```

3. **Different Exchange Rules**:
```java
// Variable exchange rates or bonus bottles
```

4. **Visualization**:
```java
// Show each exchange step
```

5. **Generalization**:
```java
// Multiple bottle types or exchange rates
```

## Mathematical Insight
The solution leverages:
- Properties of integer division and modulus
- Geometric series principles
- State machine simulation
- The formula: total = numBottles + ‚åänumBottles/(numExchange-1)‚åã (with adjustment)

## Alternative Implementation (Mathematical Formula)
```java
class Solution {
    public int numWaterBottles(int numBottles, int numExchange) {
        // Mathematical formula: total = numBottles + floor((numBottles - 1) / (numExchange - 1))
        return numBottles + (numBottles - 1) / (numExchange - 1);
    }
}
```
Note: This mathematical approach uses the insight that you effectively get one "free" bottle for every (numExchange-1) bottles you drink. However, the iterative simulation is more intuitive and easier to understand, especially for beginners. Both approaches produce the same result.