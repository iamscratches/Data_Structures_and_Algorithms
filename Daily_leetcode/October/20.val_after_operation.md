# ➕ Final Value of Variable After Performing Operations - Simple Counter Approach

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/final-value-of-variable-after-performing-operations/description/?envType=daily-question&envId=2025-10-20)

Given:
- An array of string `operations`
- Each operation is one of: `"++X"`, `"X++"`, `"--X"`, `"X--"`
- Initial value of variable `X` is `0`

Find:
- The **final value** of `X` after performing all operations

**Operations:**
- `"++X"` or `"X++"`: **Increment** X by 1 (pre-increment or post-increment)
- `"--X"` or `"X--"`: **Decrement** X by 1 (pre-decrement or post-decrement)

**Constraints:**
- `1 <= operations.length <= 100`
- `operations[i]` will be either `"++X"`, `"X++"`, `"--X"`, or `"X--"`

**Example:**
```text
Input: operations = ["--X","X++","X++"]
Output: 1

Explanation:
Initial: X = 0
--X: X = -1
X++: X = 0  
X++: X = 1
```

## 🧠 Intuition
The solution uses:
1. **Simple Counter**: Track the value with a single integer
2. **Pattern Recognition**: All increment operations contain `"++"`, all decrement operations contain `"--"`
3. **String Checking**: Check if operation contains increment or decrement pattern
4. **Linear Processing**: Process each operation in sequence

Key Insights:
- Don't need to distinguish between pre-increment and post-increment
- Don't need to distinguish between pre-decrement and post-decrement  
- Only need to check if the operation increases or decreases the value
- The middle character or substring pattern reveals the operation type

## ⚙️ Approach
1. **Initialize**: Start with `X = 0`
2. **Process Each Operation**:
   - If operation contains `"++"` → increment X
   - If operation contains `"--"` → decrement X
3. **Return Result**: Final value of X

## ✅ Optimized Solution
```java
class Solution {
    public int finalValueAfterOperations(String[] operations) {
        int x = 0;  // Initial value
        
        for (String operation : operations) {
            // Check if operation is increment (contains "++")
            if (operation.contains("++")) {
                x++;
            } 
            // Otherwise it's decrement (contains "--")
            else {
                x--;
            }
        }
        
        return x;
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through operations array |
| **Space**       | O(1)       | Only a few variables |

## 📊 Example Walkthrough
**Input:** operations = ["--X","X++","X++"]

**Processing:**
1. Operation "--X": contains "--" → decrement: x = -1
2. Operation "X++": contains "++" → increment: x = 0
3. Operation "X++": contains "++" → increment: x = 1

**Output:** 1 ✓

**Another Example:** operations = ["++X","++X","X++"]
- "++X": increment → x = 1
- "++X": increment → x = 2  
- "X++": increment → x = 3

**Output:** 3 ✓

## 💡 Key Features
- **Simplicity**: Straightforward logic with minimal code
- **Efficiency**: Linear time complexity
- **Readability**: Clear intention and easy to understand
- **Robustness**: Handles all valid input cases

## 🚀 When to Use
- Simple state machine problems
- When you need to process a sequence of operations
- Counting problems with increment/decrement
- Warm-up problems and basic array processing

## ⚠️ Edge Cases
- **Single operation**: Simple increment/decrement
- **All same operations**: Continuous increments/decrements
- **Empty array**: Should return 0 (but constraints prevent this)
- **Mixed operations**: Alternating increments and decrements

## 🛠 Variations
1. **Character Checking**:
```java
public int finalValueAfterOperations(String[] operations) {
    int x = 0;
    for (String op : operations) {
        if (op.charAt(1) == '+') x++;
        else x--;
    }
    return x;
}
```

2. **Switch Statement**:
```java
public int finalValueAfterOperations(String[] operations) {
    int x = 0;
    for (String op : operations) {
        switch (op) {
            case "++X":
            case "X++":
                x++;
                break;
            case "--X":
            case "X--":
                x--;
                break;
        }
    }
    return x;
}
```

3. **Stream API**:
```java
public int finalValueAfterOperations(String[] operations) {
    return Arrays.stream(operations)
                 .mapToInt(op -> op.contains("++") ? 1 : -1)
                 .sum();
}
```

## Alternative Implementation (Middle Character Check)
```java
class Solution {
    public int finalValueAfterOperations(String[] operations) {
        int x = 0;
        for (String operation : operations) {
            // The middle character (index 1) determines the operation
            // "++X" -> '+' at index 1, "X++" -> '+' at index 1
            // "--X" -> '-' at index 1, "X--" -> '-' at index 1
            if (operation.charAt(1) == '+') {
                x++;
            } else {
                x--;
            }
        }
        return x;
    }
}
```

**Why check character at index 1?**
- All operations are 3 characters long
- The operation type is determined by the middle character:
  - `"++X"`: characters = ['+', '+', 'X'] → index 1 = '+'
  - `"X++"`: characters = ['X', '+', '+'] → index 1 = '+'  
  - `"--X"`: characters = ['-', '-', 'X'] → index 1 = '-'
  - `"X--"`: characters = ['X', '-', '-'] → index 1 = '-'

## Mathematical Insight
The solution leverages:
- **Commutative Property**: Order of operations doesn't matter for final result
- **Additive Inverse**: Each decrement is the inverse of increment
- **Linear Transformation**: Final value = initial + (increments - decrements)
- **Pattern Recognition**: Operation type encoded in string structure

**Formula:**
```
Final X = 0 + count("++") - count("--")
```

The algorithm efficiently solves the problem by recognizing the simple pattern that all increment operations contain "++" and all decrement operations contain "--", making the solution both optimal and easy to understand.