# 🔢 Next Greater Numerically Balanced Number - Backtracking Approach

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/next-greater-numerically-balanced-number/description/?envType=daily-question&envId=2025-10-24)

Given:
- An integer `n`
- A **numerically balanced** number satisfies:
  - For every digit `d` in the number, the frequency of `d` equals `d`
  - If digit `d` appears at all, it must appear exactly `d` times

Find:
- The smallest numerically balanced number strictly greater than `n`

**Balanced Number Rules:**
- Digit 1 must appear exactly 1 time (if present)
- Digit 2 must appear exactly 2 times (if present)
- Digit 3 must appear exactly 3 times (if present)
- ... and so on
- Digit 0 cannot appear (since 0 would need to appear 0 times)

**Constraints:**
- `0 <= n <= 10^6`

**Examples:**
```text
Input: n = 1
Output: 22
Explanation: 22 is numerically balanced because digit 2 appears exactly 2 times.

Input: n = 1000
Output: 1333
Explanation: 1333 has one '1' and three '3's.

Input: n = 3000
Output: 3133
Explanation: 3133 has one '1', one '3', and three '3's? Wait, let's check:
Actually, 3133 has: one '1' and three '3's → balanced!
```

## 🧠 Intuition
The solution uses:
1. **Backtracking Generation**: Systematically generate all possible balanced numbers
2. **Digit Frequency Tracking**: Ensure each digit appears exactly the required number of times
3. **Pruning**: Stop early when numbers become too large
4. **Sorting + Search**: Find the smallest valid number greater than n

Key Insights:
- Maximum possible balanced number is 1224444 (digits 1,2,4 with frequencies 1,2,3)
- Only digits 1-7 can appear (digit 8 would need 8 occurrences → too long)
- Generate all valid combinations and find the next one after n

## ⚙️ Approach
1. **Backtracking Generation**:
   - Start with empty number
   - Try adding digits 1-7 while respecting frequency constraints
   - Track digit counts in frequency array

2. **Validation**:
   - Check if current digit frequencies satisfy balanced condition
   - All non-zero counts must equal their digit value

3. **Optimization**:
   - Prune when number exceeds maximum possible (1224444)
   - Only consider digits 1-7

4. **Result Finding**:
   - Sort all generated balanced numbers
   - Find first number greater than n

## ✅ Optimized Solution
```java
class Solution {
    public int nextBeautifulNumber(int n) {
        List<Integer> list = new ArrayList<>();
        generate(0, new int[10], list);
        Collections.sort(list);
        for (int num : list) {
            if (num > n) return num;
        }
        return -1;
    }
    
    private void generate(long num, int[] count, List<Integer> list) {
        // Check if current number is balanced and valid
        if (num > 0 && isBeautiful(count)) {
            list.add((int) num);
        }
        
        // Prune: stop if number exceeds maximum possible balanced number
        if (num > 1224444) return;

        // Try adding digits 1 through 7
        for (int d = 1; d <= 7; d++) {
            // Check if we can add more of this digit
            if (count[d] < d) {
                count[d]++;
                generate(num * 10 + d, count, list);
                count[d]--; // backtrack
            }
        }
    }
    
    private boolean isBeautiful(int[] count) {
        for (int d = 1; d <= 7; d++) {
            // If digit appears, it must appear exactly d times
            if (count[d] != 0 && count[d] != d) {
                return false;
            }
        }
        return true;
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(7! × 7)  | Backtracking with pruning, limited by max number 1224444 |
| **Space**       | O(K)       | Storage for generated numbers + recursion stack |

## 📊 Example Walkthrough
**Input:** n = 1000

**Generation Process:**
- Start with empty number, count = [0,0,0,0,0,0,0,0,0,0]
- Try digit 1: num=1, count[1]=1 → check: balanced? No (only one digit but needs validation later)
- Continue building: 11 → invalid (1 appears twice)
- 12 → continue...
- 22 → valid! Add to list
- 122 → invalid (1 appears once ✓, 2 appears twice ✓ but 2 appears twice needs checking)
- Actually, 122: digit 1 appears once ✓, digit 2 appears twice ✓ → valid!
- Continue generating...

**Valid numbers generated:** 1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, etc.

**After sorting:** [1, 22, 122, 212, 221, 333, 1333, 3133, ...]

**Find first > 1000:** 1333

## 💡 Key Features
- **Backtracking**: Systematic generation of all possibilities
- **Pruning**: Early termination for large numbers
- **Frequency Validation**: Efficient balanced number checking
- **Digit Constraints**: Only consider feasible digits (1-7)

## 🚀 When to Use
- Combinatorial number generation problems
- When you need to generate numbers with specific digit properties
- Problems with frequency constraints
- When brute force is feasible due to constraints

## ⚠️ Edge Cases
- **n = 0**: Should return 1 (smallest balanced number)
- **n = 10^6**: Should return 1224444
- **Single digit numbers**: Only 1 is valid
- **Large n near upper bound**: Handle maximum case efficiently

## 🛠 Variations
1. **Iterative Generation**:
```java
// Generate numbers iteratively instead of recursively
```

2. **Mathematical Approach**:
```java
// Directly construct the next balanced number
```

3. **Precomputation**:
```java
// Precompute all balanced numbers once
```

## Alternative Implementation (Iterative)
```java
class Solution {
    public int nextBeautifulNumber(int n) {
        // Predefined list of all balanced numbers up to 1224444
        int[] balanced = {1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 
                          4444, 14444, 22333, 23233, 23323, 23332, 32233, 
                          32323, 32332, 33223, 33232, 33322, 41444, 44144, 
                          44414, 44441, 55555, 122333, 123233, 123323, 123332,
                          132233, 132323, 132332, 133223, 133232, 133322,
                          155555, 212333, 213233, 213323, 213332, 221333,
                          223133, 223313, 223331, 224444, 231233, 231323,
                          231332, 232133, 232313, 232331, 233123, 233132,
                          233213, 233231, 233312, 233321, 242444, 244244,
                          244424, 244442, 312233, 312323, 312332, 313223,
                          313232, 313322, 321233, 321323, 321332, 322133,
                          322313, 322331, 323123, 323132, 323213, 323231,
                          323312, 323321, 331223, 331232, 331322, 332123,
                          332132, 332213, 332231, 332312, 332321, 333122,
                          333212, 333221, 422444, 424244, 424424, 424442,
                          442244, 442424, 442442, 444224, 444242, 444422,
                          515555, 551555, 555155, 555515, 555551, 666666,
                          1224444};
        
        for (int num : balanced) {
            if (num > n) return num;
        }
        return -1;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Combinatorics**: Limited combinations due to frequency constraints
- **Digit Position Theory**: Each digit's position affects the number but not balance
- **Pruning Theory**: Early termination based on maximum bounds
- **Frequency Analysis**: Digit counts must satisfy specific equations

## Performance Comparison
| Approach | Time Complexity | Space | Best For |
|----------|----------------|--------|----------|
| **Backtracking** | O(7! × 7) | O(K) | General case |
| **Precomputation** | O(1) lookup | O(K) | Multiple queries |
| **Mathematical** | O(log n) | O(1) | Single query |

The backtracking approach provides a clean, systematic way to generate all possible balanced numbers while respecting the constraints, making it ideal for this problem where the search space is manageable due to the strict digit frequency requirements.