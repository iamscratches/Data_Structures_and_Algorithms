# üíß Trapping Rain Water II - Priority Queue Boundary Expansion

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/trapping-rain-water-ii/description/?envType=daily-question&envId=2025-10-03)

Given:
- An `m x n` integer matrix `heightMap` representing elevation map

Find:
- The total volume of water it can trap after raining

**Rules:**
- Water can flow to adjacent cells (up, down, left, right)
- Water cannot escape the boundary
- Water level is determined by the lowest boundary height

**Constraints:**
- m == heightMap.length
- n == heightMap[i].length
- 1 ‚â§ m, n ‚â§ 200
- 0 ‚â§ heightMap[i][j] ‚â§ 2 * 10‚Å¥

**Example:**
```text
Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
Output: 4
Explanation:
Water is trapped in the low areas surrounded by higher boundaries
```

## üß† Intuition
The solution uses:
1. **Boundary First Approach**: Start from the outer boundary and expand inward
2. **Priority Queue**: Always process the lowest boundary cell first (min-heap)
3. **Water Level Tracking**: Maintain current water level as maximum boundary height encountered
4. **BFS Expansion**: Explore neighbors and calculate trapped water

Key Insights:
- Water trapped at a cell = max(0, current_level - cell_height)
- The lowest boundary determines how much water adjacent cells can hold
- Process cells in increasing height order ensures correct water calculation

## ‚öôÔ∏è Approach
1. **Initialize**:
   - Add all boundary cells to min-heap
   - Mark boundary cells as visited
2. **Process Queue**:
   - Extract lowest cell from heap
   - Update current water level
   - For each neighbor:
     - If unvisited, calculate trapped water
     - Add to heap with its height
3. **Continue**: Until all cells processed

## ‚úÖ Optimized Solution
```java
class Solution {
    public int trapRainWater(int[][] heightMap) {
        int[][] directions = {{0,1}, {1,0}, {0,-1}, {-1,0}};
        int rows = heightMap.length;
        int cols = heightMap[0].length;
        
        if (rows < 3 || cols < 3) return 0; // Need at least 3x3 to trap water
        
        boolean[][] visited = new boolean[rows][cols];
        PriorityQueue<Cell> minHeap = new PriorityQueue<>((a, b) -> a.height - b.height);
        
        // Add all boundary cells to the heap
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (i == 0 || i == rows - 1 || j == 0 || j == cols - 1) {
                    minHeap.offer(new Cell(i, j, heightMap[i][j]));
                    visited[i][j] = true;
                }
            }
        }
        
        int totalWater = 0;
        int currentLevel = 0;
        
        while (!minHeap.isEmpty()) {
            Cell cell = minHeap.poll();
            currentLevel = Math.max(currentLevel, cell.height);
            
            // Explore neighbors
            for (int[] dir : directions) {
                int newRow = cell.row + dir[0];
                int newCol = cell.col + dir[1];
                
                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols 
                    && !visited[newRow][newCol]) {
                    
                    // Calculate trapped water
                    if (currentLevel > heightMap[newRow][newCol]) {
                        totalWater += currentLevel - heightMap[newRow][newCol];
                    }
                    
                    // Add neighbor to heap with its actual height
                    minHeap.offer(new Cell(newRow, newCol, heightMap[newRow][newCol]));
                    visited[newRow][newCol] = true;
                }
            }
        }
        
        return totalWater;
    }
}

class Cell {
    int row;
    int col;
    int height;
    
    Cell(int r, int c, int h) {
        row = r;
        col = c;
        height = h;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(mn log(mn)) | Each cell processed once with heap operations |
| **Space**       | O(mn)       | Visited matrix and heap storage |

## üìä Example Walkthrough
**Input:** 3x3 heightMap
```
[1,4,3]
[3,2,1] 
[2,3,3]
```

**Execution:**
1. Add boundary to heap: corners (1,3,2,3) and edges
2. Process lowest boundary (height=1):
   - Update level = max(0,1) = 1
   - Explore neighbors
3. Continue processing:
   - When processing height=2 cell, level=2
   - Neighbor height=1 ‚Üí water += 2-1 = 1
4. Final water = sum of all such calculations

## üí° Key Features
- **Min-Heap Priority**: Always expand from lowest boundary
- **Level Propagation**: Water level increases as higher boundaries encountered
- **BFS-like Expansion**: Systematic exploration of all cells
- **Early Water Calculation**: Compute trapped water when first visiting cell

## üöÄ When to Use
- 2D water trapping problems
- When boundary conditions determine solution
- Problems requiring level-by-level processing
- Geometric optimization challenges

## ‚ö†Ô∏è Edge Cases
- **Small grids**: <3x3 cannot trap water
- **Flat surfaces**: No water trapped if all same height
- **All boundaries high**: Central low areas trap water
- **Single cell**: No water trapped

## üõ† Variations
1. **Different Neighborhoods**:
```java
// Include diagonal neighbors (8-direction)
```

2. **Multiple Sources**:
```java
// Water flowing from multiple entry points
```

3. **Flow Simulation**:
```java
// Simulate actual water flow paths
```

4. **Visualization**:
```java
// Show water accumulation step by step
```

5. **Generalization**:
```java
// 3D water trapping problems
```

## Mathematical Insight
The solution leverages:
- Properties of min-heaps for optimal processing order
- The concept of "water level" as maximum boundary encountered
- BFS traversal with priority ordering
- The fact that water trapped = max(0, boundary_level - cell_height)

## Alternative Implementation (Without Custom Class)
```java
// Use int[] instead of custom Cell class
PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);
// where int[] = {row, col, height}
```
Note: The custom Cell class improves readability, but using arrays can be more memory efficient. The algorithm remains the same in both implementations.