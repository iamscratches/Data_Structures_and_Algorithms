# üìà Adjacent Increasing Subarrays Detection II - Sequence Tracking Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-ii/description/?envType=daily-question&envId=2025-10-15)

Given:
- A list of integers `nums`
- We need to find the **maximum k** such that there exist **two adjacent increasing subarrays** each of length at least `k`

**Definitions:**
- An **increasing subarray** is a contiguous subarray where `nums[i] < nums[i+1] < nums[i+2] < ...`
- Two subarrays are **adjacent** if the end of the first is immediately before the start of the second
- Both subarrays must have length **at least k**

Find:
- The maximum possible value of `k` satisfying the condition

**Constraints:**
- `2 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^9`

**Example:**
```text
Input: nums = [2,5,7,8,9,2,3,4,3,1]
Output: 3

Explanation:
We can find two adjacent increasing subarrays of length 3:
- [2,5,7,8,9] (length 5 ‚â• 3)
- [2,3,4] (length 3 ‚â• 3)
No larger k is possible, so answer is 3.
```

## üß† Intuition
The solution uses:
1. **Increasing Sequence Tracking**: Monitor lengths of consecutive increasing sequences
2. **Adjacent Pair Evaluation**: Compare previous and current increasing sequences
3. **Maximum k Tracking**: Continuously update the maximum valid k found
4. **Sequence Splitting**: Consider splitting long sequences into two adjacent halves

Key Insights:
- We need to find the maximum k where two back-to-back increasing sequences both have length ‚â• k
- The sequences can be either:
  - Two separate adjacent increasing sequences
  - One long sequence split into two adjacent halves
- The limiting factor is the minimum length of the two sequences

## ‚öôÔ∏è Approach
1. **Track Variables**:
   - `currentMax`: length of current increasing sequence
   - `prevMax`: length of previous increasing sequence  
   - `k`: maximum valid value found so far

2. **Iterate Through Array**:
   - If current element > previous: extend current sequence
   - Else: store current as previous, reset current
   - Update k based on adjacent sequences and sequence splitting

3. **Update Logic**:
   - **Case 1**: Two adjacent sequences ‚Üí `k = min(prevMax, currentMax)`
   - **Case 2**: Split long sequence ‚Üí `k = currentMax / 2`
   - Take the maximum of all possibilities

## ‚úÖ Optimized Solution
```java
class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int prevMax = 0;       // Length of previous increasing sequence
        int currentMax = 1;    // Length of current increasing sequence  
        int k = 0;             // Maximum valid k found
        
        for (int i = 1; i < nums.size(); i++) {
            int currentNum = nums.get(i);
            int prevNum = nums.get(i - 1);
            
            if (currentNum > prevNum) {
                currentMax++;  // Extend current increasing sequence
            } else {
                // Sequence broken - update previous and reset current
                prevMax = currentMax;
                currentMax = 1;
            }
            
            // Update k based on adjacent sequences
            if (Math.min(prevMax, currentMax) > k) {
                k = Math.min(prevMax, currentMax);
            }
            
            // Update k based on sequence splitting
            if (k < (currentMax >> 1)) {
                k = currentMax >> 1;  // Equivalent to currentMax / 2
            }
        }
        
        return k;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through the array |
| **Space**       | O(1)       | Constant extra variables |

## üìä Example Walkthrough
**Input:** nums = [2,5,7,8,9,2,3,4,3,1]

**Processing:**
- i=1: 5>2 ‚Üí currentMax=2, prevMax=0 ‚Üí k=max(0,1)=1
- i=2: 7>5 ‚Üí currentMax=3, prevMax=0 ‚Üí k=max(1,1)=1  
- i=3: 8>7 ‚Üí currentMax=4, prevMax=0 ‚Üí k=max(1,2)=2
- i=4: 9>8 ‚Üí currentMax=5, prevMax=0 ‚Üí k=max(2,2)=2
- i=5: 2<9 ‚Üí prevMax=5, currentMax=1 ‚Üí k=max(2,0)=2
- i=6: 3>2 ‚Üí currentMax=2, prevMax=5 ‚Üí k=max(2,2)=2
- i=7: 4>3 ‚Üí currentMax=3, prevMax=5 ‚Üí k=max(2,3)=3 ‚úì
  - min(5,3)=3 > current k=2 ‚Üí update to 3
- i=8: 3<4 ‚Üí prevMax=3, currentMax=1 ‚Üí k remains 3
- i=9: 1<3 ‚Üí prevMax=1, currentMax=1 ‚Üí k remains 3

**Output:** 3 ‚úì

## üí° Key Features
- **Single Pass**: Processes array in linear time
- **State Tracking**: Maintains only previous and current sequence lengths
- **Bit Optimization**: Uses `>> 1` for efficient division by 2
- **Dual Strategy**: Considers both adjacent sequences and sequence splitting

## üöÄ When to Use
- Sequence pattern detection problems
- Finding maximum constraints in adjacent segments
- Problems involving consecutive increasing sequences
- Optimization problems with adjacent constraints

## ‚ö†Ô∏è Edge Cases
- **All increasing**: Can split into two equal halves ‚Üí k = n/2
- **No increasing sequences**: k = 0 (but constraints ensure at least length 1 sequences)
- **Alternating sequences**: k = 1 (minimum possible)
- **Single break point**: Maximum at the transition point

## üõ† Variations
1. **Explicit Case Handling**:
```java
// Separate logic for adjacent sequences vs splitting
```

2. **Array Preprocessing**:
```java
// Precompute all increasing sequence lengths first
```

3. **Sliding Window**:
```java
// Use sliding window to find valid adjacent pairs
```

## Alternative Implementation (More Readable)
```java
class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int prevLength = 0;    // Length of previous increasing sequence
        int currLength = 1;    // Length of current increasing sequence
        int maxK = 0;          // Maximum valid k found
        
        for (int i = 1; i < n; i++) {
            if (nums.get(i) > nums.get(i - 1)) {
                currLength++;
            } else {
                // Sequence broken - update previous and reset current
                prevLength = currLength;
                currLength = 1;
            }
            
            // Case 1: Check adjacent sequences (previous and current)
            int adjacentK = Math.min(prevLength, currLength);
            if (adjacentK > maxK) {
                maxK = adjacentK;
            }
            
            // Case 2: Check if we can split current long sequence
            int splitK = currLength / 2;
            if (splitK > maxK) {
                maxK = splitK;
            }
        }
        
        return maxK;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Monotonic Sequences**: Properties of strictly increasing subsequences
- **Adjacency Constraint**: Sequences must be back-to-back
- **Minimum Principle**: The limiting factor is the shorter sequence length
- **Sequence Splitting**: A sequence of length L can be split into two adjacent sequences of length L/2

**Key Formulas:**
- **Adjacent Sequences**: `k ‚â§ min(prevLength, currLength)`
- **Sequence Splitting**: `k ‚â§ floor(currLength / 2)`
- **Overall Maximum**: `k = max(all possible min(prev, curr) and all floor(curr/2))`

The algorithm efficiently finds the optimal k by continuously tracking the lengths of increasing sequences and evaluating both possible ways to form adjacent increasing subarrays: either from two separate sequences or by splitting one long sequence.