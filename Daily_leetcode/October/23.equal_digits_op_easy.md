# ðŸ”¢ Check If Digits Are Equal in String After Operations I - Iterative Reduction Approach

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/check-if-digits-are-equal-in-string-after-operations-i/description/?envType=daily-question&envId=2025-10-23)

Given:
- A string `s` consisting of digits (0-9)
- Repeatedly apply the following operation:
  - Replace each adjacent pair `(s[i], s[i+1])` with `(s[i] + s[i+1]) % 10`
  - The operation reduces the string length by 1 each time

Find:
- After reducing to exactly 2 characters, check if both remaining digits are equal
- Return `true` if the final two digits are equal, `false` otherwise

**Operation:**
- For each adjacent pair `(a, b)`, compute `(a + b) % 10`
- Apply this to all adjacent pairs simultaneously
- String length decreases by 1 after each operation

**Constraints:**
- `3 <= s.length <= 100`
- `s` consists only of digits ('0'-'9')

**Example:**
```text
Input: s = "3902"
Output: true

Explanation:
Step 1: "3902" â†’ 
  (3+9)%10=2, (9+0)%10=9, (0+2)%10=2 â†’ "292"
Step 2: "292" â†’ 
  (2+9)%10=1, (9+2)%10=1 â†’ "11"
Step 3: Both digits are equal (1=1) â†’ true
```

## ðŸ§  Intuition
The solution uses:
1. **Iterative Reduction**: Repeatedly apply the operation until only 2 digits remain
2. **In-place Modification**: Update array values in each iteration
3. **Modular Arithmetic**: Use `% 10` to keep results as single digits
4. **Direct Simulation**: Follow the operation rules exactly as described

Key Insights:
- The operations must be applied sequentially until only 2 digits remain
- Each iteration reduces length by 1
- We only care about the final equality check of the last 2 digits
- The process is deterministic and can be simulated directly

## âš™ï¸ Approach
1. **Convert to Array**: Convert string to integer array for easier manipulation
2. **Iterative Reduction**:
   - While length > 2, repeatedly:
     - For each position, compute `(arr[i] + arr[i+1]) % 10`
     - Reduce effective length by 1
3. **Final Check**: Compare the two remaining digits

## âœ… Optimized Solution
```java
class Solution {
    public boolean hasSameDigits(String s) {
        // Convert string to integer array
        int[] arr = new int[s.length()];
        for (int i = 0; i < s.length(); i++) {
            arr[i] = s.charAt(i) - '0';  // More efficient than Integer.parseInt
        }
        
        int len = s.length();
        
        // Keep reducing until only 2 digits remain
        while (len > 2) {
            // Apply operation to all adjacent pairs
            for (int i = 0; i < len - 1; i++) {
                arr[i] = (arr[i] + arr[i + 1]) % 10;
            }
            len--;  // Reduce effective length
        }
        
        // Check if the final two digits are equal
        return arr[0] == arr[1];
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(nÂ²)      | n operations, each taking O(current length) |
| **Space**       | O(n)       | Array to store digits |

## ðŸ“Š Example Walkthrough
**Input:** s = "3902"

**Step 0:** arr = [3,9,0,2], len=4

**Iteration 1 (len=4â†’3):**
- arr[0] = (3+9)%10 = 2
- arr[1] = (9+0)%10 = 9  
- arr[2] = (0+2)%10 = 2
- arr becomes [2,9,2], len=3

**Iteration 2 (len=3â†’2):**
- arr[0] = (2+9)%10 = 1
- arr[1] = (9+2)%10 = 1
- arr becomes [1,1], len=2

**Final Check:** 1 == 1 â†’ return `true` âœ“

**Another Example:** s = "123"
- Step 1: (1+2)%10=3, (2+3)%10=5 â†’ "35"
- Final: 3 != 5 â†’ return `false`

## ðŸ’¡ Key Features
- **Direct Simulation**: Follows problem description exactly
- **Efficient Conversion**: Use `char - '0'` instead of `Integer.parseInt`
- **In-place Updates**: Modify array without creating new arrays
- **Early Termination**: Stop when exactly 2 digits remain

## ðŸš€ When to Use
- Problems with iterative transformation rules
- When you need to simulate a process step-by-step
- Reduction problems where size decreases each step
- Deterministic transformation sequences

## âš ï¸ Edge Cases
- **All zeros**: Always results in equal digits (0=0)
- **All same digits**: May or may not result in equality
- **Length 3**: Only one reduction step needed
- **Large digits**: Modular arithmetic handles overflow

## ðŸ›  Variations
1. **Recursive Approach**:
```java
public boolean hasSameDigits(String s) {
    if (s.length() == 2) {
        return s.charAt(0) == s.charAt(1);
    }
    StringBuilder next = new StringBuilder();
    for (int i = 0; i < s.length() - 1; i++) {
        int sum = (s.charAt(i) - '0' + s.charAt(i + 1) - '0') % 10;
        next.append(sum);
    }
    return hasSameDigits(next.toString());
}
```

2. **Mathematical Optimization**:
```java
// For some patterns, mathematical properties can predict result
```

3. **Dynamic Programming**:
```java
// Could use DP for more complex variants
```

## Alternative Implementation (String-Based)
```java
class Solution {
    public boolean hasSameDigits(String s) {
        while (s.length() > 2) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < s.length() - 1; i++) {
                int digit1 = s.charAt(i) - '0';
                int digit2 = s.charAt(i + 1) - '0';
                int newDigit = (digit1 + digit2) % 10;
                sb.append(newDigit);
            }
            s = sb.toString();
        }
        return s.charAt(0) == s.charAt(1);
    }
}
```

## Mathematical Insight
The solution leverages:
- **Modular Arithmetic**: `(a + b) % 10` ensures results stay in 0-9 range
- **Iterative Transformation**: Each step is a linear combination of previous digits
- **Deterministic Process**: Same input always produces same output
- **Reduction Property**: Length decreases monotonically

**Key Observation:**
The process is similar to computing binomial coefficients modulo 10, but with a twist - each reduction step combines adjacent elements rather than following Pascal's triangle exactly.

The algorithm provides a straightforward solution by directly simulating the described process, making it easy to understand and verify correctness while efficiently handling the given constraints.