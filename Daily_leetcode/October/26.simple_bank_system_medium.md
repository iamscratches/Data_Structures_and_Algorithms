# üè¶ Simple Bank System - Object-Oriented Design

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/simple-bank-system/description/?envType=daily-question&envId=2025-10-26)

Design a simple bank system with the following operations:

**Initialization:**
- `Bank(long[] balance)`: Initialize accounts with given balances

**Operations:**
1. `transfer(int account1, int account2, long money)`
   - Transfer money from account1 to account2
   - Return `true` if successful, `false` otherwise

2. `deposit(int account, long money)`
   - Deposit money into account
   - Return `true` if successful, `false` otherwise

3. `withdraw(int account, long money)`
   - Withdraw money from account
   - Return `true` if successful, `false` otherwise

**Validation Rules:**
- Accounts are 1-indexed
- Invalid account numbers should return `false`
- Insufficient balance for transfer/withdrawal should return `false`
- Amount must be non-negative (implied constraint)

**Constraints:**
- `n == balance.length`
- `1 <= n, account, account1, account2 <= 10^5`
- `0 <= balance[i] <= 10^12`
- `0 <= money <= 10^12`
- At most `10^4` calls will be made to each function

**Examples:**
```text
Input:
["Bank", "withdraw", "transfer", "deposit", "transfer", "withdraw"]
[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]

Output:
[null, true, true, true, false, false]

Explanation:
Bank bank = new Bank([10, 100, 20, 50, 30]);
bank.withdraw(3, 10);    // return true, account 3 has 20, so 20-10=10
bank.transfer(5, 1, 20); // return true, account 5 has 30, 30-20=10, account 1 becomes 10+20=30
bank.deposit(5, 20);     // return true, account 5 becomes 10+20=30
bank.transfer(3, 4, 15); // return false, account 3 has 10 < 15
bank.withdraw(10, 50);   // return false, account 10 doesn't exist
```

## üß† Intuition
The solution uses:
1. **Direct Array Access**: Store balances in array for O(1) operations
2. **Input Validation**: Check account validity and sufficient balance
3. **Atomic Operations**: Each operation either completes fully or fails
4. **1-indexed Handling**: Convert 1-based accounts to 0-based array indices

Key Insights:
- Array provides optimal O(1) time complexity for all operations
- Pre-validation ensures data consistency
- Simple arithmetic operations for balance updates
- Error handling for edge cases

## ‚öôÔ∏è Approach
1. **Initialization**:
   - Store balances array and its length
   - Accounts are 1-indexed but stored in 0-indexed array

2. **Transfer Operation**:
   - Validate both accounts exist
   - Check if source account has sufficient balance
   - Update both accounts atomically

3. **Deposit Operation**:
   - Validate account exists
   - Add amount to account balance

4. **Withdraw Operation**:
   - Validate account exists
   - Check sufficient balance
   - Subtract amount from account balance

5. **Validation Helper**:
   - Check if account number is within valid range

## ‚úÖ Optimized Solution
```java
class Bank {
    private final long[] bal;  // Account balances (0-indexed)
    private final int n;       // Number of accounts

    public Bank(long[] balance) {
        this.bal = balance;
        this.n = balance.length;
    }
    
    public boolean transfer(int account1, int account2, long money) {
        // Validate both accounts and check sufficient balance
        if (!valid(account1) || !valid(account2) || bal[account1 - 1] < money) {
            return false;
        }
        // Perform transfer atomically
        bal[account1 - 1] -= money;
        bal[account2 - 1] += money;
        return true;
    }
    
    public boolean deposit(int account, long money) {
        // Validate account exists
        if (!valid(account)) {
            return false;
        }
        // Add money to account
        bal[account - 1] += money;
        return true;
    }
    
    public boolean withdraw(int account, long money) {
        // Validate account and check sufficient balance
        if (!valid(account) || bal[account - 1] < money) {
            return false;
        }
        // Subtract money from account
        bal[account - 1] -= money;
        return true;
    }
    
    // Helper method to validate account number
    private boolean valid(int account) {
        return account > 0 && account <= n;
    }
}
```

## ‚è≥ Complexity Analysis
| Operation     | Time Complexity | Space Complexity |
|---------------|-----------------|------------------|
| **Constructor** | O(1)          | O(n)             |
| **transfer**  | O(1)            | O(1)             |
| **deposit**   | O(1)            | O(1)             |
| **withdraw**  | O(1)            | O(1)             |

## üìä Example Walkthrough
**Input:** `[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]`

**Initialization:**
- Accounts: [10, 100, 20, 50, 30] (accounts 1-5)

**Operation 1:** `withdraw(3, 10)`
- Account 3 has 20, 20 ‚â• 10 ‚Üí valid
- Update: account 3 = 20 - 10 = 10
- Return: `true`

**Operation 2:** `transfer(5, 1, 20)`
- Account 5 has 30, 30 ‚â• 20 ‚Üí valid
- Update: account 5 = 30 - 20 = 10, account 1 = 10 + 20 = 30
- Return: `true`

**Operation 3:** `deposit(5, 20)`
- Account 5 exists ‚Üí valid
- Update: account 5 = 10 + 20 = 30
- Return: `true`

**Operation 4:** `transfer(3, 4, 15)`
- Account 3 has 10, 10 < 15 ‚Üí insufficient balance
- Return: `false`

**Operation 5:** `withdraw(10, 50)`
- Account 10 doesn't exist (n=5)
- Return: `false`

## üí° Key Features
- **Constant Time Operations**: O(1) for all methods
- **Data Integrity**: Pre-validation prevents invalid operations
- **Atomic Updates**: Operations complete fully or fail completely
- **Memory Efficient**: Only stores necessary balance array

## üöÄ When to Use
- Financial transaction systems
- Account management applications
- Systems requiring atomic operations
- Problems with multiple validation checks

## ‚ö†Ô∏è Edge Cases
- **Invalid account numbers**: Return false immediately
- **Insufficient balance**: Check before any modification
- **Zero amount transactions**: Technically valid
- **Maximum constraints**: Handle large numbers (up to 10^12)
- **Self-transfer**: account1 = account2 (still valid)

## üõ† Variations
1. **With Transaction Logging**:
```java
class Bank {
    private final long[] bal;
    private final List<String> transactionLog;
    
    public boolean transfer(int from, int to, long amt) {
        if (!valid(from) || !valid(to) || bal[from-1] < amt) return false;
        bal[from-1] -= amt;
        bal[to-1] += amt;
        transactionLog.add("Transfer: " + from + "->" + to + ": " + amt);
        return true;
    }
}
```

2. **With Balance Limits**:
```java
class Bank {
    private final long[] bal;
    private final long maxBalance;
    
    public boolean deposit(int acc, long amt) {
        if (!valid(acc) || bal[acc-1] + amt > maxBalance) return false;
        bal[acc-1] += amt;
        return true;
    }
}
```

3. **Thread-Safe Version**:
```java
class Bank {
    private final long[] bal;
    private final Object lock = new Object();
    
    public boolean transfer(int from, int to, long amt) {
        synchronized(lock) {
            if (!valid(from) || !valid(to) || bal[from-1] < amt) return false;
            bal[from-1] -= amt;
            bal[to-1] += amt;
            return true;
        }
    }
}
```

## Design Patterns Used
1. **Facade Pattern**: Simple interface for complex banking operations
2. **Data Transfer Object**: Balance array as core data structure
3. **Validation Pattern**: Pre-operation validation checks
4. **Atomic Operation Pattern**: All-or-nothing transaction semantics

## Performance Considerations
- **Array vs HashMap**: Array provides better performance for sequential accounts
- **Bounds Checking**: Essential for security and data integrity
- **Memory Layout**: Array has better cache locality than linked structures
- **Scalability**: Suitable for up to 10^5 accounts and 10^4 operations

The solution provides an optimal balance of simplicity, performance, and correctness for the given problem constraints, making it suitable for real-world banking system implementations.