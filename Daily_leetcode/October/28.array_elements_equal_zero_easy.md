# üéØ Make Array Elements Equal to Zero - Simulation Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/make-array-elements-equal-to-zero/description/?envType=daily-question&envId=2025-10-28)

Given:
- An array `nums` of non-negative integers
- You start at any index where `nums[i] == 0`
- Movement rules:
  - If current element is 0, continue in same direction
  - If current element is non-zero:
    - Decrement the element by 1
    - Reverse direction
- Process ends when you move out of bounds

Find:
- The number of **valid starting positions** from which the entire array becomes zeros after the process

**Process Rules:**
1. Start at any index where `nums[i] == 0`
2. Choose initial direction: left or right
3. Move according to rules until out of bounds
4. Array is valid if all elements become 0 after process

**Constraints:**
- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`

**Example:**
```text
Input: nums = [1,0,2,0,3]
Output: 2

Explanation:
Valid starting positions:
- Start at index 1 (value 0), direction right
- Start at index 3 (value 0), direction left
Both lead to all elements becoming 0.
```

## üß† Intuition
The solution uses:
1. **Brute Force Simulation**: Try every possible starting position and direction
2. **State Tracking**: Track current position and direction
3. **Array Modification**: Decrement non-zero elements when encountered
4. **Validation Check**: Verify if array becomes all zeros after process

Key Insights:
- Only start from positions where `nums[i] == 0`
- For each starting position, try both directions (left and right)
- Simulate the entire movement process
- Check if array becomes all zeros at the end

## ‚öôÔ∏è Approach
1. **Iterate Through Array**: For each index where `nums[i] == 0`
2. **Try Both Directions**: 
   - Direction = 1 (right)
   - Direction = -1 (left)
3. **Simulate Process**:
   - Start at current position
   - While within bounds:
     - If current element is 0: continue in same direction
     - If current element > 0: decrement it and reverse direction
4. **Validate Result**: Check if all elements become 0
5. **Count Valid Starts**: Increment count for each valid starting position+direction

## ‚úÖ Solution
```java
class Solution {
    public int countValidSelections(int[] nums) {
        int count = 0;
        
        // Try every possible starting position
        for (int i = 0; i < nums.length; i++) {
            // Only start from positions with value 0
            if (nums[i] == 0) {
                
                // Try direction = 1 (right)
                int[] arr = nums.clone();
                int direction = 1;
                int curr = i;
                
                // Simulate movement process
                while (curr >= 0 && curr < arr.length) {
                    if (arr[curr] == 0) {
                        // Continue in same direction
                        curr += direction;
                    } else {
                        // Reverse direction and decrement
                        direction = direction > 0 ? -1 : 1;
                        arr[curr]--;
                        curr += direction;
                    }
                }
                
                // Check if all elements became zero
                boolean isValid = true;
                for (int j = 0; j < arr.length; j++) {
                    if (arr[j] != 0) {
                        isValid = false;
                        break;
                    }
                }
                if (isValid) {
                    count++;
                }
                
                // Try direction = -1 (left)
                arr = nums.clone();
                direction = -1;
                curr = i;
                
                // Simulate movement process
                while (curr >= 0 && curr < arr.length) {
                    if (arr[curr] == 0) {
                        // Continue in same direction
                        curr += direction;
                    } else {
                        // Reverse direction and decrement
                        direction = direction > 0 ? -1 : 1;
                        arr[curr]--;
                        curr += direction;
                    }
                }
                
                // Check if all elements became zero
                isValid = true;
                for (int j = 0; j < arr.length; j++) {
                    if (arr[j] != 0) {
                        isValid = false;
                        break;
                    }
                }
                if (isValid) {
                    count++;
                }
            }
        }
        
        return count;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n¬≥)      | n starts √ó 2 directions √ó n steps simulation |
| **Space**       | O(n)       | Clone array for simulation |

**Note:** Constraints are small (n ‚â§ 100), so O(n¬≥) is acceptable

## üìä Example Walkthrough
**Input:** nums = [1,0,2,0,3]

**Process for index 1 (value 0), direction right:**
1. Start at index 1 (0) ‚Üí move right to index 2
2. Index 2: value 2 > 0 ‚Üí decrement to 1, reverse direction (left), move to index 1
3. Index 1: value 0 ‚Üí move left to index 0
4. Index 0: value 1 > 0 ‚Üí decrement to 0, reverse direction (right), move to index 1
5. Index 1: value 0 ‚Üí move right to index 2
6. Index 2: value 1 > 0 ‚Üí decrement to 0, reverse direction (left), move to index 1
7. Index 1: value 0 ‚Üí move left to index 0
8. Index 0: value 0 ‚Üí move left to index -1 (out of bounds)

**Check array:** [0,0,0,0,3] ‚Üí NOT valid (index 4 still has 3)

**Process for index 1 (value 0), direction left:**
1. Start at index 1 (0) ‚Üí move left to index 0
2. Index 0: value 1 > 0 ‚Üí decrement to 0, reverse direction (right), move to index 1
3. Index 1: value 0 ‚Üí move right to index 2
4. Index 2: value 2 > 0 ‚Üí decrement to 1, reverse direction (left), move to index 1
5. Continue until all elements become 0 ‚Üí VALID

**Similarly test other starting positions...**

## üí° Key Features
- **Exhaustive Search**: Try all possible starting positions and directions
- **Simulation-Based**: Faithfully implements the movement rules
- **State Preservation**: Clone array to avoid modifying original
- **Complete Validation**: Check entire array after simulation

## üöÄ When to Use
- Problems with complex state transitions
- When brute force is feasible due to constraints
- Simulation-based problems
- Path exploration with state modification

## ‚ö†Ô∏è Edge Cases
- **All zeros**: Every position is valid starting point
- **Single element**: Simple case with limited movement
- **No zeros**: No valid starting positions
- **Large values**: Longer simulation but bounded by constraints

## üõ† Optimizations
1. **Early Termination**:
```java
// Stop simulation if it becomes clear array won't become all zeros
```

2. **Memoization**:
```java
// Cache results for same array state and position
```

3. **Mathematical Analysis**:
```java
// Derive conditions without full simulation
```

## Alternative Implementation (Optimized with Early Check)
```java
class Solution {
    public int countValidSelections(int[] nums) {
        int count = 0;
        int n = nums.length;
        
        for (int start = 0; start < n; start++) {
            if (nums[start] == 0) {
                // Try both directions
                for (int initialDir : new int[]{-1, 1}) {
                    if (simulateAndCheck(nums, start, initialDir)) {
                        count++;
                    }
                }
            }
        }
        return count;
    }
    
    private boolean simulateAndCheck(int[] nums, int start, int initialDir) {
        int[] arr = nums.clone();
        int dir = initialDir;
        int pos = start;
        
        while (pos >= 0 && pos < arr.length) {
            if (arr[pos] == 0) {
                pos += dir;
            } else {
                dir = -dir;  // Reverse direction
                arr[pos]--;
                pos += dir;
            }
        }
        
        // Check if all elements are zero
        for (int num : arr) {
            if (num != 0) return false;
        }
        return true;
    }
}
```

## Mathematical Insight
The solution leverages:
- **State Machine**: Position and direction form the state
- **Deterministic Process**: Same inputs always produce same outputs
- **Exhaustive Verification**: Must check all possibilities due to complex rules
- **Constraint-Based**: Feasible due to small input size

**Key Challenges:**
- Movement depends on current array state
- Direction changes create complex paths
- Need to verify final state, not just path

The simulation approach, while computationally intensive, guarantees correctness by faithfully implementing the problem rules and checking all possible starting configurations. For the given constraints, this brute-force method is both practical and reliable.