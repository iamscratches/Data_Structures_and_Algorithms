# 🌊 Pacific Atlantic Water Flow - Multi-Source DFS Approach

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/pacific-atlantic-water-flow/description/?envType=daily-question&envId=2025-10-05)

Given:
- An `m x n` rectangular island with heights `heights[r][c]`
- Pacific Ocean borders the top and left edges
- Atlantic Ocean borders the bottom and right edges

Find:
- All cells where water can flow to **both** Pacific and Atlantic oceans
- Water flows from a cell to adjacent cells (up, down, left, right) if the adjacent cell's height is **equal or lower**

**Flow Rule:**
- Water flows from higher/equal elevation to lower/equal elevation
- A cell can drain to ocean if there's a path of non-increasing heights to that ocean

**Constraints:**
- `m == heights.length`
- `n == heights[r].length`
- `1 <= m, n <= 200`
- `0 <= heights[r][c] <= 10⁵`

**Example:**
```text
Input: heights = [
  [1,2,2,3,5],
  [3,2,3,4,4],
  [2,4,5,3,1],
  [6,7,1,4,5],
  [5,1,1,2,4]
]
Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
Explanation: These cells can drain to both Pacific and Atlantic oceans.
```

## 🧠 Intuition
The solution uses:
1. **Reverse Thinking**: Instead of checking where water flows FROM each cell, check where water can reach TO oceans
2. **Multi-Source DFS**: Start from ocean borders and flow uphill
3. **Two Separate Searches**: One for Pacific reachable cells, one for Atlantic reachable cells
4. **Intersection**: Cells reachable from both oceans are the answer

Key Insights:
- Water flows downhill, so we reverse the flow and go uphill from oceans
- Pacific-accessible cells: start from top/left borders
- Atlantic-accessible cells: start from bottom/right borders
- The intersection gives cells that drain to both oceans

## ⚙️ Approach
1. **Initialize Visited Matrices**: 
   - `pacific[m][n]` - tracks cells reachable from Pacific
   - `atlantic[m][n]` - tracks cells reachable from Atlantic

2. **Multi-Source DFS from Pacific**:
   - Start DFS from all top row cells (row 0)
   - Start DFS from all left column cells (column 0)

3. **Multi-Source DFS from Atlantic**:
   - Start DFS from all bottom row cells (row m-1)
   - Start DFS from all right column cells (column n-1)

4. **Find Intersection**:
   - Cells that are marked in both `pacific` and `atlantic` matrices

## ✅ Optimized Solution
```java
class Solution {
    private int m, n;
    private int[][] directions = {{1,0}, {-1,0}, {0,1}, {0,-1}};

    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        m = heights.length;
        n = heights[0].length;
        boolean[][] pacific = new boolean[m][n];
        boolean[][] atlantic = new boolean[m][n];
        
        // Multi-source DFS from Pacific borders
        for (int j = 0; j < n; j++) dfs(0, j, heights, pacific);
        for (int i = 0; i < m; i++) dfs(i, 0, heights, pacific);
        
        // Multi-source DFS from Atlantic borders  
        for (int j = 0; j < n; j++) dfs(m - 1, j, heights, atlantic);
        for (int i = 0; i < m; i++) dfs(i, n - 1, heights, atlantic);

        // Find intersection of both reachable sets
        List<List<Integer>> result = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (pacific[i][j] && atlantic[i][j]) {
                    result.add(Arrays.asList(i, j));
                }
            }
        }
        return result;
    }

    private void dfs(int i, int j, int[][] heights, boolean[][] visited) {
        if (visited[i][j]) return;
        visited[i][j] = true;
        
        for (int[] d : directions) {
            int x = i + d[0], y = j + d[1];
            // Check bounds
            if (x < 0 || x >= m || y < 0 || y >= n) continue;
            // Check if we can flow uphill (reverse of actual water flow)
            if (heights[x][y] < heights[i][j]) continue;
            dfs(x, y, heights, visited);
        }
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(m × n)   | Each cell visited at most twice (Pacific + Atlantic) |
| **Space**       | O(m × n)   | Two visited matrices + recursion stack depth |

## 📊 Example Walkthrough
**Input:** heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]

**Pacific Reachable (from top/left):**
- Top row: (0,0), (0,1), (0,2), (0,3), (0,4)
- Left column: (1,0), (2,0), (3,0), (4,0)
- Plus cells reachable via uphill flow

**Atlantic Reachable (from bottom/right):**
- Bottom row: (4,0), (4,1), (4,2), (4,3), (4,4)
- Right column: (0,4), (1,4), (2,4), (3,4)
- Plus cells reachable via uphill flow

**Intersection:** [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]

## 💡 Key Features
- **Reverse Flow**: Start from oceans and go uphill instead of checking all paths from each cell
- **Multi-Source BFS/DFS**: Efficiently mark all reachable cells from multiple starting points
- **Two-Pass Approach**: Separate searches for each ocean
- **Early Pruning**: Skip already visited cells and invalid moves

## 🚀 When to Use
- Grid traversal problems with multiple sources
- Problems involving reachability from boundaries
- When you need to find intersection of multiple reachable sets
- Flood-fill type problems with elevation constraints

## ⚠️ Edge Cases
- **Single cell grid**: Returns that single cell
- **Flat terrain**: All cells might be reachable from both oceans
- **Mountain in center**: Only border cells might be reachable
- **Large grids**: Handles maximum constraints efficiently

## 🛠 Variations
1. **BFS Implementation**:
```java
// Use Queue instead of recursion for DFS
```

2. **Union-Find Approach**:
```java
// Connect cells based on flow rules and find connected components
```

3. **Single Pass Optimization**:
```java
// Single DFS that tracks both oceans simultaneously
```

4. **Direction Variations**:
```java
// Include diagonal movements for different problem variants
```

5. **Minimum Height Difference**:
```java
// Water flows only if height difference >= threshold
```

## Mathematical Insight
The solution leverages:
- **Graph Theory**: Treat grid as graph with elevation-based edges
- **Reachability Analysis**: Finding all nodes reachable from source sets
- **Set Intersection**: Combining results from multiple searches
- **Monotonic Paths**: Only moving to equal or higher elevations

## Alternative Implementation (BFS Version)
```java
class Solution {
    private int[][] directions = {{1,0}, {-1,0}, {0,1}, {0,-1}};
    
    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        int m = heights.length, n = heights[0].length;
        boolean[][] pacific = new boolean[m][n];
        boolean[][] atlantic = new boolean[m][n];
        
        Queue<int[]> pQueue = new LinkedList<>();
        Queue<int[]> aQueue = new LinkedList<>();
        
        // Initialize queues with border cells
        for (int i = 0; i < m; i++) {
            pQueue.offer(new int[]{i, 0});
            aQueue.offer(new int[]{i, n-1});
            pacific[i][0] = true;
            atlantic[i][n-1] = true;
        }
        for (int j = 0; j < n; j++) {
            pQueue.offer(new int[]{0, j});
            aQueue.offer(new int[]{m-1, j});
            pacific[0][j] = true;
            atlantic[m-1][j] = true;
        }
        
        // BFS for Pacific
        bfs(heights, pQueue, pacific);
        // BFS for Atlantic
        bfs(heights, aQueue, atlantic);
        
        // Find intersection
        List<List<Integer>> result = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (pacific[i][j] && atlantic[i][j]) {
                    result.add(Arrays.asList(i, j));
                }
            }
        }
        return result;
    }
    
    private void bfs(int[][] heights, Queue<int[]> queue, boolean[][] visited) {
        int m = heights.length, n = heights[0].length;
        
        while (!queue.isEmpty()) {
            int[] cell = queue.poll();
            int i = cell[0], j = cell[1];
            
            for (int[] d : directions) {
                int x = i + d[0], y = j + d[1];
                if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y] 
                    && heights[x][y] >= heights[i][j]) {
                    visited[x][y] = true;
                    queue.offer(new int[]{x, y});
                }
            }
        }
    }
}
```

Note: The BFS version avoids recursion stack overflow for very large grids and provides the same time complexity with slightly different memory characteristics.