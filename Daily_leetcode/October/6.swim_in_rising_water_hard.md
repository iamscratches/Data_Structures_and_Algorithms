# üèä Swim in Rising Water - Union-Find Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/swim-in-rising-water/description/?envType=daily-question&envId=2025-10-06)

Given:
- An `n x n` grid where `grid[i][j]` represents the elevation at that cell
- It starts raining, and the water level rises at a constant rate
- You can swim from one cell to adjacent cells (4-directional) if both cells are at or below the current water level

Find:
- The **minimum time** (water level) required for you to swim from top-left `(0,0)` to bottom-right `(n-1, n-1)`

**Movement Rule:**
- At time `t`, you can move between adjacent cells if both have elevation ‚â§ t
- You start at time 0, but can only swim when water level ‚â• cell elevation

**Constraints:**
- `n == grid.length`
- `n == grid[i].length`
- `1 <= n <= 50`
- `0 <= grid[i][j] < n¬≤`
- Each value is unique

**Example:**
```text
Input: grid = [
  [0,  2,  1],
  [3,  4,  5],
  [6,  7,  8]
]
Output: 3
Explanation: 
At time 0: Can only stay at (0,0)
At time 1: Can reach (0,2) but not further
At time 2: Can reach (0,1) but not cross to bottom-right
At time 3: Path exists: 0‚Üí2‚Üí1‚Üí5‚Üí8
```

## üß† Intuition
The solution uses:
1. **Union-Find (DSU)**: Connect cells as water level rises
2. **Edge-Based Approach**: Treat adjacent cells as edges with weight = max elevation of the two cells
3. **Gradual Connection**: Connect cells in increasing order of required water level
4. **Early Termination**: Stop when start and end cells become connected

Key Insights:
- The minimum time equals the maximum elevation along the optimal path
- As water rises, more cells become accessible
- When start and end connect, we've found the minimum required water level
- Each edge's "cost" is the maximum of its two endpoint elevations

## ‚öôÔ∏è Approach
1. **Generate Edges**: 
   - Create edges between all adjacent cells (right and down)
   - Edge weight = max(grid[i][j], grid[neighbor])

2. **Sort Edges**: Sort all edges by their weight (required water level)

3. **Union-Find Setup**: Initialize DSU with all cells as separate components

4. **Process Edges**:
   - Process edges in increasing order of weight
   - Union the two cells connected by each edge
   - Check if start (0,0) and end (n-1,n-1) are connected
   - Return the current edge weight when they connect

## ‚úÖ Optimized Solution
```java
class Solution {
    public int swimInWater(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        List<int[]> edges = new ArrayList<>();
        
        // Generate all possible edges between adjacent cells
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // Right edge
                if (i > 0)
                    edges.add(new int[]{
                        Math.max(grid[i][j], grid[i-1][j]),  // weight
                        i*n+j,                               // cell1
                        (i-1)*n+j                           // cell2
                    });
                // Down edge  
                if (j > 0)
                    edges.add(new int[]{
                        Math.max(grid[i][j], grid[i][j-1]),  // weight
                        i*n+j,                               // cell1
                        i*n+j-1                             // cell2
                    });
            }
        }
        
        // Sort edges by weight (required water level)
        Collections.sort(edges, (a, b) -> a[0] - b[0]);
        
        // Initialize Union-Find
        int[] parent = new int[m * n];
        for (int i = 0; i < m * n; i++) parent[i] = i;
        
        // Process edges in increasing order
        for (int[] edge : edges) {
            union(parent, edge[1], edge[2]);
            // Check if start (0) and end (m*n-1) are connected
            if (find(parent, 0) == find(parent, m*n-1))
                return edge[0];
        }
        
        // If no path found (shouldn't happen for valid input)
        return grid[0][0];
    }
    
    private int find(int[] parent, int x) {
        if (parent[x] != x)
            parent[x] = find(parent, parent[x]);  // Path compression
        return parent[x];
    }
    
    private void union(int[] parent, int x, int y) {
        parent[find(parent, x)] = find(parent, y);
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n¬≤ log n)| Sorting O(n¬≤ log n) edges + Union-Find O(n¬≤ Œ±(n)) |
| **Space**       | O(n¬≤)      | Storing edges and Union-Find data structure |

## üìä Example Walkthrough
**Input:** grid = [[0,2,1],[3,4,5],[6,7,8]]

**Edge Generation:**
- (0,0)-(0,1): max(0,2)=2
- (0,0)-(1,0): max(0,3)=3
- (0,1)-(0,2): max(2,1)=2
- (0,1)-(1,1): max(2,4)=4
- (0,2)-(1,2): max(1,5)=5
- (1,0)-(1,1): max(3,4)=4
- (1,0)-(2,0): max(3,6)=6
- (1,1)-(1,2): max(4,5)=5
- (1,1)-(2,1): max(4,7)=7
- (1,2)-(2,2): max(5,8)=8
- (2,0)-(2,1): max(6,7)=7
- (2,1)-(2,2): max(7,8)=8

**Processing:**
- Connect edges with weight 2: (0,0)-(0,1), (0,1)-(0,2)
- Connect edges with weight 3: (0,0)-(1,0)
- Now start (0,0) connects to (1,0), (0,1), (0,2)
- Continue until start and end connect at weight 3

## üí° Key Features
- **Union-Find Efficiency**: Near-linear time complexity with path compression
- **Edge-Centric**: Focuses on connections rather than individual cells
- **Incremental Connectivity**: Builds connected components as water rises
- **Early Termination**: Stops immediately when path is found

## üöÄ When to Use
- Grid connectivity problems with thresholds
- Minimum bottleneck path problems
- When you need to find when two points become connected
- Problems with incremental accessibility

## ‚ö†Ô∏è Edge Cases
- **1x1 grid**: Return grid[0][0]
- **All cells same elevation**: Return that elevation
- **Direct path available**: Minimum of max elevations along direct path
- **Maximum constraints**: Handles 50x50 grid efficiently

## üõ† Variations
1. **Binary Search + BFS/DFS**:
```java
// Binary search on time, BFS/DFS to check connectivity
```

2. **Dijkstra's Algorithm**:
```java
// Treat as shortest path where edge cost = max elevation
```

3. **Priority Queue Approach**:
```java
// Always expand the cell with minimum elevation
```

4. **Different Movement Rules**:
```java
// 8-directional movement or different cost functions
```

## Mathematical Insight
The solution leverages:
- **Graph Theory**: Grid as graph with elevation-based edge weights
- **Union-Find**: Efficient connectivity queries
- **Bottleneck Path**: Finding path that minimizes maximum edge weight
- **Monotonicity**: Connectivity only increases with time

## Alternative Implementation (Binary Search + BFS)
```java
class Solution {
    private int[][] directions = {{1,0}, {-1,0}, {0,1}, {0,-1}};
    
    public int swimInWater(int[][] grid) {
        int n = grid.length;
        int left = grid[0][0];
        int right = n * n - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (canReach(grid, mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
    
    private boolean canReach(int[][] grid, int time) {
        int n = grid.length;
        boolean[][] visited = new boolean[n][n];
        Queue<int[]> queue = new LinkedList<>();
        
        if (grid[0][0] <= time) {
            queue.offer(new int[]{0, 0});
            visited[0][0] = true;
        }
        
        while (!queue.isEmpty()) {
            int[] cell = queue.poll();
            int i = cell[0], j = cell[1];
            
            if (i == n-1 && j == n-1) return true;
            
            for (int[] d : directions) {
                int x = i + d[0], y = j + d[1];
                if (x >= 0 && x < n && y >= 0 && y < n && 
                    !visited[x][y] && grid[x][y] <= time) {
                    visited[x][y] = true;
                    queue.offer(new int[]{x, y});
                }
            }
        }
        return false;
    }
}
```

**Comparison:**
- **Union-Find**: More efficient for this specific problem pattern
- **Binary Search + BFS**: More intuitive, easier to understand
- **Union-Find**: Better worst-case performance
- **Binary Search**: More flexible for different constraints

The Union-Find approach elegantly solves this by treating it as a connectivity problem that increases monotonically with time.