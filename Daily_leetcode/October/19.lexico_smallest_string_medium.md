# 🔤 Lexicographically Smallest String After Applying Operations - BFS Approach

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/description/?envType=daily-question&envId=2025-10-19)

Given:
- A string `s` of even length consisting of digits (0-9)
- Two operations:
  1. **Add**: Add `a` to all odd-indexed elements (mod 10)
  2. **Rotate**: Rotate the string right by `b` positions

Find:
- The **lexicographically smallest string** that can be obtained by applying any number of operations in any order

**Operations:**
- **Add Operation**: For all odd indices `i`, `s[i] = (s[i] - '0' + a) % 10 + '0'`
- **Rotate Operation**: Right rotate by `b` positions

**Constraints:**
- `2 <= s.length <= 100`
- `1 <= a <= 9`
- `1 <= b <= s.length - 1`

**Example:**
```text
Input: s = "5525", a = 9, b = 2
Output: "2050"

Explanation:
Operation sequences:
1. Rotate: "5525" → "2555"
2. Add: "2555" → "2454" (odd indices: 5→4, 5→4)
3. Add: "2454" → "2353"
4. Add: "2353" → "2252"
5. Add: "2252" → "2151"
6. Add: "2151" → "2050"
```

## 🧠 Intuition
The solution uses:
1. **BFS/State Search**: Explore all reachable string states
2. **Visited Set**: Avoid processing duplicate states
3. **Two Operations**: Generate new states by applying both operations
4. **Lexicographical Comparison**: Track the smallest string found

Key Insights:
- The operations can be applied in any order and any number of times
- The state space is finite due to modulo 10 and finite string length
- BFS ensures we explore all reachable states
- We need to track the smallest string encountered

## ⚙️ Approach
1. **BFS Initialization**: Start with the original string
2. **State Exploration**: For each state, generate two new states:
   - **Add Operation**: Add `a` to all odd indices (mod 10)
   - **Rotate Operation**: Right rotate by `b` positions
3. **Duplicate Prevention**: Use a set to track visited states
4. **Smallest Tracking**: Continuously update the smallest string

## ✅ Optimized Solution
```java
class Solution {
    public String findLexSmallestString(String s, int a, int b) {
        Set<String> visited = new HashSet<>();  // Track visited states
        String smallest = s;                    // Track smallest string
        Deque<String> queue = new ArrayDeque<>(); // BFS queue
        
        queue.offer(s);
        visited.add(s);
        
        while (!queue.isEmpty()) {
            String current = queue.poll();
            
            // Update smallest string
            if (current.compareTo(smallest) < 0) {
                smallest = current;
            }
            
            // Operation 1: Add 'a' to all odd indices
            StringBuilder sb = new StringBuilder(current);
            for (int i = 1; i < sb.length(); i += 2) {
                char original = sb.charAt(i);
                int newDigit = (original - '0' + a) % 10;
                sb.setCharAt(i, (char)(newDigit + '0'));
            }
            String addedString = sb.toString();
            
            // If new state not visited, add to queue
            if (visited.add(addedString)) {
                queue.offer(addedString);
            }
            
            // Operation 2: Rotate right by 'b' positions
            String rotatedString = current.substring(current.length() - b) + 
                                 current.substring(0, current.length() - b);
            
            // If new state not visited, add to queue
            if (visited.add(rotatedString)) {
                queue.offer(rotatedString);
            }
        }
        
        return smallest;
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n × 10^n) | In practice much better due to state reuse |
| **Space**       | O(10^n)    | Store visited states |

**Note:** While worst-case is exponential, in practice:
- Only 10 possible values per digit
- String length ≤ 100 but operations create cycles
- Actual states explored are much smaller

## 📊 Example Walkthrough
**Input:** s = "5525", a = 9, b = 2

**BFS Process:**
1. **Initial**: "5525" → smallest = "5525"
2. **From "5525":**
   - **Add**: "5525" → "5414" (5+9=14→4, 5+9=14→4)
   - **Rotate**: "5525" → "2555"
   - Add both to queue

3. **From "5414":**
   - **Add**: "5414" → "5303"
   - **Rotate**: "5414" → "1454"  
   - Continue exploring...

4. **From "2555":**
   - **Add**: "2555" → "2444"
   - **Rotate**: "2555" → "5525" (already visited)
   - Continue exploring...

**Eventually finds "2050" as smallest**

## 💡 Key Features
- **Complete Exploration**: BFS ensures all reachable states are visited
- **State Pruning**: Visited set prevents redundant processing
- **Efficient Operations**: String manipulation optimized
- **Lexicographical Tracking**: Continuous smallest string update

## 🚀 When to Use
- State space exploration problems
- When operations can be applied repeatedly
- Problems with finite but large state spaces
- Finding optimal states through transformations

## ⚠️ Edge Cases
- **a = 0**: Add operation does nothing
- **b = 0**: Rotate operation does nothing  
- **b = length**: Full rotation, back to original
- **All digits same**: Limited state space
- **a = 5, b even/odd**: Different cycle behaviors

## 🛠 Variations
1. **DFS Approach**:
```java
// Use DFS with recursion instead of BFS
```

2. **Mathematical Optimization**:
```java
// Analyze cycles mathematically to reduce search space
```

3. **Priority Queue**:
```java
// Use priority queue to always expand smallest string first
```

## Mathematical Insight
The solution leverages:
- **Group Theory**: Operations form a group acting on the string
- **Modular Arithmetic**: Add operation cycles every 10 steps
- **Cycle Detection**: Rotation creates cycles of length LCM(n, b)/b
- **State Space**: Finite due to modulo constraints

**Key Observations:**
- Add operation only affects odd indices
- Rotation can make any position become an odd index eventually
- The state space is bounded by 10^(n/2) × n for practical purposes

## Alternative Implementation (Optimized with Cycle Analysis)
```java
class Solution {
    public String findLexSmallestString(String s, int a, int b) {
        String smallest = s;
        int n = s.length();
        
        // Try all possible rotations
        for (int rotation = 0; rotation < n; rotation++) {
            String rotated = s.substring(n - rotation) + s.substring(0, n - rotation);
            
            // For odd indices, try all possible additions (0-9 cycles)
            for (int add1 = 0; add1 < 10; add1++) {
                char[] arr = rotated.toCharArray();
                
                // Apply addition to odd indices
                for (int i = 1; i < n; i += 2) {
                    arr[i] = (char)((arr[i] - '0' + add1 * a) % 10 + '0');
                }
                
                // If b is odd, even indices can also be modified through rotations
                if (b % 2 == 1) {
                    for (int add2 = 0; add2 < 10; add2++) {
                        char[] temp = arr.clone();
                        for (int i = 0; i < n; i += 2) {
                            temp[i] = (char)((temp[i] - '0' + add2 * a) % 10 + '0');
                        }
                        String candidate = new String(temp);
                        if (candidate.compareTo(smallest) < 0) {
                            smallest = candidate;
                        }
                    }
                } else {
                    String candidate = new String(arr);
                    if (candidate.compareTo(smallest) < 0) {
                        smallest = candidate;
                    }
                }
            }
        }
        return smallest;
    }
}
```

The BFS approach provides a straightforward and correct solution by systematically exploring all reachable states, while the mathematical optimization leverages insights about the problem structure to reduce the search space significantly.