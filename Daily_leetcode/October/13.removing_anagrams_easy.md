# 🔤 Find Resultant Array After Removing Anagrams - String Processing Approach

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/find-resultant-array-after-removing-anagrams/description/?envType=daily-question&envId=2025-10-13)

Given:
- An array of strings `words`
- Two words are **anagrams** if they contain the same characters in different orders
- Remove any word that is an anagram of the immediately preceding word

Find:
- The resultant array after removing all such anagrams

**Rules:**
- Process the array from left to right
- If `words[i]` is an anagram of `words[i-1]`, remove `words[i]`
- Keep the first occurrence of each anagram group

**Constraints:**
- `1 <= words.length <= 100`
- `1 <= words[i].length <= 10`
- `words[i]` consists of lowercase English letters

**Example:**
```text
Input: words = ["abba","baba","bbaa","cd","cd"]
Output: ["abba","cd"]

Explanation:
- "abba" is kept (first element)
- "baba" is anagram of "abba" → removed
- "bbaa" is anagram of "abba" → removed  
- "cd" is kept (not anagram of previous "abba")
- "cd" is anagram of previous "cd" → removed
```

## 🧠 Intuition
The solution uses:
1. **Anagram Detection**: Sort characters to identify anagrams
2. **Sequential Processing**: Compare each word with its immediate predecessor
3. **First Occurrence Preservation**: Keep the first word of each anagram group
4. **Simple Comparison**: Only compare with directly preceding word

Key Insights:
- Two words are anagrams if their sorted character sequences are equal
- We only need to compare each word with its immediate predecessor
- The first word in any anagram sequence is always kept
- Processing is linear and straightforward

## ⚙️ Approach
1. **Initialize Result**: Start with the first word in the result list
2. **Track Previous**: Store the sorted version of the last kept word
3. **Iterate Through Words**:
   - For each word, compute its sorted character representation
   - Compare with previous sorted word
   - If different, add to result and update previous
   - If same, skip (remove the anagram)
4. **Return Result**: The filtered list of words

## ✅ Optimized Solution
```java
class Solution {
    public List<String> removeAnagrams(String[] words) {
        List<String> result = new ArrayList<>();
        
        // Always add the first word
        result.add(words[0]);
        String prevSorted = sortWord(words[0]);
        
        // Process remaining words
        for (int i = 1; i < words.length; i++) {
            String currentSorted = sortWord(words[i]);
            
            // Only add if not an anagram of previous word
            if (!prevSorted.equals(currentSorted)) {
                result.add(words[i]);
                prevSorted = currentSorted; // Update previous for next comparison
            }
            // If it is an anagram, skip it (implicitly removed)
        }
        
        return result;
    }
    
    // Helper method to sort characters of a string
    private String sortWord(String str) {
        char[] characters = str.toCharArray();
        Arrays.sort(characters);
        return new String(characters); // More efficient than StringBuilder
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n × k log k) | n words, each sorted in O(k log k) |
| **Space**       | O(k)       | Temporary array for sorting (k = word length) |

Where:
- `n = words.length` (up to 100)
- `k = words[i].length` (up to 10)

## 📊 Example Walkthrough
**Input:** words = ["abba","baba","bbaa","cd","cd"]

**Processing:**
1. **Start**: result = ["abba"], prevSorted = "aabb"
2. **Word 1**: "baba" → sorted = "aabb" 
   - Equal to prevSorted → skip
3. **Word 2**: "bbaa" → sorted = "aabb"
   - Equal to prevSorted → skip  
4. **Word 3**: "cd" → sorted = "cd"
   - Different from prevSorted ("aabb") → add to result
   - result = ["abba","cd"], prevSorted = "cd"
5. **Word 4**: "cd" → sorted = "cd"
   - Equal to prevSorted → skip

**Output:** ["abba","cd"] ✓

## 💡 Key Features
- **Simple and Efficient**: Linear pass with constant-time comparisons
- **Anagram Detection**: Character sorting provides reliable anagram check
- **Minimal Memory**: Only stores previous sorted word
- **Clear Logic**: Easy to understand and implement

## 🚀 When to Use
- String processing with anagram detection
- Sequential filtering based on previous element
- Problems requiring adjacent element comparison
- When you need to remove duplicates with custom equality

## ⚠️ Edge Cases
- **Single word array**: Return the array as-is
- **All anagrams**: Return only the first word
- **No anagrams**: Return all words
- **Empty array**: Shouldn't occur per constraints
- **Different lengths**: Automatically not anagrams

## 🛠 Variations
1. **Frequency Array Approach**:
```java
private boolean isAnagram(String a, String b) {
    if (a.length() != b.length()) return false;
    int[] freq = new int[26];
    for (char c : a.toCharArray()) freq[c-'a']++;
    for (char c : b.toCharArray()) {
        if (--freq[c-'a'] < 0) return false;
    }
    return true;
}
```

2. **Using HashMap**:
```java
// Store character counts for anagram detection
```

3. **In-Place Modification**:
```java
// Modify the input array instead of creating new list
```

## Alternative Implementation (Frequency Counting)
```java
class Solution {
    public List<String> removeAnagrams(String[] words) {
        List<String> result = new ArrayList<>();
        result.add(words[0]);
        
        int[] prevFreq = getFrequency(words[0]);
        
        for (int i = 1; i < words.length; i++) {
            int[] currFreq = getFrequency(words[i]);
            
            if (!Arrays.equals(prevFreq, currFreq)) {
                result.add(words[i]);
                prevFreq = currFreq;
            }
        }
        
        return result;
    }
    
    private int[] getFrequency(String word) {
        int[] freq = new int[26];
        for (char c : word.toCharArray()) {
            freq[c - 'a']++;
        }
        return freq;
    }
}
```

## Performance Comparison
| Approach | Time Complexity | Best For |
|----------|----------------|----------|
| **Character Sorting** | O(n × k log k) | Short strings (k ≤ 10) |
| **Frequency Array** | O(n × k) | Longer strings |
| **HashMap Counting** | O(n × k) | When character set is large |

**Why Sorting is Better Here:**
- Maximum word length is 10, so k log k ≈ 10 × 3.3 ≈ 33 operations
- Frequency array: 26 operations per word
- Sorting is simpler and more readable for this constraint range

## Mathematical Insight
The solution leverages:
- **Anagram Property**: Two strings are anagrams iff their sorted forms are equal
- **Transitive Relation**: If A≈B and B≈C, then A≈C (but we only check adjacent pairs)
- **Sequential Filtering**: Linear scan with single previous state tracking
- **String Transformation**: Normalize strings to canonical form for comparison

The approach efficiently solves the problem by recognizing that we only need local comparisons (each word with its immediate predecessor) rather than global anagram grouping, making it both simple and optimal for the given constraints.