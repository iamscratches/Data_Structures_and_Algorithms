# ‚ö° Maximum Total Damage with Spell Casting - Dynamic Programming Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/maximum-total-damage-with-spell-casting/description/?envType=daily-question&envId=2025-10-11)

Given:
- An array `power` where `power[i]` represents the damage power of a spell
- You can cast spells, but cannot cast spells with power values within 2 of each other
- For example: if you cast spell with power 5, you cannot cast spells with power 3, 4, 5, 6, or 7

Find:
- The **maximum total damage** you can achieve by selecting spells optimally

**Constraints:**
- Cannot cast spells with power values `p-2, p-1, p, p+1, p+2` together
- You can cast multiple spells of the same power
- Total damage = sum of (spell power √ó frequency) for selected spells

**Formal Rule:**
- If you select spells with power `p`, you cannot select any spells with power in the range `[p-2, p+2]`

**Constraints:**
- `1 <= power.length <= 10^5`
- `1 <= power[i] <= 10^5`

**Example:**
```text
Input: power = [1,1,3,4]
Output: 6

Explanation:
- Spell powers: 1 (frequency 2), 3 (frequency 1), 4 (frequency 1)
- Options:
  * Take power 1: 1√ó2 = 2, cannot take 3 or 4
  * Take power 3: 3√ó1 = 3, cannot take 1 or 4  
  * Take power 4: 4√ó1 = 4, cannot take 1 or 3
  * Take power 1 and 4: 2 + 4 = 6 ‚úì (since |1-4| = 3 > 2)
```

## üß† Intuition
The solution uses:
1. **Frequency Counting**: Group spells by power and calculate total damage per power
2. **Sorting**: Process spells in increasing order of power
3. **Dynamic Programming**: Decide whether to take current spell power or skip it
4. **Binary Search**: Efficiently find the last compatible spell power

Key Insights:
- Spells of the same power can be taken together (no conflict)
- The constraint creates ranges of incompatible spells
- If we take power `p`, we cannot take powers `p-2, p-1, p+1, p+2`
- We need to find the optimal selection considering these conflicts

## ‚öôÔ∏è Approach
1. **Frequency Calculation**: Count occurrences of each spell power
2. **Sort Unique Powers**: Process in increasing order
3. **DP State**: `dp[i]` = maximum damage using first `i+1` unique powers
4. **Transition**:
   - **Option 1**: Skip current power ‚Üí `dp[i-1]`
   - **Option 2**: Take current power ‚Üí `current_damage + dp[last_compatible]`
5. **Binary Search**: Find the last power that is compatible (‚â§ current_power - 3)

## ‚úÖ Optimized Solution
```java
class Solution {
    public long maximumTotalDamage(int[] power) {
        // Step 1: Count frequency of each spell power
        Map<Integer, Long> freq = new HashMap<>();
        for (int p : power) {
            freq.put(p, freq.getOrDefault(p, 0L) + 1);
        }

        // Step 2: Get sorted unique powers
        List<Integer> keys = new ArrayList<>(freq.keySet());
        Collections.sort(keys);

        int n = keys.size();
        long[] dp = new long[n];  // dp[i] = max damage using first i+1 unique powers
        
        // Base case: first power
        dp[0] = freq.get(keys.get(0)) * keys.get(0);

        // Step 3: Process each unique power
        for (int i = 1; i < n; i++) {
            int currentPower = keys.get(i);
            long currentDamage = freq.get(currentPower) * currentPower;
            
            // Find the last compatible power (‚â§ currentPower - 3)
            int prevCompatible = binarySearch(keys, i - 1, currentPower - 3);
            
            // Option 1: Take current power + compatible previous maximum
            long takeOption = currentDamage;
            if (prevCompatible >= 0) {
                takeOption += dp[prevCompatible];
            }
            
            // Option 2: Skip current power
            long skipOption = dp[i - 1];
            
            // Take maximum of both options
            dp[i] = Math.max(takeOption, skipOption);
        }

        return dp[n - 1];
    }

    // Binary search to find the largest index ‚â§ end with value ‚â§ target
    private int binarySearch(List<Integer> keys, int end, int target) {
        int left = 0, right = end;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (keys.get(mid) <= target) {
                result = mid;  // Valid candidate, try to find larger
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return result;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n log n) | Sorting + n binary searches |
| **Space**       | O(n)       | Frequency map + sorted keys + DP array |

Where `n` is the number of unique powers (‚â§ 10^5)

## üìä Example Walkthrough
**Input:** power = [1,1,3,4]

**Step 1 - Frequency Counting:**
- Power 1: frequency 2 ‚Üí damage = 2
- Power 3: frequency 1 ‚Üí damage = 3  
- Power 4: frequency 1 ‚Üí damage = 4

**Step 2 - Sorted Unique Powers:** [1, 3, 4]

**Step 3 - DP Processing:**
- **i=0 (power=1):** dp[0] = 2
- **i=1 (power=3):**
  - Current damage = 3
  - Find last compatible: power ‚â§ 3-3 = 0 ‚Üí none (-1)
  - Take option: 3 + 0 = 3
  - Skip option: dp[0] = 2
  - dp[1] = max(3, 2) = 3
- **i=2 (power=4):**
  - Current damage = 4
  - Find last compatible: power ‚â§ 4-3 = 1 ‚Üí index 0 (power=1)
  - Take option: 4 + dp[0] = 4 + 2 = 6
  - Skip option: dp[1] = 3
  - dp[2] = max(6, 3) = 6

**Output:** 6 ‚úì

## üí° Key Features
- **Frequency Aggregation**: Combine same powers for efficiency
- **Binary Search Optimization**: Quickly find compatible states
- **Classic DP Pattern**: Take/Skip decision with constraints
- **Sorted Processing**: Enables efficient compatibility checking

## üöÄ When to Use
- Selection problems with conflict constraints
- When choices affect nearby elements
- Problems with "no adjacent" or "range exclusion" rules
- Optimization with frequency counts

## ‚ö†Ô∏è Edge Cases
- **All same power**: Can only take that one power
- **Large gaps between powers**: No conflicts, take all
- **Consecutive powers**: Must skip every 2-3 powers
- **Single element**: Return that element's total damage

## üõ† Variations
1. **Space Optimized DP**:
```java
// Only store last few DP values since we only need dp[last_compatible]
```

2. **Iterative without Binary Search**:
```java
// Use pointer to track last compatible instead of binary search
```

3. **Different Conflict Ranges**:
```java
// Adjust the -3 constant for different exclusion ranges
```

## Space Optimized Implementation
```java
class Solution {
    public long maximumTotalDamage(int[] power) {
        Map<Integer, Long> freq = new HashMap<>();
        for (int p : power) freq.put(p, freq.getOrDefault(p, 0L) + 1);
        
        List<Integer> keys = new ArrayList<>(freq.keySet());
        Collections.sort(keys);
        
        int n = keys.size();
        long prev2 = 0, prev1 = 0;  // Store only last two DP values
        int j = 0;  // Pointer to last compatible power
        
        for (int i = 0; i < n; i++) {
            int currentPower = keys.get(i);
            long currentDamage = freq.get(currentPower) * currentPower;
            
            // Advance j until compatible
            while (j < i && keys.get(j) <= currentPower - 3) {
                prev2 = prev1;
                j++;
            }
            
            long takeOption = currentDamage + (j > 0 ? prev2 : 0);
            long skipOption = prev1;
            long current = Math.max(takeOption, skipOption);
            
            prev2 = prev1;
            prev1 = current;
        }
        
        return prev1;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Optimal Substructure**: Maximum for first i powers depends on previous maxima
- **Conflict Graph**: Powers form an interval graph where edges connect incompatible ranges
- **Weighted Interval Scheduling**: Classic DP pattern with binary search optimization
- **Monotonicity**: Sorted processing enables efficient compatibility checks

The approach efficiently handles the constraint by recognizing it as a weighted interval scheduling problem where each "job" (power value) conflicts with nearby jobs, and binary search helps quickly find the last compatible state for optimal DP transitions.