# 🔢 Smallest Missing Non-Negative Integer After Operations - Modular Arithmetic Approach

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/smallest-missing-non-negative-integer-after-operations/description/?envType=daily-question&envId=2025-10-16)

Given:
- An array `nums` of integers
- An integer `value`
- You can perform the following operation any number of times:
  - Add or subtract `value` from any element of the array

Find:
- The **smallest non-negative integer** that cannot be obtained by summing a subset of the array elements after any number of operations

**Operations:**
- For any element `nums[i]`, you can add/subtract `value` any number of times
- This effectively means each element can be transformed to any number congruent to it modulo `value`

**Constraints:**
- `1 <= nums.length <= 10^5`
- `1 <= value <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

**Example:**
```text
Input: nums = [1,-10,7,13,6,8], value = 5
Output: 4

Explanation:
After operations, we can get numbers with remainders:
- 1 → 1, 6, 11, ... (remainder 1)
- -10 → 0, 5, 10, ... (remainder 0)  
- 7 → 2, 7, 12, ... (remainder 2)
- 13 → 3, 8, 13, ... (remainder 3)
- 6 → 1, 6, 11, ... (remainder 1)
- 8 → 3, 8, 13, ... (remainder 3)

We can form:
0 (from -10), 1 (from 1), 2 (from 7), 3 (from 13)
But cannot form 4 → answer is 4
```

## 🧠 Intuition
The solution uses:
1. **Modular Arithmetic**: Transform problem to residue classes modulo `value`
2. **Frequency Counting**: Count how many elements have each remainder
3. **Mex Finding**: Find smallest missing number using remainder availability
4. **Greedy Construction**: Build numbers sequentially until we can't continue

Key Insights:
- After operations, each element contributes its residue class modulo `value`
- We can form number `x` if we have enough elements with remainder `x % value`
- The problem reduces to finding the smallest `res` where we don't have enough elements with remainder `res % value`

## ⚙️ Approach
1. **Normalize Remainders**: Convert all numbers to their non-negative residues modulo `value`
2. **Count Frequencies**: Store count of each remainder in `rem` array
3. **Greedy Construction**: 
   - Start from 0 and increment `res`
   - For each `res`, check if we have elements with remainder `res % value`
   - Use one element from that remainder class
   - Stop when we run out of elements for a required remainder

## ✅ Optimized Solution
```java
class Solution {
    public int findSmallestInteger(int[] nums, int value) {
        int n = nums.length;
        int[] rem = new int[value];  // Count of each remainder
        
        // Step 1: Count frequencies of each remainder
        for (int x : nums) {
            // Normalize remainder to range [0, value-1]
            int r = ((x % value) + value) % value;
            rem[r]++;
        }
        
        // Step 2: Find smallest missing integer
        int res = 0;
        // Keep building numbers while we have elements for remainder (res % value)
        while (rem[res % value]-- > 0) {
            res++;
        }
        
        return res;
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through array + linear scan |
| **Space**       | O(value)   | Array to store remainder counts |

## 📊 Example Walkthrough
**Input:** nums = [1,-10,7,13,6,8], value = 5

**Step 1 - Calculate Remainders:**
- 1 % 5 = 1
- -10 % 5 = 0 (normalized: (-10 + 5) % 5 = 0)
- 7 % 5 = 2  
- 13 % 5 = 3
- 6 % 5 = 1
- 8 % 5 = 3

**Step 2 - Count Frequencies:**
```
rem[0] = 1  (from -10)
rem[1] = 2  (from 1, 6)
rem[2] = 1  (from 7)
rem[3] = 2  (from 13, 8)
rem[4] = 0
```

**Step 3 - Build Numbers:**
- res=0: need rem[0]=1 → available, use it → rem[0]=0, res=1
- res=1: need rem[1]=2 → available, use it → rem[1]=1, res=2  
- res=2: need rem[2]=1 → available, use it → rem[2]=0, res=3
- res=3: need rem[3]=2 → available, use it → rem[3]=1, res=4
- res=4: need rem[4]=0 → NOT available → STOP

**Output:** 4 ✓

## 💡 Key Features
- **Modular Arithmetic**: Elegant transformation using residue classes
- **Greedy Algorithm**: Build smallest numbers first
- **Efficient Counting**: Linear time with constant space per remainder
- **Early Termination**: Stop at first missing number

## 🚀 When to Use
- Problems involving modular arithmetic
- When operations allow cycling through values
- Finding smallest missing number (Mex) with constraints
- Subset sum problems with modular constraints

## ⚠️ Edge Cases
- **All same remainder**: Answer = frequency of that remainder
- **value = 1**: All numbers become 0, answer = count of elements
- **Large negative numbers**: Proper remainder normalization crucial
- **Empty array**: Should return 0 (but constraints prevent this)

## 🛠 Variations
1. **Priority Queue Approach**:
```java
// Use min-heap to track available numbers
```

2. **Mathematical Formula**:
```java
// Direct formula based on remainder frequencies
```

3. **Binary Search**:
```java
// Binary search on the answer with feasibility check
```

## Alternative Implementation (More Explicit)
```java
class Solution {
    public int findSmallestInteger(int[] nums, int value) {
        int[] freq = new int[value];
        
        for (int num : nums) {
            int remainder = num % value;
            if (remainder < 0) {
                remainder += value;  // Normalize to [0, value-1]
            }
            freq[remainder]++;
        }
        
        int result = 0;
        while (true) {
            int requiredRemainder = result % value;
            if (freq[requiredRemainder] > 0) {
                freq[requiredRemainder]--;
                result++;
            } else {
                break;
            }
        }
        
        return result;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Residue Theorem**: Every integer is congruent to some r ∈ [0, value-1] modulo value
- **Mex Property**: Smallest missing non-negative integer in constructed set
- **Greedy Optimality**: Building numbers sequentially is optimal
- **Pigeonhole Principle**: When we run out of a remainder, we cannot form that number

**Key Observation:**
- We can form number `x` if we have at least `floor(x/value) + 1` elements with remainder `x % value`
- The while loop efficiently checks this condition incrementally

The algorithm elegantly solves the problem by recognizing that after the modular transformations, the problem reduces to a simple resource allocation problem where we assign remainder classes to construct consecutive integers until we exhaust one of the required resources.