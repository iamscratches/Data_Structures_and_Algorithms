# 🔢 Maximum Number of Distinct Elements After Operations - Greedy Approach

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/maximum-number-of-distinct-elements-after-operations/description/?envType=daily-question&envId=2025-10-18)

Given:
- An array `nums` of integers
- An integer `k`
- You can perform the following operation on each element:
  - Add or subtract any value in the range `[-k, k]` to/from the element

Find:
- The **maximum number of distinct elements** possible after operations

**Operations:**
- For each element `nums[i]`, you can change it to any value in `[nums[i]-k, nums[i]+k]`
- Each element can be modified independently
- Goal is to maximize the count of distinct values in the final array

**Constraints:**
- `1 <= nums.length <= 1000`
- `1 <= nums[i] <= 10^9`
- `0 <= k <= 10^9`

**Example:**
```text
Input: nums = [2,1,3,4], k = 1
Output: 4

Explanation:
We can assign:
- 2 → 2 (or 1 or 3)
- 1 → 1 (or 2)
- 3 → 3 (or 2 or 4)  
- 4 → 4 (or 3 or 5)
We can assign all to distinct values: 1, 2, 3, 4

Input: nums = [2,1,3,4], k = 0
Output: 4
(No changes allowed, but all are already distinct)
```

## 🧠 Intuition
The solution uses:
1. **Sorting**: Process numbers in increasing order
2. **Greedy Assignment**: Assign the smallest possible distinct value to each element
3. **Range Management**: Track the last assigned value to ensure distinctness
4. **Optimal Spacing**: Minimize gaps between assigned values

Key Insights:
- Sort numbers to process them in order
- For each number, assign the smallest possible value that:
  - Is within `[x-k, x+k]` range
  - Is greater than the previous assigned value
- This greedy approach ensures we maximize distinct counts

## ⚙️ Approach
1. **Sort the Array**: Process numbers from smallest to largest
2. **Initialize Tracking**:
   - `prev`: last assigned value (start with very small number)
   - `ans`: count of distinct elements
3. **Process Each Number**:
   - Calculate the smallest possible value we can assign: `max(x-k, prev+1)`
   - If this value is within the allowed range `[x-k, x+k]`, assign it
   - Update `prev` and increment count
4. **Return Result**: The maximum distinct count achieved

## ✅ Optimized Solution
```java
class Solution {
    public int maxDistinctElements(int[] nums, int k) {
        // Step 1: Sort the array to process in order
        Arrays.sort(nums);
        
        int ans = 0;                    // Count of distinct elements
        long prev = (long)-1e18;        // Last assigned value (use long to avoid overflow)
        
        // Step 2: Process each number greedily
        for (int x : nums) {
            // Calculate the smallest possible distinct value we can assign
            // Must be: ≥ (x - k) and > prev
            long lowerBound = Math.max((long)x - k, prev + 1);
            
            // Check if this value is within the allowed range
            if (lowerBound <= (long)x + k) {
                prev = lowerBound;  // Assign this value
                ans++;              // Count as distinct
            }
            // If no valid value exists, skip this element (cannot make it distinct)
        }
        
        return ans;
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n log n) | Sorting dominates |
| **Space**       | O(1)       | Only a few variables |

## 📊 Example Walkthrough
**Input:** nums = [2,1,3,4], k = 1

**Step 1 - Sort:** [1,2,3,4]

**Step 2 - Process:**
- **x=1**: 
  - lowerBound = max(1-1, -∞+1) = max(0, -∞) = 0
  - 0 ≤ 1+1=2 → valid, assign 0, prev=0, ans=1
- **x=2**:
  - lowerBound = max(2-1, 0+1) = max(1, 1) = 1  
  - 1 ≤ 2+1=3 → valid, assign 1, prev=1, ans=2
- **x=3**:
  - lowerBound = max(3-1, 1+1) = max(2, 2) = 2
  - 2 ≤ 3+1=4 → valid, assign 2, prev=2, ans=3
- **x=4**:
  - lowerBound = max(4-1, 2+1) = max(3, 3) = 3
  - 3 ≤ 4+1=5 → valid, assign 3, prev=3, ans=4

**Output:** 4 ✓

**Another Example:** nums = [3,3,3], k = 2

**Sort:** [3,3,3]
- **x=3**: lowerBound = max(1, -∞+1)=1 → valid, assign 1, prev=1, ans=1
- **x=3**: lowerBound = max(1, 1+1)=2 → valid, assign 2, prev=2, ans=2  
- **x=3**: lowerBound = max(1, 2+1)=3 → valid, assign 3, prev=3, ans=3

## 💡 Key Features
- **Greedy Optimal**: Always assign the smallest possible distinct value
- **Sorting Strategy**: Process numbers in order to minimize conflicts
- **Range Checking**: Efficiently verify feasibility
- **Overflow Protection**: Use long for large values

## 🚀 When to Use
- Assignment problems with ranges
- Maximizing distinct values under constraints
- Interval scheduling and assignment
- When elements have flexible values within ranges

## ⚠️ Edge Cases
- **k = 0**: No changes allowed, count original distinct elements
- **All same numbers**: Can still make distinct if k > 0
- **Very large k**: Can make all numbers distinct if ranges don't overlap
- **Single element**: Always distinct

## 🛠 Variations
1. **Priority Queue Approach**:
```java
// Use min-heap to track assigned values
```

2. **Two Pointer Technique**:
```java
// Process ranges without sorting
```

3. **Binary Search**:
```java
// Binary search on the maximum distinct count
```

## Alternative Implementation (Interval-Based)
```java
class Solution {
    public int maxDistinctElements(int[] nums, int k) {
        Arrays.sort(nums);
        int count = 0;
        long current = Long.MIN_VALUE;
        
        for (int num : nums) {
            long start = (long)num - k;
            long end = (long)num + k;
            
            // Try to assign the smallest possible value greater than current
            long assign = Math.max(start, current + 1);
            
            if (assign <= end) {
                count++;
                current = assign;
            }
        }
        
        return count;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Greedy Choice Property**: Optimal to assign smallest possible distinct value
- **Sorted Processing**: Ensures we don't "block" future assignments
- **Interval Intersection**: Each number provides an interval `[x-k, x+k]` of possible values
- **Distinctness Constraint**: Each assigned value must be greater than previous

**Key Formula:**
- For element `x`, assignable range: `[x-k, x+k]`
- To be distinct from previous `prev`: must assign value `≥ prev + 1`
- Valid if: `max(x-k, prev+1) ≤ x+k`

The algorithm elegantly solves the problem by recognizing that processing numbers in sorted order and greedily assigning the smallest possible distinct value within each element's range guarantees the maximum number of distinct elements.