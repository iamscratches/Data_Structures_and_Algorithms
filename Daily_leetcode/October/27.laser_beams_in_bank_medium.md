# üî¶ Number of Laser Beams in a Bank - Adjacent Row Counting Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/number-of-laser-beams-in-a-bank/description/?envType=daily-question&envId=2025-10-27)

Given:
- A string array `bank` representing the layout of a bank
- Each string represents a row, containing `'0'` (empty) and `'1'` (security device)
- Laser beams can be between security devices with rules:
  - Beams go **straight** (same column)
  - Beams only between **adjacent rows** that both have devices
  - Each device in one row connects to **all devices** in the next non-empty row

Find:
- The **total number of laser beams** in the bank

**Beam Rules:**
- Two devices form a beam if:
  1. They are in different rows
  2. They are in the same column  
  3. There are no devices in any row between them

**Constraints:**
- `m == bank.length`
- `n == bank[i].length`
- `1 <= m, n <= 500`
- `bank[i][j]` is either `'0'` or `'1'`

**Example:**
```text
Input: bank = ["011001","000000","010100","001000"]
Output: 8

Explanation:
Row 0: 3 devices  (011001 ‚Üí columns 1,2,5)
Row 1: 0 devices  (skipped)
Row 2: 2 devices  (010100 ‚Üí columns 1,3)  
Row 3: 1 device   (001000 ‚Üí column 2)

Beams:
- Row 0 to Row 2: 3 devices √ó 2 devices = 6 beams
- Row 2 to Row 3: 2 devices √ó 1 device = 2 beams
Total: 6 + 2 = 8 beams
```

## üß† Intuition
The solution uses:
1. **Device Counting**: Count security devices in each row
2. **Skip Empty Rows**: Ignore rows with no devices for beam calculations
3. **Adjacent Multiplication**: Multiply devices between consecutive non-empty rows
4. **Cumulative Sum**: Accumulate beams across all valid row pairs

Key Insights:
- Only consecutive non-empty rows form beams
- Number of beams between two rows = devices in row i √ó devices in row j
- Empty rows don't break the adjacency for beams
- We only care about the sequence of non-empty rows

## ‚öôÔ∏è Approach
1. **Initialize**: `prev` = devices in first non-empty row, `ans` = 0
2. **Process Each Row**:
   - Count devices in current row
   - If row has devices:
     - Add `prev √ó current` to answer (beams between previous and current)
     - Update `prev` to current device count
   - If row is empty, skip it (but maintain previous device count)
3. **Return Result**: Total accumulated beams

## ‚úÖ Optimized Solution
```java
class Solution {
    public int numberOfBeams(String[] bank) {
        int ans = 0;                    // Total laser beams
        int prev = 0;                   // Devices in previous non-empty row
        final int n = bank[0].length(); // Number of columns (constant)
        
        for (String row : bank) {
            int devices = 0;            // Count devices in current row
            
            // Count security devices in this row
            for (int j = 0; j < n; j++) {
                devices += (row.charAt(j) == '1' ? 1 : 0);
            }
            
            // Only process rows with devices
            if (devices > 0) {
                // Add beams between previous and current non-empty row
                ans += devices * prev;
                // Update previous to current for next calculation
                prev = devices;
            }
            // If row is empty (devices == 0), skip it but keep previous value
        }
        
        return ans;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(m √ó n)   | Process each cell in the bank |
| **Space**       | O(1)       | Only a few variables |

Where:
- `m` = number of rows
- `n` = number of columns

## üìä Example Walkthrough
**Input:** bank = ["011001","000000","010100","001000"]

**Processing:**
1. **Row 0**: "011001" ‚Üí devices = 3
   - First non-empty row: prev = 3, ans = 0

2. **Row 1**: "000000" ‚Üí devices = 0
   - Skip (empty row), prev remains 3

3. **Row 2**: "010100" ‚Üí devices = 2
   - Beams: 3 √ó 2 = 6 ‚Üí ans = 6
   - Update prev = 2

4. **Row 3**: "001000" ‚Üí devices = 1  
   - Beams: 2 √ó 1 = 2 ‚Üí ans = 8
   - Update prev = 1

**Output:** 8 ‚úì

**Another Example:** bank = ["1","1"]
- Row 0: devices = 1 ‚Üí prev = 1
- Row 1: devices = 1 ‚Üí beams = 1√ó1 = 1 ‚Üí ans = 1

## üí° Key Features
- **Efficient Counting**: Single pass through the bank
- **Skip Optimization**: Ignore empty rows without breaking logic
- **Simple Multiplication**: Beam count = product of adjacent device counts
- **Minimal State**: Only track previous non-empty row count

## üöÄ When to Use
- Grid processing with conditional relationships
- When you need to relate adjacent non-empty elements
- Problems involving products between consecutive groups
- Counting connections in sparse matrices

## ‚ö†Ô∏è Edge Cases
- **Single row**: No beams (ans = 0)
- **All empty rows**: No beams (ans = 0)
- **Single device per row**: Beams = 1 between each adjacent pair
- **Alternating empty/full**: Only full rows contribute to beams

## üõ† Variations
1. **Precompute Device Counts**:
```java
// First collect all non-zero device counts, then multiply adjacent pairs
```

2. **Functional Programming**:
```java
// Use streams to filter and process
```

3. **Two-Pass Approach**:
```java
// First pass: collect device counts, second pass: calculate beams
```

## Alternative Implementation (Precomputation)
```java
class Solution {
    public int numberOfBeams(String[] bank) {
        List<Integer> deviceCounts = new ArrayList<>();
        
        // First pass: collect device counts for non-empty rows
        for (String row : bank) {
            int count = 0;
            for (char c : row.toCharArray()) {
                if (c == '1') count++;
            }
            if (count > 0) {
                deviceCounts.add(count);
            }
        }
        
        // Second pass: calculate beams between consecutive rows
        int totalBeams = 0;
        for (int i = 1; i < deviceCounts.size(); i++) {
            totalBeams += deviceCounts.get(i - 1) * deviceCounts.get(i);
        }
        
        return totalBeams;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Combinatorial Multiplication**: Each device in row i connects to all in row j
- **Transitive Skip**: Empty rows don't affect the adjacency relationship
- **Cumulative Product**: Sum of products of consecutive elements
- **Sparse Processing**: Only process non-empty rows for beam calculations

**Key Formula:**
For consecutive non-empty rows with device counts `d1, d2, d3, ...`:
```
Total beams = d1√ód2 + d2√ód3 + d3√ód4 + ...
```

The algorithm efficiently solves the problem by recognizing that we only need to track the sequence of non-empty rows and that the beam count between any two such rows is simply the product of their device counts. The solution handles empty rows gracefully by skipping them while maintaining the correct adjacency for beam calculations.