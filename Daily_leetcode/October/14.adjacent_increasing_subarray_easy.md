# üìà Adjacent Increasing Subarrays Detection - Sliding Window Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-i/description/?envType=daily-question&envId=2025-10-14)

Given:
- A list of integers `nums`
- An integer `k`
- We need to find if there exist **two adjacent increasing subarrays** each of length at least `k`

**Definitions:**
- An **increasing subarray** is a contiguous subarray where `nums[i] < nums[i+1] < nums[i+2] < ...`
- Two subarrays are **adjacent** if the end of the first is immediately before the start of the second
- Both subarrays must have length **at least k**

Find:
- Return `true` if such two adjacent increasing subarrays exist, `false` otherwise

**Constraints:**
- `2 <= nums.length <= 100`
- `1 <= k <= floor(nums.length / 2)`
- `1 <= nums[i] <= 1000`

**Example:**
```text
Input: nums = [2,5,7,8,9,2,3,4,3,1], k = 3
Output: true

Explanation:
Two adjacent increasing subarrays:
- [2,5,7,8,9] (length 5 ‚â• 3)
- [2,3,4] (length 3 ‚â• 3)
They are adjacent: first ends at index 4, second starts at index 5
```

## üß† Intuition
The solution uses:
1. **Increasing Sequence Tracking**: Track lengths of consecutive increasing sequences
2. **Adjacent Pair Checking**: Compare previous and current increasing sequences
3. **Bit Manipulation Optimization**: Use bit shifts for efficient division by 2
4. **Early Termination**: Return as soon as condition is satisfied

Key Insights:
- We need to find two back-to-back increasing sequences
- Each sequence must be at least length `k`
- The sequences must be adjacent (end of first = start of second - 1)
- We can track this by maintaining current and previous increasing lengths

## ‚öôÔ∏è Approach
1. **Track Variables**:
   - `inc`: length of current increasing sequence
   - `prevInc`: length of previous increasing sequence  
   - `maxLen`: maximum valid pair length found so far

2. **Iterate Through Array**:
   - If current element > previous: extend current sequence
   - Else: store current as previous, reset current
   - Check if we have two adjacent sequences meeting the criteria

3. **Validation Logic**:
   - For two adjacent sequences, each must be ‚â• k
   - The minimum of the two sequences determines the valid pair length
   - Also consider splitting a long sequence into two halves

## ‚úÖ Optimized Solution
```java
public class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        int inc = 1;           // Length of current increasing sequence
        int prevInc = 0;       // Length of previous increasing sequence
        int maxLen = 0;        // Maximum valid adjacent pair length found
        
        for (int i = 1; i < n; i++) {
            if (nums.get(i) > nums.get(i - 1)) {
                inc++;  // Extend current increasing sequence
            } else {
                // Sequence broken - update previous and reset current
                prevInc = inc;
                inc = 1;
            }
            
            // Calculate maximum valid adjacent pair length
            maxLen = Math.max(maxLen, Math.max(inc >> 1,        // Split current sequence
                              Math.min(prevInc, inc)));          // Adjacent sequences
            
            // Early termination if we found valid pair
            if (maxLen >= k) return true;
        }
        
        return false;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through the array |
| **Space**       | O(1)       | Constant extra variables |

## üìä Example Walkthrough
**Input:** nums = [2,5,7,8,9,2,3,4,3,1], k = 3

**Processing:**
- i=1: 5>2 ‚Üí inc=2, prevInc=0 ‚Üí maxLen=max(0,1)=1
- i=2: 7>5 ‚Üí inc=3, prevInc=0 ‚Üí maxLen=max(1,1)=1  
- i=3: 8>7 ‚Üí inc=4, prevInc=0 ‚Üí maxLen=max(2,1)=2
- i=4: 9>8 ‚Üí inc=5, prevInc=0 ‚Üí maxLen=max(2,1)=2
- i=5: 2<9 ‚Üí prevInc=5, inc=1 ‚Üí maxLen=max(0,1)=2
- i=6: 3>2 ‚Üí inc=2, prevInc=5 ‚Üí maxLen=max(1,2)=2
- i=7: 4>3 ‚Üí inc=3, prevInc=5 ‚Üí maxLen=max(1,3)=3 ‚úì
  - min(prevInc=5, inc=3) = 3 ‚â• k=3 ‚Üí return true

**Explanation:**
- Previous sequence: [2,5,7,8,9] (length 5)
- Current sequence: [2,3,4] (length 3)  
- min(5,3) = 3 ‚â• k=3 ‚Üí valid adjacent pair

## üí° Key Features
- **Single Pass**: Processes array in linear time
- **State Tracking**: Maintains only previous and current sequence lengths
- **Early Termination**: Returns immediately when condition is met
- **Bit Optimization**: Uses `inc >> 1` for efficient division by 2

## üöÄ When to Use
- Sequence pattern detection problems
- When you need to find adjacent segments with properties
- Problems involving consecutive increasing/decreasing sequences
- Sliding window variations

## ‚ö†Ô∏è Edge Cases
- **All increasing**: Can split long sequence into two halves
- **No increasing sequences**: Immediately return false
- **k = 1**: Always true (any two consecutive elements form increasing sequence)
- **Small array**: Constraints ensure n ‚â• 2, k ‚â§ n/2

## üõ† Variations
1. **Explicit Length Tracking**:
```java
// Track start and end indices of sequences
```

2. **Two Pointer Approach**:
```java
// Use two pointers to find valid adjacent pairs
```

3. **DP Approach**:
```java
// Use DP to store increasing sequence lengths
```

## Alternative Implementation (More Readable)
```java
public class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        int currentLength = 1;    // Length of current increasing sequence
        int previousLength = 0;   // Length of previous increasing sequence
        
        for (int i = 1; i < n; i++) {
            if (nums.get(i) > nums.get(i - 1)) {
                currentLength++;
            } else {
                // Sequence broken - update previous and reset current
                previousLength = currentLength;
                currentLength = 1;
            }
            
            // Check two cases:
            // 1. Split current long sequence into two adjacent halves
            if (currentLength >= 2 * k) {
                return true;
            }
            
            // 2. Check adjacent sequences (previous and current)
            if (previousLength >= k && currentLength >= k) {
                return true;
            }
            
            // 3. Check if we can use part of previous and current
            if (Math.min(previousLength, currentLength) >= k) {
                return true;
            }
        }
        
        return false;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Monotonic Sequences**: Properties of strictly increasing subsequences
- **Adjacency Constraint**: Sequences must be back-to-back
- **Minimum Length**: The limiting factor is the shorter of two sequences
- **Sequence Splitting**: A long sequence can be split into two adjacent parts

**Key Formula:**
- Valid if: `min(prevInc, inc) >= k` OR `inc >= 2*k` (can split)
- The bit shift `inc >> 1` efficiently computes `floor(inc / 2)` for splitting check

The algorithm efficiently solves the problem by recognizing that we only need to track the lengths of consecutive increasing sequences and check if any two adjacent ones (or a splittable long one) meet the length requirement.