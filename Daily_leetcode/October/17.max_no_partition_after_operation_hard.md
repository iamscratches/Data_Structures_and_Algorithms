# ðŸ§© Maximize the Number of Partitions After Operations - Two-Pass DP Approach

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/maximize-the-number-of-partitions-after-operations/description/?envType=daily-question&envId=2025-10-17)

Given:
- A string `s` consisting of lowercase English letters
- An integer `k`
- You can change **at most one character** in the string to any lowercase letter

Find:
- The **maximum number of partitions** such that:
  1. Each partition contains **at most k distinct characters**
  2. Partitions are contiguous substrings
  3. You can change at most one character

**Partition Rules:**
- Split `s` into contiguous substrings
- Each substring must have â‰¤ k distinct characters
- After changing at most one character (optional)
- Maximize the number of partitions

**Constraints:**
- `1 <= s.length <= 10^4`
- `1 <= k <= 26`
- `s` consists of lowercase English letters

**Example:**
```text
Input: s = "accca", k = 2
Output: 4

Explanation:
Without operation: partitions = ["a","c","cc","a"] â†’ 4 partitions
We can also change one character to get more partitions?
Wait, let's understand the problem better...

Actually, the key insight is we can change one character to potentially 
create more partition points while maintaining the distinct character constraint.
```

## ðŸ§  Intuition
The solution uses:
1. **Two-Pass DP**: Compute partitions from left and right separately
2. **Bitmask Tracking**: Use bitmasks to track distinct characters efficiently
3. **Partition Counting**: Track number of partitions and current state
4. **Split Point Analysis**: Evaluate each possible split point with the operation

Key Insights:
- Precompute maximum partitions from left and right for each position
- The operation (changing one character) can help merge partitions or create new ones
- Analyze three cases at each potential split point
- Use bitwise operations for efficient distinct character counting

## âš™ï¸ Approach
1. **Left Pass**: Compute for each position:
   - `left[i][0]`: number of partitions ending at i
   - `left[i][1]`: bitmask of current partition
   - `left[i][2]`: distinct count in current partition

2. **Right Pass**: Compute for each position:
   - `right[i][0]`: number of partitions starting from i
   - `right[i][1]`: bitmask of current partition
   - `right[i][2]`: distinct count in current partition

3. **Merge Analysis**: For each split point `i`:
   - Combine left and right partitions
   - Consider the effect of changing one character
   - Three main cases to maximize partitions

## âœ… Optimized Solution
```java
public class Solution {

    public int maxPartitionsAfterOperations(String s, int k) {
        int n = s.length();
        int[][] left = new int[n][3];  // [partitions, mask, distinct_count]
        int[][] right = new int[n][3]; // [partitions, mask, distinct_count]

        // Left-to-right pass
        int num = 0;
        int mask = 0;
        int count = 0;
        for (int i = 0; i < n - 1; i++) {
            int binary = 1 << (s.charAt(i) - 'a');
            if ((mask & binary) == 0) {
                count++;
                if (count <= k) {
                    mask |= binary;
                } else {
                    // Start new partition
                    num++;
                    mask = binary;
                    count = 1;
                }
            }
            left[i + 1][0] = num;
            left[i + 1][1] = mask;
            left[i + 1][2] = count;
        }

        // Right-to-left pass
        num = 0;
        mask = 0;
        count = 0;
        for (int i = n - 1; i > 0; i--) {
            int binary = 1 << (s.charAt(i) - 'a');
            if ((mask & binary) == 0) {
                count++;
                if (count <= k) {
                    mask |= binary;
                } else {
                    // Start new partition
                    num++;
                    mask = binary;
                    count = 1;
                }
            }
            right[i - 1][0] = num;
            right[i - 1][1] = mask;
            right[i - 1][2] = count;
        }

        // Find maximum partitions considering operation
        int maxVal = 0;
        for (int i = 0; i < n; i++) {
            int seg = left[i][0] + right[i][0] + 2;
            int totMask = left[i][1] | right[i][1];
            int totCount = Integer.bitCount(totMask);
            
            // Case analysis for operation
            if (left[i][2] == k && right[i][2] == k && totCount < 26) {
                // Operation can merge three partitions into two
                seg++;
            } else if (Math.min(totCount + 1, 26) <= k) {
                // Operation can help but reduces one partition
                seg--;
            }
            maxVal = Math.max(maxVal, seg);
        }
        return maxVal;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Two passes through the string |
| **Space**       | O(n)       | Left and right DP arrays |

## ðŸ“Š Example Walkthrough
**Input:** s = "accca", k = 2

**Left Pass:**
- i=0: 'a' â†’ mask=a(1), count=1, partitions=0
- i=1: 'c' â†’ mask=ac(3), count=2, partitions=0  
- i=2: 'c' â†’ mask=ac(3), count=2, partitions=0
- i=3: 'c' â†’ mask=ac(3), count=2, partitions=0
- i=4: 'a' â†’ Would exceed k=2? Actually need to check partitioning...

**Actually, let's trace properly:**

For s = "accca", k = 2:

**Without operation:**
Optimal partition: "a", "c", "cc", "a" â†’ 4 partitions
- "a": distinct=1
- "c": distinct=1  
- "cc": distinct=1
- "a": distinct=1

**With the algorithm:**
The code analyzes each position to see if changing one character can increase partitions.

## ðŸ’¡ Key Features
- **Two-Pass Technique**: Enables analyzing both sides of each split point
- **Bitmask Efficiency**: Compact representation of character sets
- **Case Analysis**: Comprehensive consideration of operation impact
- **Greedy Partitioning**: Build partitions optimally from both directions

## ðŸš€ When to Use
- String partitioning problems with constraints
- When operations can modify the string
- Problems requiring analysis from both directions
- Distinct character counting with limits

## âš ï¸ Edge Cases
- **k = 1**: Only single-character partitions
- **k â‰¥ 26**: Can have unlimited distinct characters
- **All same characters**: Simple partitioning
- **String length 1**: Single partition

## ðŸ›  Variations
1. **Dynamic Programming with State**:
```java
// DP with state (position, mask, changed)
```

2. **Greedy with Lookahead**:
```java
// Greedy partitioning with lookahead for operation
```

3. **Binary Search on Partitions**:
```java
// Binary search on number of partitions with feasibility check
```

## Alternative Implementation (DP with State)
```java
public class Solution {
    public int maxPartitionsAfterOperations(String s, int k) {
        int n = s.length();
        // dp[i][mask][changed] = max partitions up to i
        int[][][] dp = new int[n+1][1<<26][2];
        
        for (int i = 0; i <= n; i++) {
            for (int mask = 0; mask < (1<<26); mask++) {
                Arrays.fill(dp[i][mask], -1);
            }
        }
        
        dp[0][0][0] = 0;
        
        for (int i = 0; i < n; i++) {
            for (int mask = 0; mask < (1<<26); mask++) {
                for (int changed = 0; changed < 2; changed++) {
                    if (dp[i][mask][changed] == -1) continue;
                    
                    int current = dp[i][mask][changed];
                    int ch = s.charAt(i) - 'a';
                    
                    // Case 1: Don't change current character
                    int newMask = mask | (1 << ch);
                    int distinct = Integer.bitCount(newMask);
                    
                    if (distinct <= k) {
                        // Continue current partition
                        dp[i+1][newMask][changed] = Math.max(dp[i+1][newMask][changed], current);
                    } else {
                        // Start new partition
                        dp[i+1][1<<ch][changed] = Math.max(dp[i+1][1<<ch][changed], current + 1);
                    }
                    
                    // Case 2: Change current character (if allowed)
                    if (changed == 0) {
                        for (int newCh = 0; newCh < 26; newCh++) {
                            newMask = mask | (1 << newCh);
                            distinct = Integer.bitCount(newMask);
                            
                            if (distinct <= k) {
                                dp[i+1][newMask][1] = Math.max(dp[i+1][newMask][1], current);
                            } else {
                                dp[i+1][1<<newCh][1] = Math.max(dp[i+1][1<<newCh][1], current + 1);
                            }
                        }
                    }
                }
            }
        }
        
        // Find maximum partitions
        int maxPartitions = 0;
        for (int mask = 0; mask < (1<<26); mask++) {
            for (int changed = 0; changed < 2; changed++) {
                if (dp[n][mask][changed] != -1) {
                    maxPartitions = Math.max(maxPartitions, dp[n][mask][changed] + 1);
                }
            }
        }
        return maxPartitions;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Set Theory**: Bitmasks represent character sets efficiently
- **Optimal Substructure**: Maximum partitions up to i depends on previous states
- **Operation Analysis**: Strategic character change can merge or split partitions
- **Two-Pointer Technique**: Analyzing from both ends reveals optimal split points

The algorithm cleverly combines preprocessing from both directions with careful case analysis of how the single operation can affect partition boundaries, providing an efficient solution to this complex optimization problem.