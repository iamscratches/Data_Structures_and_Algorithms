# ğŸ”¢ Smallest Number With All Set Bits - Bit Manipulation Approach

## ğŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/smallest-number-with-all-set-bits/description/?envType=daily-question&envId=2025-10-29)

Given:
- An integer `n`
- Find the smallest number `x` such that:
  - `x >= n`
  - The binary representation of `x` has **all 1's** (all bits set)

**Definition:**
- A number has "all set bits" if its binary representation consists only of 1's
- Examples: 1 (1), 3 (11), 7 (111), 15 (1111), 31 (11111), etc.

Find:
- The smallest number â‰¥ n that has all bits set in its binary representation

**Constraints:**
- `1 <= n <= 10^8`

**Example:**
```text
Input: n = 5
Output: 7

Explanation:
Numbers with all set bits: 1, 3, 7, 15, 31, ...
5 is between 3 and 7, so smallest â‰¥ 5 is 7.

Input: n = 8
Output: 15

Explanation:
8 is between 7 and 15, so smallest â‰¥ 8 is 15.
```

## ğŸ§  Intuition
The solution uses:
1. **Bit Pattern Recognition**: Numbers with all bits set follow pattern: 1, 3, 7, 15, 31...
2. **Bit Shifting**: Build numbers with all 1's efficiently
3. **Comparison**: Find the smallest such number â‰¥ n

Key Insights:
- Numbers with all bits set are of form: 2^k - 1
- We need to find smallest k such that 2^k - 1 â‰¥ n
- This means: 2^k â‰¥ n + 1
- So k = ceil(logâ‚‚(n + 1))

## âš™ï¸ Approach
1. **Initialize**: Start with value = 1 (binary: 1)
2. **Build All-Ones Numbers**:
   - While n > 1, shift left and add 1
   - This generates sequence: 1 â†’ 11 â†’ 111 â†’ 1111...
3. **Termination**: Stop when we've built a number with enough bits
4. **Return**: The constructed all-ones number

## âœ… Optimized Solution
```java
class Solution {
    public int smallestNumber(int n) {
        int val = 1;  // Start with binary: 1
        
        // Build the smallest number with all bits set that is â‰¥ n
        while (n > 1) {
            val = (val << 1) | 1;  // Shift left and set the new LSB to 1
            n = n >> 1;            // Reduce n by half (check when to stop)
        }
        
        return val;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(log n)   | Number of bits in n |
| **Space**       | O(1)       | Only a few variables |

## ğŸ“Š Example Walkthrough
**Input:** n = 5

**Step-by-step:**
1. **Initial**: val = 1 (binary: 1), n = 5
2. **Iteration 1**:
   - val = (1 << 1) | 1 = (10) | 1 = 11 (binary) = 3
   - n = 5 >> 1 = 2
   - n > 1? Yes, continue
3. **Iteration 2**:
   - val = (3 << 1) | 1 = (110) | 1 = 111 (binary) = 7
   - n = 2 >> 1 = 1
   - n > 1? No, stop
4. **Return**: 7 âœ“

**Input:** n = 8

**Step-by-step:**
1. **Initial**: val = 1, n = 8
2. **Iteration 1**: val = 3, n = 4
3. **Iteration 2**: val = 7, n = 2  
4. **Iteration 3**: val = 15, n = 1
5. **Return**: 15 âœ“

## ğŸ’¡ How It Works
The algorithm builds numbers with all bits set:
- Start: 1 (binary 1)
- Step 1: 1 â†’ 11 (binary) = 3
- Step 2: 11 â†’ 111 (binary) = 7  
- Step 3: 111 â†’ 1111 (binary) = 15
- And so on...

The condition `n > 1` ensures we build enough bits:
- When n becomes 1, we've built a number with sufficient bits to be â‰¥ original n

## ğŸ’¡ Key Features
- **Efficient Bit Manipulation**: Uses shifts and OR operations
- **Mathematical Insight**: Leverages properties of binary numbers
- **Optimal Solution**: Finds answer in logarithmic time
- **Minimal Operations**: Only bit operations, no expensive calculations

## ğŸš€ When to Use
- Problems involving binary number patterns
- When you need numbers with specific bit patterns
- Finding boundaries in binary sequences
- Bit manipulation optimization problems

## âš ï¸ Edge Cases
- **n = 1**: Returns 1 (already all bits set)
- **n = 2**: Returns 3 (binary 11)
- **n = 3**: Returns 3 (exactly matches)
- **Large n**: Handles up to 10^8 efficiently

## ğŸ›  Variations
1. **Mathematical Formula**:
```java
public int smallestNumber(int n) {
    int bits = 32 - Integer.numberOfLeadingZeros(n);
    return (1 << bits) - 1;
}
```

2. **Logarithm Approach**:
```java
public int smallestNumber(int n) {
    int bits = (int)Math.ceil(Math.log(n + 1) / Math.log(2));
    return (1 << bits) - 1;
}
```

3. **String Manipulation**:
```java
public int smallestNumber(int n) {
    String binary = Integer.toBinaryString(n);
    // Find next power of two and subtract 1
}
```

## Alternative Implementation (Using Bit Counting)
```java
class Solution {
    public int smallestNumber(int n) {
        // Count how many bits are needed to represent n
        int bitsNeeded = 0;
        int temp = n;
        while (temp > 0) {
            bitsNeeded++;
            temp >>= 1;
        }
        
        // Check if n is already of form 2^k - 1
        if ((n & (n + 1)) == 0) {
            return n;  // n already has all bits set
        }
        
        // Return the next number with all bits set
        return (1 << bitsNeeded) - 1;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Binary Number Theory**: Numbers with all bits set = 2^k - 1
- **Bit Length**: For n, we need k = ceil(logâ‚‚(n + 1))
- **Shift Operations**: Efficient way to compute 2^k
- **Pattern Recognition**: The sequence 1, 3, 7, 15, 31... follows clear pattern

**Key Formula:**
```
smallestNumber(n) = 2^ceil(logâ‚‚(n + 1)) - 1
```

The algorithm elegantly finds the solution by recognizing that we need to find the smallest power of 2 that is greater than n, then subtract 1 to get the number with all bits set. The bit-shifting approach provides an efficient way to compute this without floating-point operations or logarithms.

## Why This Works
For any number n:
- Find the smallest k such that 2^k > n
- Then 2^k - 1 is the smallest number with all bits set that is â‰¥ n
- The while loop effectively finds this k by counting how many times we can halve n before it becomes 1