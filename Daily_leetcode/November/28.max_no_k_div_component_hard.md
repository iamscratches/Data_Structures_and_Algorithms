# üå≥ Maximum Number of K-Divisible Components - Tree DFS Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/maximum-number-of-k-divisible-components/description/?envType=daily-question&envId=2025-11-28)

Given:
- An undirected tree with `n` nodes
- `edges` representing the tree connections
- `values` array where `values[i]` is the value of node i
- An integer `k`

Find:
- The **maximum number of connected components** such that:
  - Each component's sum of values is divisible by `k`
  - You can remove edges to create components

**Constraints:**
- `1 <= n <= 3 * 10^4`
- `0 <= edges.length <= 3 * 10^4`
- `1 <= k <= 10^9`
- `1 <= values[i] <= 10^9`

**Example:**
```text
Input: n = 5, edges = [[0,2],[1,2],[1,3],[2,4]], values = [1,8,1,4,4], k = 6
Output: 2

Explanation:
We can remove edges to create components with sums divisible by 6:
- Remove edge [1,2]: Components [0,2,4] (sum=1+1+4=6) and [1,3] (sum=8+4=12)
- Both sums divisible by 6 ‚Üí 2 components

Input: n = 7, edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [3,0,6,1,5,2,1], k = 3
Output: 3
```

## üß† Intuition
The solution uses:
1. **Tree DFS**: Process the tree from leaves to root
2. **Post-order Traversal**: Calculate subtree sums bottom-up
3. **Greedy Partitioning**: Cut edges when subtree sum is divisible by k
4. **Modular Arithmetic**: Track sums modulo k to handle large numbers

Key Insights:
- Perform DFS from root (node 0) to calculate subtree sums
- If a subtree's sum is divisible by k, we can cut the edge above it
- Each cut increases component count by 1
- Return the accumulated count of valid cuts

## ‚öôÔ∏è Approach
1. **Build Graph**: Convert edges to adjacency list
2. **DFS Traversal**:
   - Start from root (node 0) with parent -1
   - For each node, calculate sum of its subtree
   - If subtree sum % k == 0, increment component count
   - Return subtree sum to parent
3. **Return Result**: Total number of components found

## ‚úÖ Optimized Solution
```java
class Solution {
    public int maxKDivisibleComponents(int n, int[][] edges, int[] values, int k) {
        // Build the tree as an adjacency list
        List<Integer>[] graph = new List[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            graph[u].add(v);
            graph[v].add(u);
        }
        
        // Initialize component counter
        componentCount = 0;
        
        // Perform DFS starting from root (node 0)
        dfs(graph, 0, -1, values, k);
        
        return componentCount;
    }
    
    private int componentCount = 0;
    
    private long dfs(List<Integer>[] graph, int currentNode, int parent, int[] values, int k) {
        // Start with the current node's value
        long subtreeSum = values[currentNode];
        
        // Process all neighbors (children in DFS tree)
        for (int neighbor : graph[currentNode]) {
            if (neighbor != parent) { // Avoid going back to parent
                subtreeSum += dfs(graph, neighbor, currentNode, values, k);
            }
        }
        
        // If the subtree sum is divisible by k, we can cut here
        // This creates a valid component
        if (subtreeSum % k == 0) {
            componentCount++;
        }
        
        return subtreeSum;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single DFS traversal |
| **Space**       | O(n)       | Graph storage + recursion stack |

## üìä Example Walkthrough
**Input:** n = 5, edges = [[0,2],[1,2],[1,3],[2,4]], values = [1,8,1,4,4], k = 6

**Tree Structure:**
```
    1
   / \
  3   2
     / \
    0   4
```

**DFS Execution:**
1. **Start at root 1** (arbitrary, but code uses 0 as root - let's trace with actual root 0)

**Actual tree with root 0:**
```
    0
    |
    2
   / \
  1   4
  |
  3
```

**DFS Trace:**
1. **Node 3** (leaf): sum=4 ‚Üí 4%6=4 ‚Üí return 4
2. **Node 1**: sum=8+4=12 ‚Üí 12%6=0 ‚úì ‚Üí count=1, return 12
3. **Node 4** (leaf): sum=4 ‚Üí 4%6=4 ‚Üí return 4  
4. **Node 2**: sum=1+12+4=17 ‚Üí 17%6=5 ‚Üí return 17
5. **Node 0**: sum=1+17=18 ‚Üí 18%6=0 ‚úì ‚Üí count=2

**Output:** 2 ‚úì

**Explanation of Cuts:**
- Cut above node 1: creates component [1,3] with sum 12
- Cut above node 0: creates component [0,2,4] with sum 6
- Total: 2 components

## üí° How It Works
**DFS Strategy:**
- Process leaves first, then internal nodes
- For each node, calculate sum of its entire subtree
- If subtree sum is divisible by k, we can cut the edge connecting this subtree to its parent
- This creates a valid component and increases count

**Why This Works:**
- When we cut at a node, the subtree becomes an independent component
- The remaining tree continues to be processed
- Each valid cut increases the component count by 1
- The algorithm finds all possible cuts that create valid components

## üí° Key Features
- **Greedy Optimal**: Each valid cut immediately increases count
- **Tree Properties**: Leverages tree structure for efficient computation
- **Bottom-up Processing**: Calculates sums from leaves to root
- **Modular Handling**: Works with large numbers using long

## üöÄ When to Use
- Tree partitioning problems
- When you need to split tree into components with properties
- Problems involving subtree sums
- Greedy tree decomposition

## ‚ö†Ô∏è Edge Cases
- **Single node**: If value divisible by k, count=1
- **All values divisible by k**: Can create n components
- **No valid cuts**: Return 1 (the whole tree)
- **Large k**: Modular arithmetic handles this
- **Chain tree**: Linear structure

## üõ† Variations
1. **Iterative DFS (Stack)**:
```java
public int maxKDivisibleComponents(int n, int[][] edges, int[] values, int k) {
    List<Integer>[] graph = new List[n];
    for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();
    for (int[] edge : edges) {
        graph[edge[0]].add(edge[1]);
        graph[edge[1]].add(edge[0]);
    }
    
    int[] parent = new int[n];
    Arrays.fill(parent, -1);
    List<Integer> order = new ArrayList<>();
    Stack<Integer> stack = new Stack<>();
    stack.push(0);
    
    // Get DFS order
    while (!stack.isEmpty()) {
        int u = stack.pop();
        order.add(u);
        for (int v : graph[u]) {
            if (v != parent[u]) {
                parent[v] = u;
                stack.push(v);
            }
        }
    }
    
    // Process in reverse DFS order
    long[] sum = new long[n];
    int count = 0;
    for (int i = order.size() - 1; i >= 0; i--) {
        int u = order.get(i);
        sum[u] = values[u];
        for (int v : graph[u]) {
            if (v != parent[u]) {
                sum[u] += sum[v];
            }
        }
        if (sum[u] % k == 0) count++;
    }
    return count;
}
```

2. **BFS Level Order**:
```java
// Alternative using BFS for topological order
```

## Mathematical Insight
The solution leverages:
- **Tree Decomposition**: Any tree can be partitioned by removing edges
- **Subtree Sum Property**: Sum of subtree = node value + sum of children's subtrees
- **Greedy Choice**: Cutting when divisible always benefits the count
- **Modular Arithmetic**: `(a + b) % k = (a%k + b%k) % k`

**Key Insight:**
The maximum number of components is achieved by cutting every edge where the subtree below it has a sum divisible by k. This is optimal because:
1. Each such cut creates a valid component
2. The cuts are independent (tree structure)
3. No better partitioning exists

The algorithm efficiently solves the problem by performing a single DFS traversal that simultaneously calculates subtree sums and counts valid partitions, providing an optimal solution in linear time.