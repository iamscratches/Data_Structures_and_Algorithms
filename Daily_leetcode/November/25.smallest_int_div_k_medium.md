# ðŸ”¢ Smallest Integer Divisible by K - Modular Arithmetic Approach

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/smallest-integer-divisible-by-k/description/?envType=daily-question&envId=2025-11-27)

Given:
- A positive integer `k`

Find:
- The **length** of the smallest positive integer `N` such that:
  - `N` is divisible by `k`
  - `N` consists only of the digit `1`
- If no such integer exists, return `-1`

**Integer Examples:**
- 1, 11, 111, 1111, 11111, ...

**Constraints:**
- `1 <= k <= 10^5`

**Example:**
```text
Input: k = 1
Output: 1
Explanation: 1 is divisible by 1

Input: k = 2
Output: -1
Explanation: No number consisting only of 1s is divisible by 2

Input: k = 3  
Output: 3
Explanation: 111 is divisible by 3 (111 Ã· 3 = 37)
```

## ðŸ§  Intuition
The solution uses:
1. **Modular Arithmetic**: Track remainder instead of actual large numbers
2. **Digit Construction**: Build numbers of form 1, 11, 111, ... incrementally
3. **Pigeonhole Principle**: If no solution found in k steps, no solution exists
4. **Early Termination**: Stop as soon as remainder becomes 0

Key Insights:
- Numbers of form 111...1 can be built as: `N = 10 * prev + 1`
- We only care about `N % k`, not the actual number
- If `k` is divisible by 2 or 5, no solution exists (numbers ending with 1 can't be divisible by 2 or 5)
- By pigeonhole principle, we only need to check up to k steps

## âš™ï¸ Approach
1. **Check Divisibility**:
   - If `k % 2 == 0` or `k % 5 == 0`, return -1 immediately
2. **Iterative Construction**:
   - Start with remainder = 0
   - For length from 1 to k:
     - Update remainder: `rem = (rem * 10 + 1) % k`
     - If remainder becomes 0, return current length
3. **Return -1**: If no solution found in k steps

## âœ… Optimized Solution
```java
class Solution {
    public int smallestRepunitDivByK(int k) {
        // Numbers made of only 1s always end with 1
        // They can NEVER be divisible by 2 or 5
        if (k % 2 == 0 || k % 5 == 0) {
            return -1;
        }
        
        int remainder = 0;
        // We only need to check up to k steps (pigeonhole principle)
        for (int length = 1; length <= k; length++) {
            // Build number: N = 10 * prev + 1
            remainder = (remainder * 10 + 1) % k;
            
            if (remainder == 0) {
                return length;
            }
        }
        
        return -1;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(k)       | At most k iterations |
| **Space**       | O(1)       | Only a few variables |

## ðŸ“Š Example Walkthrough
**Input:** k = 3

**Step-by-step:**
1. **Check**: 3 % 2 â‰  0 and 3 % 5 â‰  0 â†’ continue
2. **length=1**: rem = (0*10 + 1) % 3 = 1 % 3 = 1
3. **length=2**: rem = (1*10 + 1) % 3 = 11 % 3 = 2  
4. **length=3**: rem = (2*10 + 1) % 3 = 21 % 3 = 0 âœ“

**Output:** 3 âœ“ (111 is divisible by 3)

**Another Example:** k = 7
1. length=1: rem = 1 % 7 = 1
2. length=2: rem = 11 % 7 = 4
3. length=3: rem = 41 % 7 = 6
4. length=4: rem = 61 % 7 = 5
5. length=5: rem = 51 % 7 = 2
6. length=6: rem = 21 % 7 = 0 âœ“

**Output:** 6 âœ“ (111111 Ã· 7 = 15873)

**Edge Case:** k = 2
- k % 2 == 0 â†’ return -1 immediately âœ“

## ðŸ’¡ How It Works
**Mathematical Foundation:**
- Numbers of form 111...1 can be represented as:
  ```
  N = 1 + 10 + 10Â² + ... + 10^(n-1)
  ```
- Alternatively, they can be built iteratively:
  ```
  Nâ‚ = 1
  Nâ‚‚ = 10 Ã— 1 + 1 = 11  
  Nâ‚ƒ = 10 Ã— 11 + 1 = 111
  ```
- Using modular arithmetic:
  ```
  rem = (rem Ã— 10 + 1) % k
  ```

**Why check only up to k steps?**
- By pigeonhole principle, with k+1 remainders (0 to k-1) and k steps, either:
  - We hit remainder 0 (success), or
  - We get a repeated remainder (cycle means no solution)

## ðŸ’¡ Key Features
- **Modular Arithmetic**: Avoids large number computation
- **Early Pruning**: Quick check for multiples of 2 or 5
- **Pigeonhole Principle**: Guarantees termination in O(k) time
- **Simple Iteration**: Easy to understand and implement

## ðŸš€ When to Use
- Problems involving large numbers built from digits
- Divisibility checking with modular arithmetic
- When you need to find smallest number satisfying conditions
- Problems with digit pattern constraints

## âš ï¸ Edge Cases
- **k = 1**: Should return 1
- **k is prime**: Often has solution (except 2 and 5)
- **k is multiple of 2 or 5**: No solution
- **k = 3**: 111 is divisible by 3
- **k = 9**: 111111111 (9 ones) is divisible by 9

## ðŸ›  Variations
1. **Using BigInteger** (less efficient):
```java
public int smallestRepunitDivByK(int k) {
    if (k % 2 == 0 || k % 5 == 0) return -1;
    
    BigInteger num = BigInteger.ONE;
    for (int length = 1; length <= k; length++) {
        if (num.mod(BigInteger.valueOf(k)).equals(BigInteger.ZERO)) {
            return length;
        }
        num = num.multiply(BigInteger.TEN).add(BigInteger.ONE);
    }
    return -1;
}
```

2. **Explicit Remainder Calculation**:
```java
public int smallestRepunitDivByK(int k) {
    if (k % 2 == 0 || k % 5 == 0) return -1;
    
    int remainder = 1 % k;
    for (int length = 1; length <= k; length++) {
        if (remainder == 0) return length;
        remainder = (remainder * 10 + 1) % k;
    }
    return -1;
}
```

3. **While Loop Version**:
```java
public int smallestRepunitDivByK(int k) {
    if (k % 2 == 0 || k % 5 == 0) return -1;
    
    int remainder = 0;
    int length = 0;
    do {
        remainder = (remainder * 10 + 1) % k;
        length++;
    } while (remainder != 0 && length <= k);
    
    return remainder == 0 ? length : -1;
}
```

## Mathematical Insight
The solution leverages:
- **Modular Arithmetic Properties**: `(a Ã— b + c) % k = ((a % k) Ã— b + c) % k`
- **Digit Construction**: Each step appends a '1' digit
- **Pigeonhole Principle**: Guarantees we find solution or prove impossibility in k steps
- **Divisibility Rules**: Numbers ending with 1 cannot be divisible by 2 or 5

**Key Theorem:**
For any k not divisible by 2 or 5, there exists a repunit (number consisting only of 1s) divisible by k, and its length is at most k.

The algorithm elegantly solves the problem by combining mathematical insight about divisibility with efficient computation using modular arithmetic, avoiding the need to handle very large numbers directly.