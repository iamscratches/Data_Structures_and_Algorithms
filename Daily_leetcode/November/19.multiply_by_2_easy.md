# ğŸ”¢ Keep Multiplying Found Values by Two - HashSet Approach

## ğŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/keep-multiplying-found-values-by-two/description/?envType=daily-question&envId=2025-11-19)

Given:
- An integer array `nums`
- An integer `original`

Find:
- The final value after repeatedly applying:
  - If `original` is found in `nums`, multiply `original` by 2
  - Repeat until `original` is not found in `nums`
  - Return the final value of `original`

**Process Rules:**
- Start with the given `original` value
- While `original` exists in `nums`, double it
- Stop when `original` is not found in `nums`
- Return the final `original` value

**Constraints:**
- `1 <= nums.length <= 1000`
- `1 <= nums[i], original <= 1000`

**Example:**
```text
Input: nums = [5,3,6,1,12], original = 3
Output: 24

Explanation:
- Start: original = 3 (found in nums) â†’ 3Ã—2=6
- Now: original = 6 (found in nums) â†’ 6Ã—2=12  
- Now: original = 12 (found in nums) â†’ 12Ã—2=24
- Now: original = 24 (not found) â†’ stop
Final: 24

Input: nums = [2,7,9], original = 4
Output: 4

Explanation:
- Start: original = 4 (not found) â†’ stop immediately
Final: 4
```

## ğŸ§  Intuition
The solution uses:
1. **HashSet for Fast Lookup**: Store all numbers for O(1) membership checks
2. **Iterative Doubling**: Keep doubling while the current value exists
3. **Early Termination**: Stop as soon as value is not found
4. **Boundary Check**: Optional optimization for large values

Key Insights:
- Use HashSet to avoid O(n) searches for each doubling
- The process is deterministic - always double when found
- Values grow exponentially, so process terminates quickly
- Maximum possible value is bounded by constraints

## âš™ï¸ Approach
1. **Store in HashSet**: Convert array to set for fast lookups
2. **Iterate While Found**:
   - While `original` exists in set, double it
   - Stop when `original` is not found
3. **Return Result**: Final value after process completes

## âœ… Optimized Solution
```java
class Solution {
    public int findFinalValue(int[] nums, int original) {
        // Step 1: Store all numbers in HashSet for O(1) lookups
        Set<Integer> numSet = new HashSet<>();
        for (int num : nums) {
            numSet.add(num);
        }
        
        // Step 2: Keep doubling while original exists in set
        while (numSet.contains(original)) {
            original *= 2;
        }
        
        return original;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n + k)   | n for building set + k doubling steps |
| **Space**       | O(n)       | HashSet storage |

Where k is the number of doubling operations (logarithmic in final value)

## ğŸ“Š Example Walkthrough
**Input:** nums = [5,3,6,1,12], original = 3

**Step 1 - Build HashSet:**
- numSet = {5, 3, 6, 1, 12}

**Step 2 - Process:**
- original=3 â†’ found in set â†’ double to 6
- original=6 â†’ found in set â†’ double to 12  
- original=12 â†’ found in set â†’ double to 24
- original=24 â†’ not found â†’ stop

**Output:** 24 âœ“

**Another Example:** nums = [2,7,9], original = 4
- numSet = {2,7,9}
- original=4 â†’ not found â†’ stop immediately
- **Output:** 4 âœ“

**Edge Case:** nums = [1,2,4,8,16], original = 1
- 1â†’2â†’4â†’8â†’16â†’32 (not found)
- **Output:** 32 âœ“

## ğŸ’¡ Key Features
- **Efficient Lookups**: HashSet provides O(1) membership tests
- **Simple Logic**: Straightforward iterative process
- **Optimal Solution**: Minimum possible operations
- **Clear Termination**: Stops as soon as condition fails

## ğŸš€ When to Use
- Repeated transformation problems
- When you need fast membership testing
- Problems with exponential growth patterns
- State transition with termination conditions

## âš ï¸ Edge Cases
- **Original not in nums**: Return original immediately
- **All same numbers**: [2,2,2], original=2 â†’ 2â†’4â†’8â†’...
- **Empty array**: Return original (but constraints prevent)
- **Maximum chain**: Values that keep doubling until beyond set
- **Large numbers**: Process terminates due to exponential growth

## ğŸ›  Variations
1. **Without HashSet**:
```java
public int findFinalValue(int[] nums, int original) {
    boolean found;
    do {
        found = false;
        for (int num : nums) {
            if (num == original) {
                original *= 2;
                found = true;
                break;
            }
        }
    } while (found);
    return original;
}
```

2. **Sorting Approach**:
```java
public int findFinalValue(int[] nums, int original) {
    Arrays.sort(nums);
    for (int num : nums) {
        if (num == original) {
            original *= 2;
        }
    }
    return original;
}
```

3. **Boolean Array** (since constraints are small):
```java
public int findFinalValue(int[] nums, int original) {
    boolean[] exists = new boolean[1001];
    for (int num : nums) {
        exists[num] = true;
    }
    while (original <= 1000 && exists[original]) {
        original *= 2;
    }
    return original;
}
```

## Alternative Implementation (With Bound Check)
```java
class Solution {
    public int findFinalValue(int[] nums, int original) {
        Set<Integer> numSet = new HashSet<>();
        for (int num : nums) numSet.add(num);
        
        // Optional: add bound check since numbers grow quickly
        while (original <= 1000000 && numSet.contains(original)) {
            original *= 2;
        }
        
        return original;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Exponential Growth**: Values double each step, so process terminates quickly
- **Set Theory**: Membership testing is the core operation
- **Deterministic Process**: Always the same sequence for given input
- **Monotonic Increase**: Values only increase, never decrease

**Growth Pattern:**
If original keeps being found, the sequence is:
```
original, 2Ã—original, 4Ã—original, 8Ã—original, ...
```
This grows exponentially, so even for the worst case, only O(log M) steps are needed where M is the maximum possible value.

The algorithm efficiently solves the problem by combining the speed of hash set lookups with the simple doubling logic, providing an optimal solution that handles all cases within the given constraints.