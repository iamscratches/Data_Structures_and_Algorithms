# ğŸ”„ Unique Length-3 Palindromic Subsequences - Two Pointer Counting

## ğŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/unique-length-3-palindromic-subsequences/description/?envType=daily-question&envId=2025-11-21)

Given:
- A string `s`
- We're looking for **palindromic subsequences** of length 3

Find:
- The number of **unique** palindromic subsequences of length 3

**Subsequence Rules:**
- A subsequence is obtained by deleting some characters without changing order
- Palindromic: reads same forwards and backwards
- Length 3: form `aba` where first and last characters are same
- Unique: Count distinct palindromic subsequences

**Constraints:**
- `3 <= s.length <= 10^5`
- `s` consists only of lowercase English letters

**Example:**
```text
Input: s = "aabca"
Output: 3

Explanation:
The palindromic subsequences of length 3 are:
1. "aba" (from indices 0,1,3) â†’ a_a_a
2. "aaa" (from indices 0,1,4) â†’ a_a_a  
3. "aca" (from indices 0,3,4) â†’ a_c_a
All are unique: "aba", "aaa", "aca"

Input: s = "adc"
Output: 0 (no palindromic subsequences of length 3)

Input: s = "bbcbaba"
Output: 4
```

## ğŸ§  Intuition
The solution uses:
1. **Three-part Structure**: Palindromes of length 3 have form `a x a`
2. **Character Pairing**: For each possible outer character, find unique middle characters
3. **Frequency Tracking**: Use left and right frequency arrays
4. **Sliding Window**: Move through string while maintaining counts

Key Insights:
- For each position as middle, check what characters appear on left and right
- A valid palindrome exists if same character appears on both sides of current
- Use sets to track unique `(outer_char, middle_char)` pairs
- Process string from left to right with sliding frequency counts

## âš™ï¸ Approach
1. **Initialize**:
   - `left[]`: frequency of characters seen so far (left of current)
   - `right[]`: frequency of characters yet to be seen (right of current)
   - `set`: store unique palindromes as `outer_char * 100 + middle_char`
2. **Precompute Right**:
   - Count all characters from position 2 to end
3. **Process Middle Positions**:
   - For each position i (from 1 to n-2):
     - Check all characters that exist in both left and right
     - For each such character, add `(char, s[i])` to set
     - Update left and right frequency arrays
4. **Return**: Size of set (number of unique palindromes)

## âœ… Optimized Solution
```java
class Solution {
    public int countPalindromicSubsequence(String s) {
        int n = s.length();
        char[] chars = s.toCharArray();
        
        // Frequency arrays for left and right parts
        int[] left = new int[26];  // Characters to the left of current position
        int[] right = new int[26]; // Characters to the right of current position
        
        // Initialize: first character in left, rest in right
        left[chars[0] - 'a']++;
        for (int i = 2; i < n; i++) {
            right[chars[i] - 'a']++;
        }
        
        Set<Integer> uniquePalindromes = new HashSet<>();
        
        // Process each character as potential middle (from index 1 to n-2)
        for (int i = 1; i < n - 1; i++) {
            // Check all possible outer characters that exist on both sides
            for (int charIdx = 0; charIdx < 26; charIdx++) {
                if (left[charIdx] > 0 && right[charIdx] > 0) {
                    // Found palindrome: (char) + (middle) + (same char)
                    // Encode as: outer_char * 100 + middle_char
                    int palindromeCode = charIdx * 100 + (chars[i] - 'a');
                    uniquePalindromes.add(palindromeCode);
                }
            }
            
            // Update frequency arrays for next iteration
            left[chars[i] - 'a']++;          // Current becomes part of left
            if (i + 1 < n) {
                right[chars[i + 1] - 'a']--; // Next character leaves right
            }
        }
        
        return uniquePalindromes.size();
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(26 Ã— n)  | 26 letters Ã— n positions |
| **Space**       | O(26 + n)  | Frequency arrays + set storage |

## ğŸ“Š Example Walkthrough
**Input:** s = "aabca"

**Step 1 - Initialize:**
- left: [1,0,0,...] (only 'a' at index 0)
- right: [2,0,1,...] ('a' at indices 3,4; 'c' at index 2)

**Step 2 - Process i=1 (middle='a'):**
- Check all chars with left>0 and right>0: only 'a'
- Add palindrome: 'a' + 'a' + 'a' â†’ code 0*100+0=0
- Update: left['a']=2, right['b']-- (but 'b' not in right yet)

**Step 3 - Process i=2 (middle='b'):**
- left: [2,0,0,...], right: [2,0,0,...] (after updates)
- Check: 'a' has left>0 and right>0
- Add palindrome: 'a' + 'b' + 'a' â†’ code 0*100+1=1
- Update: left['b']=1, right['c']--

**Step 4 - Process i=3 (middle='c'):**
- left: [2,1,0,...], right: [1,0,0,...]
- Check: 'a' has left>0 and right>0  
- Add palindrome: 'a' + 'c' + 'a' â†’ code 0*100+2=2
- Update: left['c']=1, right['a']--

**Unique Palindromes:** {0, 1, 2} â†’ 3 âœ“

**Decoding the stored values:**
- 0 = 0*100+0 â†’ 'a' + 'a' + 'a' = "aaa"
- 1 = 0*100+1 â†’ 'a' + 'b' + 'a' = "aba"  
- 2 = 0*100+2 â†’ 'a' + 'c' + 'a' = "aca"

## ğŸ’¡ Key Features
- **Efficient Encoding**: Store palindromes as integers to avoid string operations
- **Sliding Frequency**: Maintain left/right counts with O(1) updates
- **Early Pruning**: Only check characters that actually exist
- **Unique Tracking**: HashSet automatically handles duplicates

## ğŸš€ When to Use
- Palindrome counting problems
- When you need to track character distributions
- Problems with fixed-length patterns
- Subsequence counting with constraints

## âš ï¸ Edge Cases
- **All same characters**: "aaa" â†’ only one unique palindrome "aaa"
- **No palindromes**: "abc" â†’ return 0
- **Three characters**: "aba" â†’ one palindrome
- **Large input**: Efficient O(26n) handles 10^5

## ğŸ›  Variations
1. **First/Last Occurrence Approach**:
```java
public int countPalindromicSubsequence(String s) {
    int result = 0;
    for (char c = 'a'; c <= 'z'; c++) {
        int first = s.indexOf(c);
        int last = s.lastIndexOf(c);
        if (first != -1 && last != -1 && first < last) {
            Set<Character> middleChars = new HashSet<>();
            for (int i = first + 1; i < last; i++) {
                middleChars.add(s.charAt(i));
            }
            result += middleChars.size();
        }
    }
    return result;
}
```

2. **Bitmask Approach**:
```java
public int countPalindromicSubsequence(String s) {
    int n = s.length();
    int[] prefix = new int[n + 1];
    for (int i = 0; i < n; i++) {
        prefix[i + 1] = prefix[i] | (1 << (s.charAt(i) - 'a'));
    }
    
    int result = 0;
    int[] first = new int[26], last = new int[26];
    Arrays.fill(first, -1);
    for (int i = 0; i < n; i++) {
        int idx = s.charAt(i) - 'a';
        if (first[idx] == -1) first[idx] = i;
        last[idx] = i;
    }
    
    for (int i = 0; i < 26; i++) {
        if (first[i] != -1 && first[i] < last[i]) {
            int mask = prefix[last[i]] ^ prefix[first[i] + 1];
            result += Integer.bitCount(mask);
        }
    }
    return result;
}
```

## Mathematical Insight
The solution leverages:
- **Combinatorial Structure**: Fixed-length palindromes have symmetric form
- **Frequency Analysis**: Distribution of characters determines possibilities
- **Encoding Efficiency**: Integer representation avoids string overhead
- **Incremental Updates**: Sliding window maintains correct state

**Key Insight:**
For each middle position, the possible palindromes are determined by the intersection of characters that appear on both sides. The encoding `outer_char * 100 + middle_char` works because there are only 26 possible characters, so 100 provides enough separation.

The algorithm efficiently solves the problem by recognizing that we only need to track character presence (not exact counts or positions) and that the palindrome structure naturally decomposes into independent considerations for each possible outer character.