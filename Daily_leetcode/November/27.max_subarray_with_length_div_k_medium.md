# ðŸ”¢ Maximum Subarray Sum with Length Divisible by K - Prefix Sum with Modulo Tracking

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/maximum-subarray-sum-with-length-divisible-by-k/description/?envType=daily-question&envId=2025-11-27)

Given:
- An integer array `nums`
- An integer `k`

Find:
- The **maximum sum** of any subarray whose **length is divisible by k**
- A subarray is a contiguous part of the array

**Constraints:**
- `1 <= k <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`

**Example:**
```text
Input: nums = [1,2,3,4,5], k = 3
Output: 12

Explanation:
Subarrays with length divisible by 3:
- [1,2,3] â†’ sum=6
- [2,3,4] â†’ sum=9  
- [3,4,5] â†’ sum=12 (maximum)

Input: nums = [-1,-2,-3,-4,-5], k = 2
Output: -3

Explanation:
Subarrays with length divisible by 2:
- [-1,-2] â†’ sum=-3
- [-2,-3] â†’ sum=-5
- [-3,-4] â†’ sum=-7
- [-4,-5] â†’ sum=-9
Maximum: -3
```

## ðŸ§  Intuition
The solution uses:
1. **Prefix Sum Technique**: Calculate cumulative sums
2. **Modulo Property**: For subarray from i to j, length divisible by k means `(j-i+1) % k == 0`
3. **Mathematical Insight**: `(prefix[j] - prefix[i])` gives subarray sum, and we need `(j-i) % k == 0`
4. **Minimum Tracking**: Track minimum prefix sum for each modulo class

Key Insights:
- If `prefix[j] - prefix[i]` and `(j-i) % k == 0`, then `j % k == i % k`
- For each position j, we want the minimum `prefix[i]` where `i % k == j % k`
- The maximum subarray sum = `max(prefix[j] - min_prefix[i])` where `j % k == i % k`

## âš™ï¸ Approach
1. **Initialize**:
   - `prefSum`: running prefix sum
   - `minSoFar[k]`: track minimum prefix sum for each modulo class
   - Initialize `minSoFar[(k-1) % k] = 0` (virtual prefix at index -1)
2. **Process Each Element**:
   - Update prefix sum
   - For current index i, check against minimum prefix with same modulo
   - Update maximum subarray sum
   - Update minimum prefix for current modulo class
3. **Return**: Maximum subarray sum found

## âœ… Optimized Solution
```java
class Solution {
    public long maxSubarraySum(int[] nums, int k) {
        long prefixSum = 0;
        long maxSum = Long.MIN_VALUE;
        
        // minSoFar[r] stores the minimum prefix sum with index % k == r
        long[] minSoFar = new long[k];
        Arrays.fill(minSoFar, Long.MAX_VALUE / 2); // Avoid overflow
        
        // Initialize: prefix sum at index -1 is 0, and (-1) % k = (k-1) % k
        minSoFar[(k - 1) % k] = 0;
        
        for (int i = 0; i < nums.length; i++) {
            prefixSum += nums[i];
            int currentMod = i % k;
            
            // Maximum subarray ending at i with length divisible by k
            // = prefixSum - minSoFar[currentMod]
            maxSum = Math.max(maxSum, prefixSum - minSoFar[currentMod]);
            
            // Update minimum prefix sum for current modulo class
            minSoFar[currentMod] = Math.min(minSoFar[currentMod], prefixSum);
        }
        
        return maxSum;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through the array |
| **Space**       | O(k)       | Array to track minimum prefix sums |

## ðŸ“Š Example Walkthrough
**Input:** nums = [1,2,3,4,5], k = 3

**Step-by-step:**
- Initialize: minSoFar = [âˆž, âˆž, 0] (for mod 0,1,2)

1. **i=0** (mod=0):
   - prefixSum = 1
   - maxSum = max(âˆž, 1 - minSoFar[0]) = max(âˆž, 1-âˆž) = âˆž
   - minSoFar[0] = min(âˆž, 1) = 1

2. **i=1** (mod=1):
   - prefixSum = 1+2=3
   - maxSum = max(âˆž, 3 - minSoFar[1]) = max(âˆž, 3-âˆž) = âˆž
   - minSoFar[1] = min(âˆž, 3) = 3

3. **i=2** (mod=2):
   - prefixSum = 3+3=6
   - maxSum = max(âˆž, 6 - minSoFar[2]) = max(âˆž, 6-0) = 6
   - minSoFar[2] = min(0, 6) = 0

4. **i=3** (mod=0):
   - prefixSum = 6+4=10
   - maxSum = max(6, 10 - minSoFar[0]) = max(6, 10-1) = 9
   - minSoFar[0] = min(1, 10) = 1

5. **i=4** (mod=1):
   - prefixSum = 10+5=15
   - maxSum = max(9, 15 - minSoFar[1]) = max(9, 15-3) = 12
   - minSoFar[1] = min(3, 15) = 3

**Output:** 12 âœ“

## ðŸ’¡ How It Works
**Mathematical Foundation:**
For a subarray from i+1 to j:
- Sum = `prefix[j] - prefix[i]`
- Length = `j - i`
- We need: `(j - i) % k == 0`
- This implies: `j % k == i % k`

So for each position j, we look for the minimum `prefix[i]` where `i % k == j % k` and `i < j`.

**Why initialize `minSoFar[(k-1) % k] = 0`?**
- This represents the prefix sum before index 0 (virtual index -1)
- `(-1) % k = (k-1) % k` in Java's modulo operation
- This allows subarrays starting from index 0

## ðŸ’¡ Key Features
- **Modulo Tracking**: Groups prefix sums by their index modulo k
- **Optimal Substructure**: Each position only needs the minimum from its modulo class
- **Efficient**: Single pass with O(k) space
- **Handles Negatives**: Works with both positive and negative numbers

## ðŸš€ When to Use
- Subarray problems with length constraints
- When subarray length has divisibility conditions
- Prefix sum optimization problems
- Problems involving modulo arithmetic

## âš ï¸ Edge Cases
- **All negative numbers**: Still finds maximum (least negative)
- **k = 1**: All subarrays of length 1 are valid
- **k = n**: Only the entire array is valid
- **Single element**: k must be 1 for it to be valid

## ðŸ›  Variations
1. **Alternative Initialization**:
```java
public long maxSubarraySum(int[] nums, int k) {
    long prefixSum = 0;
    long maxSum = Long.MIN_VALUE;
    long[] minPrefix = new long[k];
    Arrays.fill(minPrefix, Long.MAX_VALUE);
    
    for (int i = 0; i < nums.length; i++) {
        if (i % k == (k - 1) % k) {
            minPrefix[i % k] = Math.min(minPrefix[i % k], prefixSum);
        }
        prefixSum += nums[i];
        maxSum = Math.max(maxSum, prefixSum - minPrefix[i % k]);
        minPrefix[i % k] = Math.min(minPrefix[i % k], prefixSum);
    }
    return maxSum;
}
```

2. **Using HashMap** (for variable k):
```java
// For cases where k might be large but sparse
```

3. **Brute Force** (for small n):
```java
public long maxSubarraySum(int[] nums, int k) {
    long maxSum = Long.MIN_VALUE;
    for (int i = 0; i < nums.length; i++) {
        long sum = 0;
        for (int j = i; j < nums.length; j++) {
            sum += nums[j];
            if ((j - i + 1) % k == 0) {
                maxSum = Math.max(maxSum, sum);
            }
        }
    }
    return maxSum;
}
```

## Mathematical Insight
The solution leverages:
- **Modular Arithmetic**: `(a - b) % k == 0` implies `a % k == b % k`
- **Prefix Sum Property**: Subarray sum = difference of prefix sums
- **Optimality Principle**: For each modulo class, only the minimum prefix sum matters
- **Monotonicity**: As we process left to right, we can greedily track minimums

**Key Formula:**
For subarray from i+1 to j with length divisible by k:
```
sum = prefix[j] - prefix[i]
where (j - i) % k == 0 â‡’ j % k == i % k
```

The algorithm elegantly solves the problem by recognizing that the length divisibility constraint translates to a modulo condition on the prefix sum indices, allowing us to use a simple array to track the minimum prefix sums for each residue class.