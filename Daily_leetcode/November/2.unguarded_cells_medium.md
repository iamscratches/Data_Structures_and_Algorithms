# üõ°Ô∏è Count Unguarded Cells in the Grid - Directional Marking Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/count-unguarded-cells-in-the-grid/description/?envType=daily-question&envId=2025-11-02)

Given:
- Grid dimensions `m √ó n`
- Arrays `guards` and `walls` containing positions
- Guards can see in **four directions** (up, down, left, right) until blocked
- Walls block vision, guards cannot see through them

Find:
- The number of **unguarded cells** in the grid

**Vision Rules:**
- Guards can see in all four cardinal directions
- Vision continues until hitting a wall or another guard
- Guards and walls occupy cells (cannot be unguarded)
- A cell is guarded if visible by any guard

**Constraints:**
- `1 <= m, n <= 10^5`
- `1 <= m * n <= 10^5`
- `0 <= guards.length, walls.length <= 5 * 10^4`

**Example:**
```text
Input: m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]
Output: 7

Explanation:
Grid with guards (G), walls (W), and vision coverage:
G W . . . .
. G . . W .
. . . G W .
. . . . . .

Unguarded cells are marked with dots (7 total)
```

## üß† Intuition
The solution uses:
1. **Grid State Tracking**: Use integers to represent cell states
2. **Directional Propagation**: Extend guard vision in four directions
3. **Blocking Detection**: Stop when hitting walls or guards
4. **State Encoding**: Different values for horizontal vs vertical guarding

Key Insights:
- Use value `1` for walls/guards (blocking cells)
- Use value `2` for horizontally guarded cells
- Use value `3` for vertically guarded cells  
- This prevents overcounting when guards see the same cell from different directions

## ‚öôÔ∏è Approach
1. **Initialize Grid**: Mark walls and guards as blocked (value 1)
2. **Process Each Guard**: For each guard, propagate vision in 4 directions
3. **Directional Propagation**:
   - Continue in each direction until hitting boundary or blocked cell
   - Mark cells as guarded (2 for horizontal, 3 for vertical)
   - Stop propagation when blocked
4. **Count Unguarded**: Count cells with value 0

## ‚úÖ Optimized Solution
```java
class Solution {
    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {
        int[][] grid = new int[m][n];
        int[][] directions = {{0,1}, {0,-1}, {1,0}, {-1,0}}; // right, left, down, up
        
        // Mark walls as blocked (value 1)
        for (int[] wall : walls) {
            grid[wall[0]][wall[1]] = 1;
        }
        
        // Process each guard
        for (int[] guard : guards) {
            int x = guard[0];
            int y = guard[1];
            
            // Mark guard position as blocked
            grid[x][y] = 1;
            
            // Propagate vision in all four directions
            for (int[] direction : directions) {
                int currX = x;
                int currY = y;
                
                while (true) {
                    // Move in current direction
                    currX += direction[0];
                    currY += direction[1];
                    
                    // Check boundaries and blocking cells
                    if (currX >= 0 && currX < m && currY >= 0 && currY < n && grid[currX][currY] != 1) {
                        
                        // Determine if this is horizontal or vertical direction
                        if (direction[0] == 1 || direction[0] == -1) { // Vertical movement
                            if (grid[currX][currY] == 2) {
                                // Already horizontally guarded from another direction, reset and break
                                break;
                            }
                            grid[currX][currY] = 3; // Mark as vertically guarded
                        } else { // Horizontal movement
                            if (grid[currX][currY] == 3) {
                                // Already vertically guarded from another direction, reset and break
                                break;
                            }
                            grid[currX][currY] = 2; // Mark as horizontally guarded
                        }
                    } else {
                        // Out of bounds or hit blocked cell, stop this direction
                        break;
                    }
                }
            }
        }
        
        // Count unguarded cells (value 0)
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    count++;
                }
            }
        }
        return count;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(m √ó n)   | Worst-case grid traversal |
| **Space**       | O(m √ó n)   | Grid storage |

**Note:** Due to constraints `m √ó n <= 10^5`, this is acceptable

## üìä Example Walkthrough
**Input:** m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[1,2],[2,1]]

**Step 1 - Mark Walls:**
```
[0,1,0]
[1,0,1]  
[0,1,0]
(Walls at [0,1], [1,0], [1,2], [2,1])
```

**Step 2 - Process Guard at [1,1]:**
- Mark guard position: grid[1][1] = 1
- **Right direction**: [1,2] is wall ‚Üí stop
- **Left direction**: [1,0] is wall ‚Üí stop  
- **Down direction**: [2,1] is wall ‚Üí stop
- **Up direction**: [0,1] is wall ‚Üí stop

**Step 3 - Count Unguarded:**
- Only corners [0,0], [0,2], [2,0], [2,2] are unguarded
- Count = 4

**Output:** 4 ‚úì

## üí° Key Features
- **State Encoding**: Different values for horizontal vs vertical guarding
- **Directional Propagation**: Efficient line-of-sight calculation
- **Early Termination**: Stop when blocked by walls or guards
- **Memory Efficient**: Single grid for all state tracking

## üöÄ When to Use
- Grid propagation problems
- Line-of-sight calculations
- When entities affect cells in straight lines
- Problems with blocking obstacles

## ‚ö†Ô∏è Edge Cases
- **Empty grid**: Should return 0
- **No guards**: All non-wall cells are unguarded
- **All walls**: No unguarded cells
- **Single cell**: Depends on guard/wall placement
- **Large sparse grid**: Efficient due to early termination

## üõ† Variations
1. **Separate Visited Sets**:
```java
// Use separate sets for horizontal and vertical visibility
```

2. **BFS/DFS Approach**:
```java
// Use BFS from each guard with direction tracking
```

3. **Direction Arrays**:
```java
// Process each direction separately for clarity
```

## Alternative Implementation (Clearer Direction Handling)
```java
class Solution {
    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {
        int[][] grid = new int[m][n]; // 0=unguarded, 1=blocked, 2=guarded
        
        // Mark walls and guards as blocked
        for (int[] wall : walls) grid[wall[0]][wall[1]] = 1;
        for (int[] guard : guards) grid[guard[0]][guard[1]] = 1;
        
        int[][] dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};
        
        for (int[] guard : guards) {
            for (int[] dir : dirs) {
                int x = guard[0] + dir[0];
                int y = guard[1] + dir[1];
                
                // Propagate in current direction
                while (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] != 1) {
                    grid[x][y] = 2; // Mark as guarded
                    x += dir[0];
                    y += dir[1];
                }
            }
        }
        
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) count++;
            }
        }
        return count;
    }
}
```

## Grid Propagation Insight
The solution leverages:
- **Ray Casting**: Simulate light rays from guards in straight lines
- **Obstacle Blocking**: Walls and guards stop propagation
- **State Management**: Track cell states to avoid double counting
- **Direction Independence**: Process each direction separately

**Key Optimization:**
- The original solution uses values 2 and 3 to distinguish horizontal/vertical guarding
- This prevents issues when multiple guards see the same cell from different directions
- However, a simpler approach with just "guarded" state often works for counting

The algorithm efficiently handles the vision propagation by simulating each guard's line of sight in all four directions, properly handling blocking by walls and other guards, and accurately counting the remaining unguarded cells.