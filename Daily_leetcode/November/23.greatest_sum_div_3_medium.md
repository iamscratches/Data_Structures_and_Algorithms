# ðŸ”¢ Greatest Sum Divisible by Three - Remainder Tracking Approach

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/greatest-sum-divisible-by-three/description/?envType=daily-question&envId=2025-11-23)

Given:
- An array `nums` of integers

Find:
- The **maximum possible sum** of elements such that the sum is divisible by 3
- You can choose any subset of elements (including empty set)

**Constraints:**
- `1 <= nums.length <= 4 * 10^4`
- `1 <= nums[i] <= 10^4`

**Example:**
```text
Input: nums = [3,6,5,1,8]
Output: 18

Explanation:
The maximum sum divisible by 3 is 3 + 6 + 1 + 8 = 18

Input: nums = [4]
Output: 0

Explanation:
No subset (except empty) gives sum divisible by 3, so return 0

Input: nums = [1,2,3,4,4]
Output: 12
Explanation: 4 + 4 + 3 + 1 = 12
```

## ðŸ§  Intuition
The solution uses:
1. **Total Sum Approach**: Start with sum of all elements
2. **Remainder Analysis**: If total sum not divisible by 3, remove smallest elements to fix remainder
3. **Two Smallest Tracking**: Track the two smallest numbers for each remainder (1 and 2)
4. **Optimal Removal**: Remove either one number with remainder=1 or two numbers with remainder=2 (and vice versa)

Key Insights:
- If sum % 3 == 0: return sum directly
- If sum % 3 == 1: remove either:
  - Smallest number with remainder 1, OR
  - Two smallest numbers with remainder 2
- If sum % 3 == 2: remove either:
  - Smallest number with remainder 2, OR  
  - Two smallest numbers with remainder 1

## âš™ï¸ Approach
1. **Calculate Total Sum**: Sum all elements
2. **Track Smallest Elements**: For remainders 1 and 2, track two smallest numbers
3. **Handle Remainder**:
   - If remainder 0: return sum
   - If remainder 1: remove min(one_remainder1, two_remainder2)
   - If remainder 2: remove min(one_remainder2, two_remainder1)
4. **Edge Cases**: Handle when required numbers don't exist

## âœ… Optimized Solution
```java
class Solution {
    public int maxSumDivThree(int[] nums) {
        int totalSum = 0;
        
        // Track the two smallest numbers for each remainder
        int minRem1_1 = Integer.MAX_VALUE; // Smallest with remainder 1
        int minRem1_2 = Integer.MAX_VALUE; // Second smallest with remainder 1
        int minRem2_1 = Integer.MAX_VALUE; // Smallest with remainder 2  
        int minRem2_2 = Integer.MAX_VALUE; // Second smallest with remainder 2
        
        for (int num : nums) {
            totalSum += num;
            int remainder = num % 3;
            
            if (remainder == 1) {
                // Update the two smallest numbers with remainder 1
                if (num < minRem1_1) {
                    minRem1_2 = minRem1_1;
                    minRem1_1 = num;
                } else if (num < minRem1_2) {
                    minRem1_2 = num;
                }
            } else if (remainder == 2) {
                // Update the two smallest numbers with remainder 2
                if (num < minRem2_1) {
                    minRem2_2 = minRem2_1;
                    minRem2_1 = num;
                } else if (num < minRem2_2) {
                    minRem2_2 = num;
                }
            }
        }
        
        int remainder = totalSum % 3;
        
        if (remainder == 0) {
            return totalSum;
        } else if (remainder == 1) {
            // Remove either: one number with remainder 1, or two numbers with remainder 2
            int removeOne = minRem1_1; // Single removal option
            int removeTwo = (minRem2_1 == Integer.MAX_VALUE || minRem2_2 == Integer.MAX_VALUE) 
                          ? Integer.MAX_VALUE : minRem2_1 + minRem2_2; // Double removal option
            
            int minRemove = Math.min(removeOne, removeTwo);
            return (minRemove == Integer.MAX_VALUE) ? 0 : totalSum - minRemove;
        } else { // remainder == 2
            // Remove either: one number with remainder 2, or two numbers with remainder 1
            int removeOne = minRem2_1; // Single removal option
            int removeTwo = (minRem1_1 == Integer.MAX_VALUE || minRem1_2 == Integer.MAX_VALUE)
                          ? Integer.MAX_VALUE : minRem1_1 + minRem1_2; // Double removal option
            
            int minRemove = Math.min(removeOne, removeTwo);
            return (minRemove == Integer.MAX_VALUE) ? 0 : totalSum - minRemove;
        }
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through the array |
| **Space**       | O(1)       | Only a few variables |

## ðŸ“Š Example Walkthrough
**Input:** nums = [3,6,5,1,8]

**Step 1 - Calculate Total Sum:**
- totalSum = 3+6+5+1+8 = 23
- Remainder = 23 % 3 = 2

**Step 2 - Track Smallest Elements:**
- Remainder 1: [1] â†’ minRem1_1=1, minRem1_2=MAX
- Remainder 2: [5,8] â†’ minRem2_1=5, minRem2_2=8

**Step 3 - Handle Remainder 2:**
- Option 1: Remove one remainder 2 number â†’ remove 5
- Option 2: Remove two remainder 1 numbers â†’ remove 1 + ? (only one available)
- Choose Option 1: remove 5
- Result: 23 - 5 = 18 âœ“

**Another Example:** nums = [1,2,3,4,4]
- totalSum = 1+2+3+4+4 = 14
- Remainder = 14 % 3 = 2
- Remainder 1: [1,4,4] â†’ minRem1_1=1, minRem1_2=4
- Remainder 2: [2] â†’ minRem2_1=2, minRem2_2=MAX
- Options: remove 2 (single) or remove 1+4=5 (double)
- Choose remove 2: 14-2=12 âœ“

## ðŸ’¡ Key Features
- **Greedy Optimal**: Always removes the smallest possible numbers
- **Efficient Tracking**: Maintains only the two smallest per remainder
- **Mathematical Insight**: Uses modulo 3 properties
- **Edge Case Handling**: Properly handles missing numbers

## ðŸš€ When to Use
- Subset sum problems with divisibility constraints
- When you need to optimize sum under modulo conditions
- Problems involving remainder analysis
- Greedy removal strategies

## âš ï¸ Edge Cases
- **Empty valid subset**: Return 0
- **All numbers same remainder**: May need to remove multiple
- **No numbers with required remainder**: Use alternative removal strategy
- **Single element arrays**: Simple modulo check

## ðŸ›  Variations
1. **Dynamic Programming Approach**:
```java
public int maxSumDivThree(int[] nums) {
    int[] dp = new int[3]; // dp[i] = max sum with remainder i
    for (int num : nums) {
        int[] newDp = dp.clone();
        for (int i = 0; i < 3; i++) {
            if (dp[i] != 0 || i == 0) {
                int newRem = (i + num) % 3;
                newDp[newRem] = Math.max(newDp[newRem], dp[i] + num);
            }
        }
        dp = newDp;
    }
    return dp[0];
}
```

2. **Sorting Approach**:
```java
public int maxSumDivThree(int[] nums) {
    List<Integer> rem1 = new ArrayList<>();
    List<Integer> rem2 = new ArrayList<>();
    int sum = 0;
    
    for (int num : nums) {
        sum += num;
        if (num % 3 == 1) rem1.add(num);
        else if (num % 3 == 2) rem2.add(num);
    }
    
    Collections.sort(rem1);
    Collections.sort(rem2);
    
    int rem = sum % 3;
    if (rem == 0) return sum;
    
    int remove = Integer.MAX_VALUE;
    if (rem == 1) {
        if (!rem1.isEmpty()) remove = Math.min(remove, rem1.get(0));
        if (rem2.size() >= 2) remove = Math.min(remove, rem2.get(0) + rem2.get(1));
    } else {
        if (!rem2.isEmpty()) remove = Math.min(remove, rem2.get(0));
        if (rem1.size() >= 2) remove = Math.min(remove, rem1.get(0) + rem1.get(1));
    }
    
    return remove == Integer.MAX_VALUE ? 0 : sum - remove;
}
```

## Mathematical Insight
The solution leverages:
- **Modular Arithmetic**: (a + b) % 3 = (a%3 + b%3) % 3
- **Remainder Properties**: To change sum remainder by 1, remove numbers with remainder 1 or add numbers with remainder 2 (but we're removing)
- **Optimal Substructure**: Best solution builds on removing minimal elements
- **Greedy Choice**: Always remove the smallest numbers to fix remainder

**Key Insight:**
If total sum has remainder r, we need to remove numbers whose remainders sum to r modulo 3:
- Remove one number with remainder r, OR
- Remove two numbers with remainders that sum to r modulo 3

The algorithm efficiently solves the problem by combining mathematical insight about modular arithmetic with a greedy approach to minimize the removal cost, providing an optimal solution in linear time.