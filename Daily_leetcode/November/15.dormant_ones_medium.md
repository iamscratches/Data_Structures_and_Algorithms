# ðŸ”¢ Count the Number of Substrings with Dominant Ones - Contiguous Ones Counting

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/count-the-number-of-substrings-with-dominant-ones/description/?envType=daily-question&envId=2025-11-15)

Given:
- A binary string `s` containing only '0's and '1's

Find:
- The number of **substrings** that contain only '1's
- Return answer modulo 10^9 + 7

**Substring Definition:**
- A contiguous sequence of characters within the string
- A substring of "101" would be "1", "0", "1", "10", "01", "101"
- We only count substrings that contain **only '1's**

**Constraints:**
- `1 <= s.length <= 10^5`

**Example:**
```text
Input: s = "0110111"
Output: 9

Explanation:
Substrings containing only '1's:
- "1" (index 1)
- "1" (index 2) 
- "11" (index 1-2)
- "1" (index 4)
- "1" (index 5)
- "1" (index 6)
- "11" (index 5-6)
- "111" (index 4-6)
- "1" (index 4) - wait, this seems duplicate

Let's list systematically:
Length 1: positions 1,2,4,5,6 â†’ 5 substrings
Length 2: positions 1-2, 5-6 â†’ 2 substrings  
Length 3: positions 4-6 â†’ 1 substring
Total: 5 + 2 + 1 = 8? But output is 9.

Wait, positions 4-6 gives "111" which has:
- "1" at 4, "1" at 5, "1" at 6
- "11" at 4-5, "11" at 5-6  
- "111" at 4-6
That's 3 + 2 + 1 = 6 from just the "111" segment!
```

## ðŸ§  Intuition
The solution uses:
1. **Contiguous Segment Processing**: Count consecutive '1's
2. **Triangular Number Formula**: For n consecutive '1's, there are nÃ—(n+1)/2 substrings
3. **Running Counter**: Track current streak of '1's
4. **Modulo Arithmetic**: Handle large numbers

Key Insights:
- When we have k consecutive '1's, they form k single-char substrings, (k-1) 2-char substrings, etc.
- Total substrings from k consecutive '1's = 1 + 2 + ... + k = kÃ—(k+1)/2
- Process string linearly, reset counter at '0's

## âš™ï¸ Approach
1. **Initialize**: 
   - `currentStreak` = consecutive '1's count
   - `total` = total valid substrings
2. **Process Each Character**:
   - If '1': increment streak, add streak to total
   - If '0': reset streak to 0
3. **Return**: Total modulo 10^9+7

## âœ… Optimized Solution
```java
class Solution {
    public int numSub(String s) {
        long currentStreak = 0;      // Current consecutive ones count
        long totalSubstrings = 0;    // Total valid substrings
        long mod = 1000000007;       // Modulo value
        
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '1') {
                currentStreak++;
                // Add the number of new substrings ending at current position
                totalSubstrings = (totalSubstrings + currentStreak) % mod;
            } else {
                currentStreak = 0;   // Reset streak when we hit '0'
            }
        }
        
        return (int) totalSubstrings;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through the string |
| **Space**       | O(1)       | Only a few variables |

## ðŸ“Š Example Walkthrough
**Input:** s = "0110111"

**Step-by-step processing:**
1. **i=0**: '0' â†’ currentStreak=0, total=0
2. **i=1**: '1' â†’ currentStreak=1, total=0+1=1
3. **i=2**: '1' â†’ currentStreak=2, total=1+2=3
4. **i=3**: '0' â†’ currentStreak=0, total=3
5. **i=4**: '1' â†’ currentStreak=1, total=3+1=4
6. **i=5**: '1' â†’ currentStreak=2, total=4+2=6
7. **i=6**: '1' â†’ currentStreak=3, total=6+3=9

**Output:** 9 âœ“

**Verification:**
Let's list all substrings containing only '1's:
- From "11" at indices 1-2: "1"(1), "1"(2), "11"
- From "1" at index 4: "1"(4)
- From "111" at indices 4-6: 
  - "1"(4), "1"(5), "1"(6)
  - "11"(4-5), "11"(5-6) 
  - "111"(4-6)

Total: 3 + 1 + 6 = 10? Wait, let's count carefully:

**Actual substrings:**
1. "1" at index 1
2. "1" at index 2
3. "11" at indices 1-2
4. "1" at index 4
5. "1" at index 5  
6. "1" at index 6
7. "11" at indices 4-5
8. "11" at indices 5-6
9. "111" at indices 4-6

Total: 9 âœ“

## ðŸ’¡ Key Features
- **Efficient Counting**: Linear time complexity
- **Mathematical Insight**: Uses triangular number pattern
- **Incremental Update**: Add current streak length at each step
- **Modulo Handling**: Prevents integer overflow

## ðŸš€ When to Use
- Counting contiguous segments with specific properties
- Problems involving substring counting
- When substrings have simple pattern (all same character)
- Cumulative counting problems

## âš ï¸ Edge Cases
- **All zeros**: Return 0
- **All ones**: Return nÃ—(n+1)/2
- **Single character**: Return 1 if '1', 0 if '0'
- **Large input**: Modulo prevents overflow

## ðŸ›  Variations
1. **Explicit Triangular Number**:
```java
public int numSub(String s) {
    long total = 0, mod = 1000000007;
    int streak = 0;
    
    for (int i = 0; i <= s.length(); i++) {
        if (i < s.length() && s.charAt(i) == '1') {
            streak++;
        } else {
            // When streak ends, add triangular number
            total = (total + (long)streak * (streak + 1) / 2) % mod;
            streak = 0;
        }
    }
    
    return (int) total;
}
```

2. **Two Pointer Approach**:
```java
public int numSub(String s) {
    long total = 0, mod = 1000000007;
    int left = 0;
    
    for (int right = 0; right < s.length(); right++) {
        if (s.charAt(right) == '1') {
            total = (total + (right - left + 1)) % mod;
        } else {
            left = right + 1;
        }
    }
    
    return (int) total;
}
```

3. **Split and Calculate**:
```java
public int numSub(String s) {
    long total = 0, mod = 1000000007;
    String[] ones = s.split("0");
    
    for (String segment : ones) {
        long n = segment.length();
        total = (total + n * (n + 1) / 2) % mod;
    }
    
    return (int) total;
}
```

## Mathematical Insight
The solution leverages:
- **Triangular Numbers**: Sum of first k integers = kÃ—(k+1)/2
- **Combinatorial Counting**: Each contiguous segment of k '1's contributes C(k+1, 2) substrings
- **Linearity of Expectation**: Total = sum of contributions from all segments
- **Incremental Computation**: Can compute online without storing segments

**Key Formula:**
For a contiguous segment of k '1's:
```
Number of substrings = 1 + 2 + 3 + ... + k = k Ã— (k + 1) / 2
```

The algorithm provides an elegant O(n) solution by recognizing that at each position, the number of new substrings ending at that position equals the current streak length of consecutive '1's. This incremental approach avoids the need to explicitly find all segments and apply the triangular number formula separately for each one.