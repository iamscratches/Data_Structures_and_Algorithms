# ğŸ—‘ï¸ Delete Nodes From Linked List Present in Array - Hash Set Approach

## ğŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/delete-nodes-from-linked-list-present-in-array/?envType=daily-question&envId=2025-11-01)

Given:
- An array `nums` containing integer values to delete
- A linked list `head`
- Delete all nodes from the linked list whose values are present in the array

Find:
- Return the modified linked list after deletion

**Deletion Rules:**
- Remove all nodes where `node.val` exists in `nums`
- Maintain the relative order of remaining nodes
- Handle consecutive deletions correctly

**Constraints:**
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^5`
- All values in `nums` are unique
- The number of nodes in the list is in the range `[1, 10^5]`
- `1 <= Node.val <= 10^5`

**Example:**
```text
Input: nums = [1,2], head = [1,2,3,4,5]
Output: [3,4,5]

Explanation:
Delete nodes with values 1 and 2, remaining list: 3â†’4â†’5

Input: nums = [2,3], head = [1,2,3,4,5]
Output: [1,4,5]

Explanation:
Delete nodes with values 2 and 3, remaining list: 1â†’4â†’5
```

## ğŸ§  Intuition
The solution uses:
1. **Hash Set for O(1) Lookup**: Store values to delete for fast access
2. **Two-Pass Deletion**: Handle head deletions separately from internal nodes
3. **Pointer Manipulation**: Update next pointers to skip deleted nodes
4. **Dummy Node Alternative**: Implicit handling without extra node

Key Insights:
- First handle potential head deletions (special case)
- Then traverse and skip nodes that need deletion
- Use while loops to handle consecutive deletions
- Maintain current pointer for list traversal

## âš™ï¸ Approach
1. **Store Values to Delete**: Convert array to HashSet for O(1) lookups
2. **Handle Head Deletions**: Remove leading nodes that need deletion
3. **Traverse and Delete**: For each node, check if next node should be deleted
4. **Skip Deleted Nodes**: Update next pointers to bypass deleted nodes
5. **Return Modified Head**: Return the (potentially new) head

## âœ… Optimized Solution
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode modifiedList(int[] nums, ListNode head) {
        // Step 1: Store values to delete in HashSet for O(1) lookups
        java.util.HashSet<Integer> valuesToDelete = new java.util.HashSet<>();
        for (int x : nums) {
            valuesToDelete.add(x);
        }
        
        // Step 2: Handle head deletions - remove leading nodes to delete
        while (head != null && valuesToDelete.contains(head.val)) {
            head = head.next;
        }
        
        // If list becomes empty after head deletions
        if (head == null) {
            return null;
        }
        
        // Step 3: Traverse list and delete internal nodes
        ListNode current = head;
        while (current != null && current.next != null) {
            // Skip consecutive nodes that need deletion
            while (current.next != null && valuesToDelete.contains(current.next.val)) {
                current.next = current.next.next;
            }
            // Move to next valid node
            current = current.next;
        }
        
        return head;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n + m)   | n = list length, m = nums length |
| **Space**       | O(m)       | HashSet to store values to delete |

## ğŸ“Š Example Walkthrough
**Input:** nums = [2,3], head = [1,2,3,4,5]

**Step 1 - Create HashSet:**
- valuesToDelete = {2, 3}

**Step 2 - Check Head:**
- head.val = 1 â†’ not in set â†’ keep head

**Step 3 - Traverse List:**
- current = node(1)
- current.next = node(2) â†’ in set â†’ skip: 1â†’3
- current.next = node(3) â†’ in set â†’ skip: 1â†’4
- current.next = node(4) â†’ not in set â†’ move current to node(4)
- current.next = node(5) â†’ not in set â†’ move current to node(5)

**Result:** 1â†’4â†’5 âœ“

**Another Example:** nums = [1,2], head = [1,2,3,4,5]
- Step 2: head=1 â†’ in set â†’ head = 2
- head=2 â†’ in set â†’ head = 3
- head=3 â†’ not in set â†’ keep
- Traverse: 3â†’4â†’5 all not in set
- Result: 3â†’4â†’5 âœ“

## ğŸ’¡ Key Features
- **Efficient Lookups**: HashSet provides O(1) deletion checks
- **In-place Modification**: No extra space for new list
- **Consecutive Handling**: While loop handles multiple deletions in row
- **Head Special Case**: Separate handling for leading deletions

## ğŸš€ When to Use
- Linked list filtering problems
- When you need to remove elements based on condition
- Problems requiring O(1) value lookups
- List manipulation with deletion constraints

## âš ï¸ Edge Cases
- **Empty list**: Should return null
- **All nodes deleted**: Return null
- **Head deletion**: Multiple leading deletions
- **Consecutive deletions**: Multiple nodes in row to delete
- **Single node list**: Handle deletion of only node

## ğŸ›  Variations
1. **Dummy Node Approach**:
```java
public ListNode modifiedList(int[] nums, ListNode head) {
    Set<Integer> toDelete = new HashSet<>();
    for (int num : nums) toDelete.add(num);
    
    ListNode dummy = new ListNode(0, head);
    ListNode current = dummy;
    
    while (current.next != null) {
        if (toDelete.contains(current.next.val)) {
            current.next = current.next.next;
        } else {
            current = current.next;
        }
    }
    
    return dummy.next;
}
```

2. **Recursive Approach**:
```java
public ListNode modifiedList(int[] nums, ListNode head) {
    Set<Integer> toDelete = new HashSet<>();
    for (int num : nums) toDelete.add(num);
    
    if (head == null) return null;
    if (toDelete.contains(head.val)) {
        return modifiedList(nums, head.next);
    }
    head.next = modifiedList(nums, head.next);
    return head;
}
```

## Alternative Implementation (With Dummy Node)
```java
class Solution {
    public ListNode modifiedList(int[] nums, ListNode head) {
        Set<Integer> deleteSet = new HashSet<>();
        for (int num : nums) deleteSet.add(num);
        
        // Use dummy node to simplify head deletion handling
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode current = dummy;
        
        while (current.next != null) {
            if (deleteSet.contains(current.next.val)) {
                // Skip the next node
                current.next = current.next.next;
            } else {
                // Move to next node
                current = current.next;
            }
        }
        
        return dummy.next;
    }
}
```

## Linked List Insight
The solution leverages:
- **Pointer Manipulation**: Directly modify next pointers for deletion
- **Sentinel Node**: Implicit or explicit dummy node handling
- **Traversal Strategy**: Look ahead to next node rather than current
- **Early Termination**: Stop when no more nodes to process

**Key Techniques:**
- **Head Special Case**: Handle separately or use dummy node
- **Look-ahead Deletion**: Check current.next instead of current
- **Consecutive Skip**: While loop for multiple deletions in sequence
- **Memory Efficiency**: In-place modification without extra list

The algorithm efficiently solves the problem by combining the speed of hash set lookups with careful linked list pointer manipulation, ensuring optimal performance even for the upper constraint limits.