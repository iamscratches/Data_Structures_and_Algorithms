# ðŸ”¢ Make Sum Divisible by P - Prefix Sum with Hash Map

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/make-sum-divisible-by-p/description/?envType=daily-question&envId=2025-11-30)

Given:
- An array `nums` of positive integers
- An integer `p`
- You can remove a **subarray** (contiguous elements)

Find:
- The **length of the smallest subarray** to remove so that the sum of remaining elements is divisible by `p`
- Return -1 if it's impossible

**Constraints:**
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^9`
- `1 <= p <= 10^9`

**Example:**
```text
Input: nums = [3,1,4,2], p = 6
Output: 1

Explanation:
Total sum = 3+1+4+2 = 10
10 % 6 = 4
We need to remove a subarray with sum % 6 = 4
Subarray [4] has sum 4 â†’ remove it â†’ remaining sum = 6 (divisible by 6)
Length of smallest such subarray = 1

Input: nums = [6,3,5,2], p = 9
Output: 2

Explanation:
Total sum = 16, 16 % 9 = 7
Need to remove subarray with sum % 9 = 7
Subarray [5,2] has sum 7 â†’ remove it â†’ remaining sum = 9
```

## ðŸ§  Intuition
The solution uses:
1. **Modular Arithmetic**: Work with remainders instead of actual sums
2. **Prefix Sum**: Calculate cumulative sums modulo p
3. **Hash Map Lookup**: Store previous prefix sums for O(1) lookups
4. **Mathematical Insight**: If total remainder is r, we need to find prefix[j] - prefix[i] â‰¡ r (mod p)

Key Insights:
- Total sum % p = r (the remainder we need to remove)
- We want: (prefix[j] - prefix[i]) % p = r
- Equivalently: prefix[j] â‰¡ (prefix[i] + r) % p
- Use hash map to store earliest occurrences of prefix sums

## âš™ï¸ Approach
1. **Calculate Total Remainder**: total_sum % p
2. **Base Case**: If remainder is 0, no removal needed
3. **Prefix Sum Tracking**:
   - Maintain running prefix sum modulo p
   - For each position, calculate needed complementary prefix sum
   - Use hash map to find earliest occurrence of needed prefix
4. **Find Minimum**: Track smallest subarray length that satisfies the condition

## âœ… Optimized Solution
```java
class Solution {
    public int minSubarray(int[] nums, int p) {
        // Calculate total sum and the remainder we need to remove
        long totalSum = 0;
        for (int num : nums) {
            totalSum += num;
        }
        
        long targetRemainder = totalSum % p;
        // If already divisible, no subarray needs to be removed
        if (targetRemainder == 0) {
            return 0;
        }
        
        // Map to store prefix_sum_mod_p -> earliest index
        Map<Long, Integer> prefixMap = new HashMap<>();
        prefixMap.put(0L, -1); // Base case: prefix sum 0 at index -1
        
        long prefixSum = 0;
        int minLength = nums.length; // Initialize with maximum possible
        
        for (int i = 0; i < nums.length; i++) {
            prefixSum = (prefixSum + nums[i]) % p;
            
            // We need: (prefixSum - needed) % p = targetRemainder
            // So: needed = (prefixSum - targetRemainder + p) % p
            long neededPrefix = (prefixSum - targetRemainder + p) % p;
            
            if (prefixMap.containsKey(neededPrefix)) {
                int subarrayLength = i - prefixMap.get(neededPrefix);
                minLength = Math.min(minLength, subarrayLength);
            }
            
            // Store current prefix sum with current index
            prefixMap.put(prefixSum, i);
        }
        
        // If we found no solution or the solution is to remove entire array
        return minLength == nums.length ? -1 : minLength;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass with hash map operations |
| **Space**       | O(n)       | Hash map storage |

## ðŸ“Š Example Walkthrough
**Input:** nums = [3,1,4,2], p = 6

**Step 1 - Calculate Total:**
- totalSum = 3+1+4+2 = 10
- targetRemainder = 10 % 6 = 4

**Step 2 - Process Array:**
- Initialize: prefixMap = {0: -1}, prefixSum = 0

**i=0** (num=3):
- prefixSum = (0+3)%6 = 3
- neededPrefix = (3-4+6)%6 = 5
- prefixMap doesn't contain 5
- Store: prefixMap = {0:-1, 3:0}

**i=1** (num=1):
- prefixSum = (3+1)%6 = 4
- neededPrefix = (4-4+6)%6 = 0
- prefixMap contains 0 at index -1 â†’ subarray length = 1 - (-1) = 2
- minLength = 2
- Store: prefixMap = {0:-1, 3:0, 4:1}

**i=2** (num=4):
- prefixSum = (4+4)%6 = 2
- neededPrefix = (2-4+6)%6 = 4
- prefixMap contains 4 at index 1 â†’ subarray length = 2-1 = 1
- minLength = 1
- Store: prefixMap = {0:-1, 3:0, 4:1, 2:2}

**i=3** (num=2):
- prefixSum = (2+2)%6 = 4
- neededPrefix = (4-4+6)%6 = 0
- prefixMap contains 0 at index -1 â†’ subarray length = 3 - (-1) = 4
- minLength remains 1

**Output:** 1 âœ“

## ðŸ’¡ How It Works
**Mathematical Foundation:**
Let:
- Total sum = S, S % p = r
- We need to remove subarray with sum % p = r
- Prefix sum up to i: P[i] = (nums[0] + ... + nums[i]) % p
- Subarray from i+1 to j has sum: (P[j] - P[i]) % p
- We want: (P[j] - P[i]) % p = r
- This means: P[j] â‰¡ (P[i] + r) % p

So for each j, we look for the largest i < j such that P[i] â‰¡ (P[j] - r) % p

## ðŸ’¡ Key Features
- **Modular Arithmetic**: Handles large numbers efficiently
- **Prefix Sum Optimization**: O(1) range sum queries
- **Hash Map Efficiency**: O(1) lookups for complementary values
- **Early Index Storage**: Always store earliest occurrence for minimum length

## ðŸš€ When to Use
- Subarray problems with modulo conditions
- When you need to find complementary pairs
- Problems involving prefix sums with specific properties
- Range sum queries with constraints

## âš ï¸ Edge Cases
- **Already divisible**: Return 0 immediately
- **No solution**: Return -1
- **Single element**: May be the solution
- **Entire array**: Check if removing entire array works
- **Large p**: Modular arithmetic handles this

## ðŸ›  Variations
1. **Using Integer for Prefix Sums**:
```java
public int minSubarray(int[] nums, int p) {
    long total = 0;
    for (int num : nums) total += num;
    int target = (int)(total % p);
    if (target == 0) return 0;
    
    Map<Integer, Integer> prefixMap = new HashMap<>();
    prefixMap.put(0, -1);
    
    int prefix = 0;
    int minLen = nums.length;
    
    for (int i = 0; i < nums.length; i++) {
        prefix = (prefix + nums[i]) % p;
        int need = (prefix - target + p) % p;
        
        if (prefixMap.containsKey(need)) {
            minLen = Math.min(minLen, i - prefixMap.get(need));
        }
        prefixMap.put(prefix, i);
    }
    
    return minLen == nums.length ? -1 : minLen;
}
```

2. **Array instead of HashMap** (when p is small):
```java
// Only works if p is small enough
```

3. **Two Pass Approach**:
```java
// First calculate total, then find minimum subarray
```

## Mathematical Insight
The solution leverages:
- **Modular Arithmetic Properties**: (a - b) % p = (a%p - b%p + p) % p
- **Prefix Sum Difference**: Subarray sum = difference of prefix sums
- **Complementary Search**: For each prefix, find its complementary partner
- **Optimal Substructure**: Earliest occurrence gives shortest subarray

**Key Formula:**
For subarray from i+1 to j to have sum % p = r:
```
(P[j] - P[i]) % p = r
â‡’ P[i] â‰¡ (P[j] - r) % p
```

The algorithm efficiently solves the problem by combining prefix sums with hash map lookups to find the shortest subarray that, when removed, makes the remaining sum divisible by p.