# ðŸ”¢ Binary Prefix Divisible By 5 - Modular Arithmetic Approach

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/binary-prefix-divisible-by-5/description/?envType=daily-question&envId=2025-11-24)

Given:
- A binary array `nums` (contains only 0s and 1s)

Find:
- For each prefix of the array, determine if the **binary number** formed by that prefix is divisible by 5
- Return a list of boolean values where result[i] is true if nums[0..i] is divisible by 5

**Prefix Definition:**
- prefix[0] = first element
- prefix[1] = first two elements  
- prefix[i] = first i+1 elements
- Each prefix represents a binary number (most significant bit first)

**Constraints:**
- `1 <= nums.length <= 10^5`
- `nums[i]` is either 0 or 1

**Example:**
```text
Input: nums = [0,1,1]
Output: [true,false,false]

Explanation:
- prefix[0] = "0" (binary) = 0 â†’ divisible by 5 âœ“
- prefix[1] = "01" (binary) = 1 â†’ not divisible by 5 âœ—
- prefix[2] = "011" (binary) = 3 â†’ not divisible by 5 âœ—

Input: nums = [1,1,1]
Output: [false,false,false]

Input: nums = [0,1,1,1,1,1]
Output: [true,false,false,false,true,false]
```

## ðŸ§  Intuition
The solution uses:
1. **Modular Arithmetic**: Instead of storing large numbers, track remainder modulo 5
2. **Binary Shift Property**: Left shift = multiply by 2, then add new bit
3. **State Preservation**: Only need current remainder, not entire number
4. **Early Modulo**: Apply modulo 5 at each step to prevent overflow

Key Insights:
- When we add a new bit, the number becomes: `new_val = old_val * 2 + new_bit`
- We only care about the value modulo 5: `(old_val * 2 + new_bit) % 5`
- This allows us to handle very long binary strings without overflow
- Divisibility by 5 is equivalent to remainder 0 modulo 5

## âš™ï¸ Approach
1. **Initialize**: Start with current value = 0
2. **Process Each Bit**:
   - Left shift current value: `val = val * 2` (equivalent to `val << 1`)
   - Add new bit: `val = val | nums[i]` 
   - Take modulo 5: `val = val % 5`
   - Check if remainder is 0
3. **Store Result**: Add boolean to result list

## âœ… Optimized Solution
```java
class Solution {
    public List<Boolean> prefixesDivBy5(int[] nums) {
        List<Boolean> result = new ArrayList<>();
        int currentValue = 0;
        
        for (int i = 0; i < nums.length; i++) {
            // Equivalent to: currentValue = currentValue * 2 + nums[i]
            currentValue = (currentValue << 1) | nums[i];
            
            // Keep the value manageable by taking modulo 5
            currentValue %= 5;
            
            // Check if divisible by 5 (remainder 0)
            result.add(currentValue == 0);
        }
        
        return result;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through the array |
| **Space**       | O(1)       | Excluding output list, only a few variables |

## ðŸ“Š Example Walkthrough
**Input:** nums = [0,1,1]

**Step-by-step:**
1. **i=0**: 
   - currentValue = (0 << 1) | 0 = 0
   - 0 % 5 = 0 â†’ true
2. **i=1**:
   - currentValue = (0 << 1) | 1 = 1  
   - 1 % 5 = 1 â†’ false
3. **i=2**:
   - currentValue = (1 << 1) | 1 = 3
   - 3 % 5 = 3 â†’ false

**Output:** [true, false, false] âœ“

**Another Example:** nums = [1,1,1]
1. i=0: (0<<1)|1=1 â†’ 1%5=1 â†’ false
2. i=1: (1<<1)|1=3 â†’ 3%5=3 â†’ false  
3. i=2: (3<<1)|1=7 â†’ 7%5=2 â†’ false
**Output:** [false, false, false] âœ“

**Example with Larger Numbers:** nums = [0,1,1,1,1,1]
1. i=0: 0 â†’ 0%5=0 â†’ true
2. i=1: 1 â†’ 1%5=1 â†’ false
3. i=2: 3 â†’ 3%5=3 â†’ false
4. i=3: 7 â†’ 7%5=2 â†’ false
5. i=4: 15 â†’ 15%5=0 â†’ true âœ“
6. i=5: 31 â†’ 31%5=1 â†’ false

## ðŸ’¡ How It Works
**Mathematical Foundation:**
- Binary number: `bâ‚€bâ‚bâ‚‚...bâ‚™ = bâ‚€Ã—2â¿ + bâ‚Ã—2â¿â»Â¹ + ... + bâ‚™`
- Modular property: `(a + b) % m = (a%m + b%m) % m`
- Modular property: `(a Ã— b) % m = (a%m Ã— b%m) % m`

When processing bit by bit:
```
new_value = old_value Ã— 2 + new_bit
new_value % 5 = (old_value Ã— 2 + new_bit) % 5
```

**Bitwise Operations:**
- `val << 1` = multiply by 2
- `val | bit` = add the bit (since val ends with 0 after shift)

## ðŸ’¡ Key Features
- **Avoids Overflow**: Modulo operation keeps numbers small
- **Efficient**: Single pass with constant operations per bit
- **Bitwise Optimization**: Uses shift and OR for performance
- **Mathematical**: Leverages modular arithmetic properties

## ðŸš€ When to Use
- Processing large numbers bit by bit
- Divisibility checking problems
- When intermediate values can grow exponentially
- Stream processing of binary data

## âš ï¸ Edge Cases
- **All zeros**: [0,0,0] â†’ [true,true,true]
- **Single element**: [1] â†’ [false]
- **Large input**: Handles 10^5 bits efficiently
- **Pattern recognition**: Some binary patterns are always divisible by 5

## ðŸ›  Variations
1. **Explicit Multiplication**:
```java
public List<Boolean> prefixesDivBy5(int[] nums) {
    List<Boolean> result = new ArrayList<>();
    int current = 0;
    for (int num : nums) {
        current = (current * 2 + num) % 5;
        result.add(current == 0);
    }
    return result;
}
```

2. **Using Long** (for smaller inputs):
```java
public List<Boolean> prefixesDivBy5(int[] nums) {
    List<Boolean> result = new ArrayList<>();
    long current = 0;
    for (int num : nums) {
        current = (current * 2 + num) % 5;
        result.add(current == 0);
    }
    return result;
}
```

3. **Functional Style**:
```java
public List<Boolean> prefixesDivBy5(int[] nums) {
    final int[] current = {0};
    return Arrays.stream(nums)
                .mapToObj(num -> {
                    current[0] = (current[0] * 2 + num) % 5;
                    return current[0] == 0;
                })
                .collect(Collectors.toList());
}
```

## Mathematical Insight
The solution leverages:
- **Modular Arithmetic**: `(a + b) % m = (a%m + b%m) % m`
- **Distributive Property**: `(a Ã— b) % m = (a%m Ã— b%m) % m`
- **State Machine**: Current remainder is the only state needed
- **Binary Representation**: MSB-first processing matches natural reading order

**Key Property:**
For binary number `B` with new bit `b`:
```
B_new = 2 Ã— B_old + b
B_new % 5 = (2 Ã— (B_old % 5) + b) % 5
```

This allows us to track only the remainder modulo 5 instead of the actual binary number, which can grow exponentially with the number of bits.

The algorithm elegantly solves the problem by recognizing that we don't need the actual binary values - we only need to know their remainders when divided by 5, and these remainders can be computed incrementally using modular arithmetic.