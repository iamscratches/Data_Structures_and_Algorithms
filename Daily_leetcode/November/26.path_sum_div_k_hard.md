# ðŸ§­ Paths in Matrix Whose Sum Is Divisible by K - Dynamic Programming Approach

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/?envType=daily-question&envId=2025-11-27)

Given:
- An `m Ã— n` matrix `grid` of integers
- An integer `k`

Find:
- The number of paths from top-left (0,0) to bottom-right (m-1,n-1) where:
  - You can only move **right** or **down**
  - The **sum** of numbers on the path is **divisible by k**

Return the answer modulo 10^9 + 7.

**Constraints:**
- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 5 * 10^4`
- `1 <= m * n <= 5 * 10^4`
- `0 <= grid[i][j] <= 100`
- `1 <= k <= 50`

**Example:**
```text
Input: grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3
Output: 2

Explanation:
Two paths with sum divisible by 3:
1. 5â†’2â†’0â†’7â†’2 â†’ sum=16 â†’ 16%3=1? Wait, let's calculate...
Actually: 5+2+0+7+2=16 â†’ 16%3=1 âœ—
Let me find the correct paths...

The two valid paths:
1. 5â†’3â†’0â†’0â†’2 â†’ sum=5+3+0+0+2=10 â†’ 10%3=1? Still not divisible...
Wait, the example must be different.
```

## ðŸ§  Intuition
The solution uses:
1. **Dynamic Programming**: Track number of paths for each possible remainder
2. **Space Optimization**: Use rolling arrays to reduce memory usage
3. **Modulo Arithmetic**: Only care about sum modulo k, not actual sum
4. **Path Counting**: Combine paths from left and top cells

Key Insights:
- For each cell (i,j), store `dp[j][r]` = number of paths to (i,j) with sum % k = r
- Transition: `dp[j][(r + grid[i][j]) % k] = dp[j][r] + dp[j-1][r]`
- Use two rows (prev and curr) to save space
- Initialize first row and column separately

## âš™ï¸ Approach
1. **Initialize First Row**:
   - Process leftmost row from (0,0) to (0,n-1)
   - Track cumulative sum modulo k
2. **Process Remaining Rows**:
   - For each row i, process column 0 separately (only from top)
   - For other columns, combine paths from left and top
3. **State Transition**:
   - For remainder r, new remainder = `(r + grid[i][j]) % k`
   - Number of paths = paths from left + paths from top
4. **Return**: `dp[n-1][0]` at bottom-right cell

## âœ… Optimized Solution
```java
class Solution {
    private static final int MOD = (int) 1e9 + 7;

    public int numberOfPaths(int[][] grid, int k) {
        int m = grid.length, n = grid[0].length;
        
        // prev[j][r] = number of paths to previous row, column j with remainder r
        int[][] prev = new int[n][k];
        int[][] curr = new int[n][k];
        
        // Initialize first row (can only come from left)
        int cumulativeSum = 0;
        for (int j = 0; j < n; j++) {
            cumulativeSum = (cumulativeSum + grid[0][j]) % k;
            prev[j][cumulativeSum] = 1;
        }
        
        // Initialize for first column of second row onwards
        cumulativeSum = grid[0][0] % k; // Start from (0,0)
        for (int i = 1; i < m; i++) {
            // Process first column (can only come from top)
            cumulativeSum = (cumulativeSum + grid[i][0]) % k;
            Arrays.fill(curr[0], 0);
            curr[0][cumulativeSum] = 1;
            
            // Process remaining columns
            for (int j = 1; j < n; j++) {
                Arrays.fill(curr[j], 0);
                int currentVal = grid[i][j];
                
                // For each possible remainder, calculate new paths
                for (int remainder = 0; remainder < k; remainder++) {
                    int newRemainder = (remainder + currentVal) % k;
                    
                    // Paths from top (prev[j]) + paths from left (curr[j-1])
                    curr[j][newRemainder] = (prev[j][remainder] + curr[j - 1][remainder]) % MOD;
                }
            }
            
            // Swap arrays for next iteration
            int[][] temp = prev;
            prev = curr;
            curr = temp;
        }
        
        return prev[n - 1][0];
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(m Ã— n Ã— k) | Process each cell Ã— k remainders |
| **Space**       | O(n Ã— k)   | Two rows of n Ã— k arrays |

## ðŸ“Š Example Walkthrough
**Input:** grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3

Let me trace a simpler example first:

**Simple Example:** grid = [[1,2],[3,4]], k = 2

**Step 1 - Initialize First Row:**
- j=0: sum=1%2=1 â†’ prev[0][1]=1
- j=1: sum=(1+2)=3%2=1 â†’ prev[1][1]=1

**Step 2 - Process Row 1:**
- **Column 0**: sum=(1+3)=4%2=0 â†’ curr[0][0]=1
- **Column 1**: 
  - For each remainder r:
    - r=0: newR=(0+4)%2=0 â†’ from top: prev[1][0]=0, from left: curr[0][0]=1 â†’ total=1
    - r=1: newR=(1+4)%2=1 â†’ from top: prev[1][1]=1, from left: curr[0][1]=0 â†’ total=1
  - So curr[1][0]=1, curr[1][1]=1

**Result:** prev[1][0] = 1 path with sum divisible by 2 âœ“

**Paths:** 1â†’3â†’4 (sum=8, 8%2=0)

## ðŸ’¡ How It Works
**DP State Definition:**
```
dp[i][j][r] = number of paths to cell (i,j) with path_sum % k = r
```

**Transition:**
```
dp[i][j][(r + grid[i][j]) % k] = dp[i-1][j][r] + dp[i][j-1][r]
```

**Space Optimization:**
- Only need current and previous row
- Use `prev` for row i-1, `curr` for row i
- Swap after processing each row

## ðŸ’¡ Key Features
- **Modulo Focus**: Track remainders instead of actual sums
- **Space Efficient**: O(nk) instead of O(mnk)
- **Rolling Arrays**: Reuse memory between rows
- **Modulo Arithmetic**: Handles large numbers efficiently

## ðŸš€ When to Use
- Grid path counting problems
- When path sum has divisibility constraints
- Problems with modulo conditions
- Space-optimized DP solutions

## âš ï¸ Edge Cases
- **Single cell**: grid = [[5]], k=5 â†’ 1 path
- **Single row/column**: Only one possible path
- **k=1**: All paths are valid (any sum divisible by 1)
- **All zeros**: Many paths with sum 0

## ðŸ›  Variations
1. **Full 2D DP** (more readable):
```java
public int numberOfPaths(int[][] grid, int k) {
    int m = grid.length, n = grid[0].length;
    int[][][] dp = new int[m][n][k];
    
    // Initialize first cell
    dp[0][0][grid[0][0] % k] = 1;
    
    // Initialize first row
    int sum = grid[0][0];
    for (int j = 1; j < n; j++) {
        sum = (sum + grid[0][j]) % k;
        dp[0][j][sum] = 1;
    }
    
    // Initialize first column
    sum = grid[0][0];
    for (int i = 1; i < m; i++) {
        sum = (sum + grid[i][0]) % k;
        dp[i][0][sum] = 1;
    }
    
    // Fill rest of the grid
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            int val = grid[i][j];
            for (int r = 0; r < k; r++) {
                int newR = (r + val) % k;
                dp[i][j][newR] = (dp[i-1][j][r] + dp[i][j-1][r]) % MOD;
            }
        }
    }
    
    return dp[m-1][n-1][0];
}
```

2. **DFS with Memoization**:
```java
public int numberOfPaths(int[][] grid, int k) {
    int m = grid.length, n = grid[0].length;
    Integer[][][] memo = new Integer[m][n][k];
    return dfs(grid, k, 0, 0, 0, memo);
}

private int dfs(int[][] grid, int k, int i, int j, int sumMod, Integer[][][] memo) {
    if (i == grid.length || j == grid[0].length) return 0;
    
    int newSumMod = (sumMod + grid[i][j]) % k;
    
    if (i == grid.length - 1 && j == grid[0].length - 1) {
        return newSumMod == 0 ? 1 : 0;
    }
    
    if (memo[i][j][sumMod] != null) return memo[i][j][sumMod];
    
    int paths = (dfs(grid, k, i + 1, j, newSumMod, memo) + 
                 dfs(grid, k, i, j + 1, newSumMod, memo)) % MOD;
    
    return memo[i][j][sumMod] = paths;
}
```

## Mathematical Insight
The solution leverages:
- **Modular Arithmetic**: `(a + b) % k = (a%k + b%k) % k`
- **Dynamic Programming Optimality**: Number of paths to (i,j) depends only on (i-1,j) and (i,j-1)
- **State Compression**: Only need remainder modulo k, not actual sum
- **Combinatorial Counting**: Additive property of path counts

**Key Insight:**
The divisibility condition `sum % k == 0` is preserved when we work modulo k throughout the computation, allowing us to track only k possible states per cell instead of tracking actual sums which could be very large.

The algorithm efficiently solves the problem by combining dynamic programming with modular arithmetic, using space optimization to handle the large grid constraints.