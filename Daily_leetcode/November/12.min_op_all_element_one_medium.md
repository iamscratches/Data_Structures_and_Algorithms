# ðŸ”¢ Minimum Operations to Make All Array Elements Equal to 1 - GCD Approach

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/description/?envType=daily-question&envId=2025-11-12)

Given:
- An array `nums` of integers
- In one operation, you can choose two **adjacent** elements and replace one with their GCD

Find:
- The **minimum number of operations** to make all elements equal to 1
- Return -1 if it's impossible

**Operation Rules:**
- Choose two adjacent elements `nums[i]` and `nums[i+1]`
- Replace either `nums[i]` or `nums[i+1]` with `gcd(nums[i], nums[i+1])`
- Goal: Make **all elements** equal to 1

**Constraints:**
- `2 <= nums.length <= 50`
- `1 <= nums[i] <= 10^6`

**Example:**
```text
Input: nums = [2,6,3,4]
Output: 4

Explanation:
Operation sequence:
1. Replace nums[1] with gcd(6,3)=3 â†’ [2,3,3,4]
2. Replace nums[0] with gcd(2,3)=1 â†’ [1,3,3,4]  
3. Replace nums[1] with gcd(1,3)=1 â†’ [1,1,3,4]
4. Replace nums[2] with gcd(1,3)=1 â†’ [1,1,1,4]
5. Replace nums[3] with gcd(1,4)=1 â†’ [1,1,1,1]
Total operations: 5? Wait, output says 4. Let me check...
```

## ðŸ§  Intuition
The solution uses:
1. **GCD Propagation**: Use GCD to create 1s and spread them
2. **Three Cases**:
   - Case 1: Already have 1s - just spread them
   - Case 2: No 1s but GCD of entire array is 1 - create one 1 then spread
   - Case 3: GCD of entire array > 1 - impossible
3. **Minimum Segment**: Find shortest subarray that can produce a 1

Key Insights:
- If any element is 1, we can spread it to neighbors using GCD(1, x) = 1
- If no 1 exists, we need to create one first
- To create a 1, we need a subarray whose GCD is 1
- The shortest such subarray minimizes operations

## âš™ï¸ Approach
1. **Count Existing 1s**: If any 1 exists, just spread them
2. **Check Overall GCD**: If GCD of all elements > 1, return -1
3. **Find Minimum Segment**: Find shortest subarray with GCD = 1
4. **Calculate Operations**:
   - Create first 1: (segment_length - 1) operations
   - Spread to all: (n - 1) operations
   - Total: segment_length + n - 2

## âœ… Optimized Solution
```java
class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        int onesCount = 0;
        int overallGcd = 0;
        
        // Step 1: Count existing 1s and compute overall GCD
        for (int num : nums) {
            if (num == 1) {
                onesCount++;
            }
            overallGcd = gcd(overallGcd, num);
        }
        
        // Case 1: If we already have 1s, just spread them
        if (onesCount > 0) {
            return n - onesCount;
        }
        
        // Case 2: If overall GCD > 1, impossible to create 1
        if (overallGcd > 1) {
            return -1;
        }
        
        // Case 3: Find shortest subarray that can produce GCD = 1
        int minSegmentLength = n;
        
        for (int i = 0; i < n; i++) {
            int currentGcd = 0;
            for (int j = i; j < n; j++) {
                currentGcd = gcd(currentGcd, nums[j]);
                
                // Found a subarray that can produce 1
                if (currentGcd == 1) {
                    minSegmentLength = Math.min(minSegmentLength, j - i + 1);
                    break; // No need to check longer subarrays starting at i
                }
            }
        }
        
        // Operations = (create first 1) + (spread to all elements)
        // create first 1: minSegmentLength - 1 operations
        // spread to all: n - 1 operations  
        // But we double-count one operation? Let's see the formula:
        return minSegmentLength + n - 2;
    }
    
    // Euclidean algorithm for GCD
    private int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(nÂ²)      | Nested loops to find minimum segment |
| **Space**       | O(1)       | Only a few variables |

## ðŸ“Š Example Walkthrough
**Input:** nums = [2,6,3,4]

**Step 1 - Check Initial State:**
- onesCount = 0 (no 1s initially)
- overallGcd = gcd(gcd(gcd(0,2),6),3),4) = 1 âœ“ (possible)

**Step 2 - Find Minimum Segment:**
- i=0: [2]â†’gcd=2, [2,6]â†’gcd=2, [2,6,3]â†’gcd=1 â†’ length=3
- i=1: [6]â†’gcd=6, [6,3]â†’gcd=3, [6,3,4]â†’gcd=1 â†’ length=3  
- i=2: [3]â†’gcd=3, [3,4]â†’gcd=1 â†’ length=2 âœ“
- i=3: [4]â†’gcd=4 â†’ no
- minSegmentLength = 2

**Step 3 - Calculate Operations:**
- Create first 1: length=2 â†’ 2-1 = 1 operation
- Spread to all: n=4 â†’ 4-1 = 3 operations
- But formula gives: 2 + 4 - 2 = 4 operations

**Operation Sequence for [2,6,3,4]:**
1. Replace nums[2] with gcd(3,4)=1 â†’ [2,6,1,4] (using segment [3,4])
2. Replace nums[1] with gcd(6,1)=1 â†’ [2,1,1,4] 
3. Replace nums[0] with gcd(2,1)=1 â†’ [1,1,1,4]
4. Replace nums[3] with gcd(1,4)=1 â†’ [1,1,1,1]
Total: 4 operations âœ“

## ðŸ’¡ Key Features
- **GCD-based Strategy**: Leverages mathematical properties
- **Three Case Analysis**: Clear handling of different scenarios
- **Optimal Segment Finding**: Minimizes operations by finding shortest path to 1
- **Efficient GCD**: Euclidean algorithm for fast computation

## ðŸš€ When to Use
- Problems involving GCD operations
- When you need to propagate values through adjacent elements
- Array transformation with mathematical operations
- Problems with "contagious" value spreading

## âš ï¸ Edge Cases
- **All elements 1**: Return 0 (already done)
- **Single element array**: Only possible if element is 1
- **No solution**: When overall GCD > 1
- **Minimum segment at boundaries**: Handled by full array scan

## ðŸ›  Variations
1. **Alternative GCD Implementation**:
```java
private int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```

2. **Early Termination**:
```java
// Stop early if found segment of length 2 (minimum possible)
```

3. **Memoization**:
```java
// Precompute GCD for all subarrays (for larger n)
```

## Mathematical Insight
The solution leverages:
- **GCD Properties**: gcd(a,b) divides both a and b, gcd(1,x)=1
- **Subarray GCD**: Monotonic decreasing as subarray grows
- **Operation Counting**: Creating 1 vs spreading 1 have different costs
- **Optimal Strategy**: Create 1 in shortest segment, then propagate

**Key Formula:**
```
Operations = (min_segment_length - 1) + (n - 1)
           = min_segment_length + n - 2
```

**Why This Formula Works:**
- `min_segment_length - 1`: Operations to reduce the segment to a single 1
- `n - 1`: Operations to spread the 1 to all other elements
- The connection between these two steps saves one operation

The algorithm efficiently solves the problem by combining mathematical insight about GCD with a systematic search for the optimal way to introduce the first 1 into the array.