# ‚ö° Maximize the Minimum Powered City - Binary Search with Difference Array

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/?envType=daily-question&envId=2025-11-07)

Given:
- `stations` array representing power stations in each city
- Integer `r` - each station powers cities within distance r
- Integer `k` - maximum number of new stations to build

**Power Distribution:**
- A station at position i powers all cities in range [i-r, i+r]
- Total power in a city = sum of all stations that can reach it
- You can build at most k new stations (anywhere)

Find:
- The **maximum possible minimum power** across all cities after building at most k stations

**Constraints:**
- `n == stations.length`
- `1 <= n <= 10^5`
- `0 <= stations[i] <= 10^5`
- `0 <= r <= n - 1`
- `0 <= k <= 10^9`

**Example:**
```text
Input: stations = [1,2,3,4,5], r = 1, k = 2
Output: 5

Explanation:
Initial powers with r=1:
City 0: stations[0] + stations[1] = 1+2=3
City 1: stations[0] + stations[1] + stations[2] = 1+2+3=6
City 2: stations[1] + stations[2] + stations[3] = 2+3+4=9
City 3: stations[2] + stations[3] + stations[4] = 3+4+5=12
City 4: stations[3] + stations[4] = 4+5=9
Minimum = 3

We can build 2 stations to increase minimum to 5.
```

## üß† Intuition
The solution uses:
1. **Binary Search**: Search for the maximum achievable minimum power
2. **Difference Array**: Efficiently compute and update power distribution
3. **Greedy Placement**: Add stations where most needed (rightmost possible)
4. **Sliding Window**: Track current power as we process cities

Key Insights:
- Use binary search to find the maximum minimum power
- For each candidate, check if we can achieve it with ‚â§ k stations
- Use difference array for efficient range updates
- Place new stations as far right as possible to maximize coverage

## ‚öôÔ∏è Approach
1. **Precompute Initial Powers**:
   - Use difference array to efficiently compute power at each city
   - Each station at i contributes to range [i-r, i+r]

2. **Binary Search Setup**:
   - Lower bound: minimum initial power
   - Upper bound: total power + k (theoretical maximum)

3. **Feasibility Check**:
   - For candidate value, compute additional stations needed
   - Use greedy: when city needs more power, add station at i+r
   - Track used stations and ensure ‚â§ k

## ‚úÖ Optimized Solution
```java
class Solution {
    public long maxPower(int[] stations, int r, int k) {
        int n = stations.length;
        
        // Step 1: Precompute initial power using difference array
        long[] powerDiff = new long[n + 1];
        
        for (int i = 0; i < n; i++) {
            int left = Math.max(0, i - r);
            int right = Math.min(n, i + r + 1);
            powerDiff[left] += stations[i];
            powerDiff[right] -= stations[i];
        }
        
        // Step 2: Binary search for maximum minimum power
        long minInitial = Arrays.stream(stations).min().getAsInt();
        long maxPossible = Arrays.stream(stations).asLongStream().sum() + k;
        long result = 0;
        
        while (minInitial <= maxPossible) {
            long mid = minInitial + (maxPossible - minInitial) / 2;
            
            if (isFeasible(powerDiff.clone(), mid, r, k)) {
                result = mid;
                minInitial = mid + 1; // Try for higher minimum
            } else {
                maxPossible = mid - 1; // Too high, try lower
            }
        }
        
        return result;
    }
    
    private boolean isFeasible(long[] powerDiff, long targetMin, int r, int k) {
        int n = powerDiff.length - 1;
        long currentPower = 0;
        long stationsUsed = 0;
        
        for (int i = 0; i < n; i++) {
            // Add the power contribution for current position
            currentPower += powerDiff[i];
            
            // If current power is less than target, we need to add stations
            if (currentPower < targetMin) {
                long additionalNeeded = targetMin - currentPower;
                
                // Check if we have enough stations remaining
                if (stationsUsed + additionalNeeded > k) {
                    return false;
                }
                
                stationsUsed += additionalNeeded;
                
                // Add station at the farthest possible position (i + r)
                // This station will cover from i to i + 2r
                int stationPos = Math.min(n, i + 2 * r + 1);
                powerDiff[stationPos] -= additionalNeeded;
                
                // The station contributes to current and future positions
                currentPower += additionalNeeded;
            }
        }
        
        return true;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n log S) | n cities √ó binary search over sum range |
| **Space**       | O(n)       | Difference array storage |

Where S is the search space size (sum of stations + k)

## üìä Example Walkthrough
**Input:** stations = [1,2,3,4,5], r = 1, k = 2

**Step 1 - Precompute Initial Powers:**
- Using difference array:
  - Station 0: affects [0,2] ‚Üí diff[0]+=1, diff[2]-=1
  - Station 1: affects [0,3] ‚Üí diff[0]+=2, diff[3]-=2
  - Station 2: affects [1,4] ‚Üí diff[1]+=3, diff[4]-=3
  - Station 3: affects [2,5] ‚Üí diff[2]+=4, diff[5]-=4
  - Station 4: affects [3,5] ‚Üí diff[3]+=5, diff[5]-=5

**Compute actual powers:**
- City 0: 1+2=3
- City 1: 1+2+3=6  
- City 2: 2+3+4=9
- City 3: 3+4+5=12
- City 4: 4+5=9
Minimum = 3

**Step 2 - Binary Search:**
- Search range: 3 to (1+2+3+4+5)+2=17
- Check mid=10: Need to add stations to reach min power 10
- Check mid=5: Feasible with 2 stations
- Check mid=6: Not feasible with 2 stations
- Result = 5

## üí° Key Features
- **Binary Search Efficiency**: Logarithmic search over large range
- **Difference Array**: O(1) range updates for power computation
- **Greedy Optimal**: Rightmost placement maximizes coverage
- **Early Termination**: Stop when k stations exhausted

## üöÄ When to Use
- Maximization problems with constraints
- When you need to find maximum achievable minimum
- Problems involving range updates and queries
- Resource allocation with coverage constraints

## ‚ö†Ô∏è Edge Cases
- **r = 0**: Each station only powers its own city
- **k = 0**: Cannot add any stations
- **All stations zero**: Start from scratch
- **Large r**: Stations cover entire array
- **Single city**: Simple case

## üõ† Variations
1. **Prefix Sum Approach**:
```java
// Use prefix sums instead of difference array
```

2. **Segment Tree**:
```java
// Use segment tree for range updates and queries
```

3. **Two Pointer**:
```java
// Use sliding window to track current power
```

## Alternative Implementation (With Explanation)
```java
class Solution {
    public long maxPower(int[] stations, int r, int k) {
        int n = stations.length;
        
        // Compute initial power at each city using sliding window
        long[] power = new long[n];
        long windowSum = 0;
        
        // First compute for first r+1 cities
        for (int i = 0; i <= Math.min(n-1, r); i++) {
            windowSum += stations[i];
        }
        
        power[0] = windowSum;
        
        // Slide window to compute power for all cities
        for (int i = 1; i < n; i++) {
            // Remove city that moved out of left range
            if (i - r - 1 >= 0) {
                windowSum -= stations[i - r - 1];
            }
            // Add city that moved into right range
            if (i + r < n) {
                windowSum += stations[i + r];
            }
            power[i] = windowSum;
        }
        
        // Binary search for answer
        long left = 0;
        long right = Arrays.stream(power).max().getAsLong() + k;
        long answer = 0;
        
        while (left <= right) {
            long mid = left + (right - left) / 2;
            
            if (canAchieve(power, mid, r, k)) {
                answer = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return answer;
    }
    
    private boolean canAchieve(long[] power, long target, int r, int k) {
        int n = power.length;
        long[] arr = power.clone();
        long used = 0;
        long add = 0;
        
        for (int i = 0; i < n; i++) {
            if (i > 2 * r) {
                add -= arr[i - 2 * r - 1];
            }
            
            if (arr[i] + add < target) {
                long need = target - (arr[i] + add);
                if (used + need > k) return false;
                used += need;
                add += need;
            }
        }
        
        return true;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Monotonicity**: If minimum x is achievable, all values < x are achievable
- **Binary Search Principle**: Enables efficient search in large space
- **Range Update Optimization**: Difference array provides O(1) updates
- **Greedy Placement**: Rightmost placement is optimal for coverage

**Key Formula:**
For candidate value `mid`:
- For each city i, if `power[i] < mid`, need `mid - power[i]` additional stations
- Place stations at position `i + r` to maximize coverage
- Total stations used must be `‚â§ k`

The algorithm efficiently finds the optimal solution by combining binary search with greedy station placement and efficient range updates using difference arrays, scaling to the large constraint limits.