# 0Ô∏è‚É£1Ô∏è‚É£ Ones and Zeroes - 2D Knapsack DP Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/ones-and-zeroes/description/?envType=daily-question&envId=2025-11-11)

Given:
- An array `strs` of binary strings
- Integers `m` (maximum 0s allowed) and `n` (maximum 1s allowed)

Find:
- The **maximum size of a subset** of `strs` such that:
  - Total number of 0s in the subset ‚â§ `m`
  - Total number of 1s in the subset ‚â§ `n`

**Constraints:**
- `1 <= strs.length <= 600`
- `1 <= strs[i].length <= 100`
- `strs[i]` consists only of '0' and '1'
- `1 <= m, n <= 100`

**Example:**
```text
Input: strs = ["10","0001","111001","1","0"], m = 5, n = 3
Output: 4

Explanation:
The subset {"10", "0001", "1", "0"} is valid:
- Total 0s: 1 + 3 + 0 + 1 = 5 ‚â§ m=5
- Total 1s: 1 + 1 + 1 + 0 = 3 ‚â§ n=3
Maximum subset size = 4
```

## üß† Intuition
The solution uses:
1. **2D Knapsack DP**: Treat as knapsack with two constraints (0s and 1s)
2. **Bottom-up DP**: Build solution from smaller subproblems
3. **Reverse Iteration**: Process items backwards to avoid overwriting
4. **State Transition**: For each string, decide whether to include it

Key Insights:
- Each string has a "cost" in terms of 0s and 1s
- We have a "budget" of m 0s and n 1s
- Classic 0/1 knapsack problem with two dimensions
- Use DP[i][j] = max subset size with i 0s and j 1s remaining

## ‚öôÔ∏è Approach
1. **DP Initialization**: Create (m+1) √ó (n+1) DP table
2. **Process Each String**:
   - Count 0s and 1s in current string
   - Update DP table from bottom-right to top-left
3. **State Transition**:
   - For each (i, j) where i ‚â• zeros and j ‚â• ones:
     - DP[i][j] = max(DP[i][j], DP[i-zeros][j-ones] + 1)
4. **Return Result**: DP[m][n] contains the answer

## ‚úÖ Optimized Solution
```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        // DP table: dp[i][j] = max subset size using i zeros and j ones
        int[][] dp = new int[m + 1][n + 1];
        
        for (String str : strs) {
            // Count zeros and ones in current string
            int zeros = 0, ones = 0;
            for (char c : str.toCharArray()) {
                if (c == '0') zeros++;
                else ones++;
            }
            
            // Update DP table from bottom-right to avoid overwriting
            for (int i = m; i >= zeros; i--) {
                for (int j = n; j >= ones; j--) {
                    // Either skip current string or take it
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
                }
            }
        }
        
        return dp[m][n];
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(L + k √ó m √ó n) | L = total string length, k = number of strings |
| **Space**       | O(m √ó n)   | DP table size |

## üìä Example Walkthrough
**Input:** strs = ["10","0001","111001","1","0"], m = 5, n = 3

**Step 1 - Process "10" (zeros=1, ones=1):**
- Update positions where i‚â•1, j‚â•1
- dp[1][1] = max(0, dp[0][0]+1) = 1
- dp[5][3] = max(0, dp[4][2]+1) = 1

**Step 2 - Process "0001" (zeros=3, ones=1):**
- dp[4][2] = max(1, dp[1][1]+1) = 2
- dp[5][3] = max(1, dp[2][2]+1) = 2

**Step 3 - Process "111001" (zeros=2, ones=4):**
- Skip (ones=4 > n=3), no updates

**Step 4 - Process "1" (zeros=0, ones=1):**
- dp[5][3] = max(2, dp[5][2]+1) = 3
- dp[5][2] = max(2, dp[5][1]+1) = 2

**Step 5 - Process "0" (zeros=1, ones=0):**
- dp[5][3] = max(3, dp[4][3]+1) = 4

**Final:** dp[5][3] = 4 ‚úì

## üí° Key Features
- **2D Knapsack**: Classic DP extension to two constraints
- **Space Optimization**: 2D DP instead of 3D
- **Reverse Iteration**: Prevents reusing same string multiple times
- **Early Pruning**: Skip strings that exceed individual constraints

## üöÄ When to Use
- Multi-constraint knapsack problems
- When items have multiple "costs"
- Subset selection with resource constraints
- Problems with two-dimensional budgets

## ‚ö†Ô∏è Edge Cases
- **Empty array**: Return 0
- **m=0, n=0**: Can only take empty strings (if any)
- **All strings exceed budget**: Return 0
- **Single string**: Include if within budget

## üõ† Variations
1. **3D DP Approach**:
```java
public int findMaxForm(String[] strs, int m, int n) {
    int[][][] dp = new int[strs.length + 1][m + 1][n + 1];
    for (int i = 1; i <= strs.length; i++) {
        int zeros = countZeros(strs[i-1]);
        int ones = strs[i-1].length() - zeros;
        for (int j = 0; j <= m; j++) {
            for (int k = 0; k <= n; k++) {
                dp[i][j][k] = dp[i-1][j][k];
                if (j >= zeros && k >= ones) {
                    dp[i][j][k] = Math.max(dp[i][j][k], dp[i-1][j-zeros][k-ones] + 1);
                }
            }
        }
    }
    return dp[strs.length][m][n];
}
```

2. **Recursive with Memoization**:
```java
public int findMaxForm(String[] strs, int m, int n) {
    Integer[][][] memo = new Integer[strs.length][m+1][n+1];
    return dfs(strs, 0, m, n, memo);
}

private int dfs(String[] strs, int idx, int zeros, int ones, Integer[][][] memo) {
    if (idx == strs.length) return 0;
    if (memo[idx][zeros][ones] != null) return memo[idx][zeros][ones];
    
    int[] count = countZerosOnes(strs[idx]);
    int take = 0;
    if (zeros >= count[0] && ones >= count[1]) {
        take = 1 + dfs(strs, idx+1, zeros-count[0], ones-count[1], memo);
    }
    int skip = dfs(strs, idx+1, zeros, ones, memo);
    
    return memo[idx][zeros][ones] = Math.max(take, skip);
}
```

## Alternative Implementation (With Helper Method)
```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        
        for (String str : strs) {
            int[] count = countZerosOnes(str);
            int zeros = count[0], ones = count[1];
            
            // Process in reverse to avoid using same string multiple times
            for (int i = m; i >= zeros; i--) {
                for (int j = n; j >= ones; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
                }
            }
        }
        
        return dp[m][n];
    }
    
    private int[] countZerosOnes(String str) {
        int zeros = 0, ones = 0;
        for (char c : str.toCharArray()) {
            if (c == '0') zeros++;
            else ones++;
        }
        return new int[]{zeros, ones};
    }
}
```

## Mathematical Insight
The solution leverages:
- **Dynamic Programming Optimal Substructure**: Solution builds on smaller subproblems
- **0/1 Knapsack Principle**: Each string can be taken or skipped
- **Two-dimensional State**: Track both zero and one usage
- **Reverse Iteration**: Ensures each string is used at most once

**State Transition Formula:**
```
dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1)
```
where:
- `i` = remaining zeros budget
- `j` = remaining ones budget  
- `zeros` = zeros in current string
- `ones` = ones in current string

The algorithm elegantly solves the problem by treating it as a two-dimensional knapsack, where each string has a cost in terms of both zeros and ones, and we want to maximize the number of strings selected without exceeding either budget constraint.