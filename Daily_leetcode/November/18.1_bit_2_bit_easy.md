# ðŸ”¤ 1-bit and 2-bit Characters - Greedy Decoding Approach

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/1-bit-and-2-bit-characters/description/?envType=daily-question&envId=2025-11-18)

Given:
- An array `bits` that always ends with 0
- Two types of characters:
  - **1-bit character**: represented by `0`
  - **2-bit character**: represented by `10` or `11`

Find:
- Whether the last character must be a **1-bit character**
- Return `true` if the last character can only be decoded as a 1-bit character, `false` otherwise

**Encoding Rules:**
- `0` â†’ 1-bit character
- `10` or `11` â†’ 2-bit character  
- The array is guaranteed to be a valid encoding of some string

**Constraints:**
- `1 <= bits.length <= 1000`
- `bits[i]` is either 0 or 1
- The array always ends with 0

**Example:**
```text
Input: bits = [1,0,0]
Output: true

Explanation:
Possible decodings:
- [1,0] (2-bit) + [0] (1-bit) â†’ last is 1-bit âœ“
- [1] + [0] + [0] â†’ invalid (1 alone is not valid)
So last character must be 1-bit.

Input: bits = [1,1,1,0]
Output: false

Explanation:
Possible decodings:
- [1,1] (2-bit) + [1,0] (2-bit) â†’ last is 2-bit âœ—
- [1,1] (2-bit) + [1] + [0] â†’ invalid
- [1] + [1,1] (2-bit) + [0] â†’ invalid  
So last character could be part of 2-bit character.
```

## ðŸ§  Intuition
The solution uses:
1. **Greedy Decoding**: Always decode from left to right
2. **Jump-based Processing**: Skip 1 or 2 bits based on current value
3. **Position Tracking**: See where we land after decoding everything before last character
4. **Final Check**: If we land exactly at last position, it must be 1-bit

Key Insights:
- If we encounter `0`, it must be a 1-bit character (move 1 step)
- If we encounter `1`, it must be the start of a 2-bit character (move 2 steps)  
- Process until we reach or pass the last character
- If we land exactly at last index, it must be a 1-bit character

## âš™ï¸ Approach
1. **Initialize**: Start at index 0
2. **Greedy Decode**:
   - If current bit is 0 â†’ move 1 step forward
   - If current bit is 1 â†’ move 2 steps forward (it starts a 2-bit character)
3. **Terminate**: Stop when we reach or pass the last character
4. **Check**: If we land exactly at last index, return true

## âœ… Optimized Solution
```java
class Solution {
    public boolean isOneBitCharacter(int[] bits) {
        int n = bits.length;
        int i = 0;
        
        // Greedily decode until we reach the last character
        while (i < n - 1) {
            // If current bit is 1, it must be start of 2-bit character
            // If current bit is 0, it must be 1-bit character
            i += bits[i] + 1;
        }
        
        // If we land exactly at the last index, last character is 1-bit
        return i == n - 1;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through bits (with jumps) |
| **Space**       | O(1)       | Only a few variables |

## ðŸ“Š Example Walkthrough
**Input:** bits = [1,0,0]

**Step-by-step:**
1. **i=0**: bits[0]=1 â†’ move i += 1 + 1 = 2
2. **i=2**: now i = n-1 = 2 â†’ stop
3. **Check**: i == n-1 â†’ return true âœ“

**Explanation:**
- We decoded [1,0] as a 2-bit character
- Landed exactly at last position, so [0] must be 1-bit character

**Input:** bits = [1,1,1,0]

**Step-by-step:**
1. **i=0**: bits[0]=1 â†’ move i += 1 + 1 = 2
2. **i=2**: bits[2]=1 â†’ move i += 1 + 1 = 4
3. **i=4**: now i â‰¥ n-1 (3) â†’ stop  
4. **Check**: i == n-1? 4 == 3? â†’ false âœ“

**Explanation:**
- We decoded [1,1] as 2-bit character, then [1,0] as 2-bit character
- Landed beyond last position, so last 0 was part of 2-bit character

## ðŸ’¡ How It Works
The key insight is in the jump logic:
- `bits[i] + 1` gives:
  - If `bits[i] = 0` â†’ `0 + 1 = 1` (move 1 step: 1-bit character)
  - If `bits[i] = 1` â†’ `1 + 1 = 2` (move 2 steps: 2-bit character)

This automatically handles the greedy decoding where every `1` must be followed by another bit to form a valid 2-bit character.

## ðŸ’¡ Key Features
- **Greedy Optimal**: Always makes the correct decoding choice
- **Efficient**: Single pass with jumps
- **Simple Logic**: Clean mathematical expression
- **Early Termination**: Stops when last character is reached

## ðŸš€ When to Use
- Prefix-free code decoding problems
- When encoding has specific patterns/rules
- Greedy parsing problems
- State machine-like processing

## âš ï¸ Edge Cases
- **Single element**: [0] â†’ return true (only one 1-bit character)
- **Two elements**: [1,0] â†’ return false (last is part of 2-bit)
- **All zeros**: [0,0,0] â†’ return true (all 1-bit characters)
- **Alternating**: [1,0,1,0] â†’ return false

## ðŸ›  Variations
1. **Backward Approach**:
```java
public boolean isOneBitCharacter(int[] bits) {
    int i = bits.length - 2;
    // Count consecutive 1's before last 0
    while (i >= 0 && bits[i] == 1) {
        i--;
    }
    // Even number of consecutive 1's means last is 1-bit
    return (bits.length - 2 - i) % 2 == 0;
}
```

2. **Stack Simulation**:
```java
public boolean isOneBitCharacter(int[] bits) {
    int i = 0;
    while (i < bits.length - 1) {
        if (bits[i] == 0) {
            i++; // 1-bit character
        } else {
            i += 2; // 2-bit character
        }
    }
    return i == bits.length - 1;
}
```

3. **Recursive Approach**:
```java
public boolean isOneBitCharacter(int[] bits) {
    return decode(bits, 0);
}

private boolean decode(int[] bits, int start) {
    if (start == bits.length - 1) return true;
    if (start >= bits.length) return false;
    
    if (bits[start] == 0) {
        return decode(bits, start + 1);
    } else {
        return decode(bits, start + 2);
    }
}
```

## Mathematical Insight
The solution leverages:
- **Prefix-free Code Property**: No code is prefix of another
- **Greedy Decodability**: Can always decode left-to-right unambiguously
- **Jump Consistency**: Movement depends only on current bit value
- **Termination Condition**: Final position reveals last character type

**Key Observation:**
The problem reduces to: "After greedily decoding everything before the last character, do we have exactly one bit left?"

The elegant solution `i += bits[i] + 1` perfectly captures the decoding rules in a single mathematical expression, making the algorithm both efficient and easy to understand.