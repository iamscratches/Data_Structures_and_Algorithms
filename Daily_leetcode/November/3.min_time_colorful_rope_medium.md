# ðŸŽ¨ Minimum Time to Make Rope Colorful - Greedy Balloon Removal Approach

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/minimum-time-to-make-rope-colorful/description/?envType=daily-question&envId=2025-11-03)

Given:
- A string `colors` where each character represents a balloon color
- An array `neededTime` where `neededTime[i]` is time to remove balloon `i`
- No two adjacent balloons should have the same color

Find:
- The **minimum time** to remove balloons so no two adjacent balloons have same color

**Removal Rules:**
- You can remove balloons in any order
- When consecutive balloons have same color, remove all but one
- Keep the balloon with **maximum removal time** in each consecutive group
- Remove all others in the group

**Constraints:**
- `n == colors.length == neededTime.length`
- `1 <= n <= 10^5`
- `1 <= neededTime[i] <= 10^4`
- `colors` contains only lowercase English letters

**Example:**
```text
Input: colors = "abaac", neededTime = [1,2,3,4,5]
Output: 3

Explanation:
Balloons: a=1, b=2, a=3, a=4, c=5
Remove the two 'a' balloons with times 1 and 3 (keep the one with time 4)
Total time = 1 + 3 = 3

Input: colors = "abc", neededTime = [1,2,3]
Output: 0 (no adjacent duplicates)
```

## ðŸ§  Intuition
The solution uses:
1. **Consecutive Group Processing**: Handle groups of same-colored balloons together
2. **Greedy Selection**: Keep balloon with maximum removal time in each group
3. **Running Sum**: Accumulate removal costs for non-maximum balloons
4. **Single Pass**: Process array while tracking current group

Key Insights:
- For consecutive same-colored balloons, keep only the most expensive one
- Remove all others in the group
- Process groups as you encounter them
- Track both current group max and running sum

## âš™ï¸ Approach
1. **Initialize**: Track previous color, previous max time, total cost
2. **Process Each Balloon**:
   - If same color as previous:
     - Add smaller time to total (remove cheaper balloon)
     - Update max time to current group maximum
   - If different color:
     - Start new group with current balloon
3. **Return**: Total accumulated removal cost

## âœ… Optimized Solution
```java
class Solution {
    public int minCost(String colors, int[] neededTime) {
        int totalTime = 0;           // Total removal time
        char prevColor = 'A';        // Previous balloon color (initialize with dummy)
        int prevMaxTime = Integer.MAX_VALUE; // Max time in current consecutive group
        
        for (int i = 0; i < colors.length(); i++) {
            char currentColor = colors.charAt(i);
            int currentTime = neededTime[i];
            
            if (i != 0 && prevColor == currentColor) {
                // Same color group - remove the cheaper balloon
                totalTime += Math.min(prevMaxTime, currentTime);
                // Update to keep the more expensive balloon
                prevMaxTime = Math.max(prevMaxTime, currentTime);
            } else {
                // New color group - start fresh
                prevMaxTime = currentTime;
            }
            
            prevColor = currentColor;
        }
        
        return totalTime;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through the array |
| **Space**       | O(1)       | Only a few variables |

## ðŸ“Š Example Walkthrough
**Input:** colors = "abaac", neededTime = [1,2,3,4,5]

**Step-by-step:**
1. **i=0**: color='a', time=1
   - First balloon: prevMaxTime=1, prevColor='a', totalTime=0

2. **i=1**: color='b', time=2
   - Different color: prevMaxTime=2, prevColor='b', totalTime=0

3. **i=2**: color='a', time=3
   - Different color: prevMaxTime=3, prevColor='a', totalTime=0

4. **i=3**: color='a', time=4
   - Same color group: 
     - Add min(3,4)=3 to totalTime â†’ totalTime=3
     - Update prevMaxTime = max(3,4)=4

5. **i=4**: color='c', time=5
   - Different color: prevMaxTime=5, prevColor='c', totalTime=3

**Output:** 3 âœ“

**Another Example:** colors = "aabaa", neededTime = [1,2,3,4,5]
- Group 1: "aa" â†’ keep max(1,2)=2, remove min=1 â†’ cost=1
- Group 2: "b" â†’ single balloon, no cost
- Group 3: "aa" â†’ keep max(4,5)=5, remove min=4 â†’ cost=4
- Total cost = 1 + 4 = 5

## ðŸ’¡ Key Features
- **Greedy Optimal**: Always keep the most expensive balloon in each group
- **Single Pass**: Processes array in linear time
- **Group Tracking**: Handles consecutive groups seamlessly
- **Memory Efficient**: Constant extra space

## ðŸš€ When to Use
- Consecutive group processing problems
- When you need to remove duplicates with cost constraints
- Greedy selection problems
- String processing with adjacent constraints

## âš ï¸ Edge Cases
- **All same color**: Remove all but the most expensive
- **No duplicates**: Zero cost
- **Single balloon**: Zero cost
- **Large groups**: Handle multiple consecutive duplicates
- **All different colors**: Zero cost

## ðŸ›  Variations
1. **Two Pointer Approach**:
```java
public int minCost(String colors, int[] neededTime) {
    int totalTime = 0;
    int i = 0, n = colors.length();
    
    while (i < n) {
        int j = i;
        int maxTime = neededTime[i];
        int sumTime = neededTime[i];
        
        // Find consecutive same-colored balloons
        while (j + 1 < n && colors.charAt(j) == colors.charAt(j + 1)) {
            j++;
            maxTime = Math.max(maxTime, neededTime[j]);
            sumTime += neededTime[j];
        }
        
        // Remove all but the most expensive
        if (j > i) {
            totalTime += sumTime - maxTime;
        }
        i = j + 1;
    }
    return totalTime;
}
```

2. **Stack Approach**:
```java
// Use stack to track consecutive groups
```

3. **Dynamic Programming**:
```java
// DP with state tracking
```

## Alternative Implementation (Group Sum Approach)
```java
class Solution {
    public int minCost(String colors, int[] neededTime) {
        int totalCost = 0;
        int currentMax = 0;
        
        for (int i = 0; i < colors.length(); i++) {
            // If same as previous, we're in a consecutive group
            if (i > 0 && colors.charAt(i) == colors.charAt(i - 1)) {
                totalCost += Math.min(currentMax, neededTime[i]);
                currentMax = Math.max(currentMax, neededTime[i]);
            } else {
                // New group starts
                currentMax = neededTime[i];
            }
        }
        
        return totalCost;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Greedy Choice Property**: Optimal to always keep the most expensive balloon
- **Local Optimization**: Each consecutive group can be handled independently
- **Running Maximum**: Track the maximum cost in current group
- **Incremental Cost**: Add costs as we process the array

**Key Formula:**
For a consecutive group with balloons having costs `[c1, c2, ..., ck]`:
```
Removal cost = (sum of all costs) - (maximum cost)
```

The algorithm efficiently implements this by processing the array in a single pass, maintaining the current group's maximum cost, and accumulating the removal costs of all but the most expensive balloon in each consecutive group of same-colored balloons.