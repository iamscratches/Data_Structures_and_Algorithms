# ðŸ§® Increment Submatrices by One - Difference Array Technique

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/increment-submatrices-by-one/description/?envType=daily-question&envId=2025-11-14)

Given:
- An integer `n` representing an nÃ—n matrix (initially all zeros)
- A 2D array `queries` where each query is `[row1, col1, row2, col2]`

Find:
- The final matrix after processing all queries

**Operation for Each Query:**
- Increment all elements in the submatrix from `(row1, col1)` to `(row2, col2)` by 1
- The submatrix includes all cells where:
  - `row1 <= row <= row2`
  - `col1 <= col <= col2`

**Constraints:**
- `1 <= n <= 500`
- `1 <= queries.length <= 10^4`
- `0 <= row1 <= row2 < n`
- `0 <= col1 <= col2 < n`

**Example:**
```text
Input: n = 3, queries = [[1,1,2,2],[0,0,1,1]]
Output: [[1,1,0],[1,2,1],[0,1,1]]

Explanation:
After query 1 [1,1,2,2]:
[0,0,0]    [0,0,0]
[0,1,1] â†’  [0,1,1]
[0,1,1]    [0,1,1]

After query 2 [0,0,1,1]:
[1,1,0]
[1,2,1]
[0,1,1]
```

## ðŸ§  Intuition
The solution uses:
1. **Difference Array Technique**: Efficient range updates in O(1) per row
2. **Row-wise Processing**: Handle each row independently
3. **Prefix Sum Reconstruction**: Convert difference array back to final values
4. **Two-pass Algorithm**: First mark changes, then compute final values

Key Insights:
- Instead of updating every cell (O(nÂ²) per query), use difference arrays
- For each row in the submatrix, mark start with +1 and end+1 with -1
- After all queries, reconstruct using prefix sums
- Reduces complexity from O(q Ã— nÂ²) to O(q Ã— n + nÂ²)

## âš™ï¸ Approach
1. **Initialize**: Create nÃ—n result matrix
2. **Process Each Query**:
   - For each row from row1 to row2:
     - Mark `res[row][col1] += 1` (increment start)
     - Mark `res[row][col2+1] -= 1` (decrement after end, if within bounds)
3. **Reconstruct Matrix**:
   - For each row, compute prefix sums
   - Current value = previous prefix sum + current difference value

## âœ… Optimized Solution
```java
class Solution {
    public int[][] rangeAddQueries(int n, int[][] queries) {
        int[][] result = new int[n][n];
        
        // Step 1: Process all queries using difference array technique
        for (int[] query : queries) {
            int row1 = query[0];
            int col1 = query[1];
            int row2 = query[2];
            int col2 = query[3];
            
            // For each affected row, mark the range [col1, col2]
            for (int row = row1; row <= row2; row++) {
                // Mark the start of the range
                result[row][col1]++;
                
                // Mark the end of the range (if within bounds)
                if (col2 + 1 < n) {
                    result[row][col2 + 1]--;
                }
            }
        }
        
        // Step 2: Reconstruct the matrix using prefix sums
        for (int row = 0; row < n; row++) {
            int prefixSum = 0;
            for (int col = 0; col < n; col++) {
                // Current value = previous prefix sum + current difference
                prefixSum += result[row][col];
                result[row][col] = prefixSum;
            }
        }
        
        return result;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(q Ã— n + nÂ²) | q queries Ã— n rows + nÂ² reconstruction |
| **Space**       | O(nÂ²)      | Result matrix storage |

Where:
- `q` = number of queries
- `n` = matrix dimension

## ðŸ’¡ Key Features
- **Difference Array**: O(1) range updates instead of O(n)
- **Efficient Reconstruction**: Single pass per row to compute prefix sums
- **Space Optimal**: Uses the same matrix for differences and result
- **Scalable**: Handles large n and many queries efficiently

## ðŸš€ When to Use
- Range update problems on arrays/matrices
- When you have multiple range increment operations
- Problems where brute force would be too slow
- Cumulative frequency counting

## âš ï¸ Edge Cases
- **Single cell queries**: row1=row2, col1=col2
- **Full matrix queries**: [0,0,n-1,n-1]
- **Empty queries**: Shouldn't occur per constraints
- **Boundary handling**: Careful with col2+1 going out of bounds

## ðŸ›  Variations
1. **2D Difference Array**:
```java
// Use proper 2D difference array for O(1) per query
public int[][] rangeAddQueries(int n, int[][] queries) {
    int[][] diff = new int[n+1][n+1];
    
    for (int[] q : queries) {
        int r1=q[0], c1=q[1], r2=q[2], c2=q[3];
        diff[r1][c1]++;
        diff[r1][c2+1]--;
        diff[r2+1][c1]--;
        diff[r2+1][c2+1]++;
    }
    
    int[][] res = new int[n][n];
    for (int i=0; i<n; i++) {
        for (int j=0; j<n; j++) {
            res[i][j] = diff[i][j];
            if (i>0) res[i][j] += res[i-1][j];
            if (j>0) res[i][j] += res[i][j-1];
            if (i>0 && j>0) res[i][j] -= res[i-1][j-1];
        }
    }
    return res;
}
```

2. **Brute Force**:
```java
// Simple but inefficient O(q Ã— nÂ²) approach
```

3. **Segment Trees**:
```java
// For dynamic queries with point updates
```

## Mathematical Insight
The solution leverages:
- **Linearity of Addition**: Range increments are additive
- **Difference Calculus**: Derivative-like approach for efficient updates
- **Prefix Sum Inversion**: Reconstruct original from differences
- **Spatial Decomposition**: Break 2D problem into 1D row problems

**Key Formula:**
For range [col1, col2] in a row:
- Set `diff[col1] += 1`
- Set `diff[col2+1] -= 1` (if within bounds)
Then reconstruct: `arr[col] = Î£ diff[0..col]`

The algorithm efficiently solves the problem by applying the difference array technique row-wise, reducing what would be an O(q Ã— nÂ²) brute force solution to an optimal O(q Ã— n + nÂ²) solution that scales to the upper constraint limits.