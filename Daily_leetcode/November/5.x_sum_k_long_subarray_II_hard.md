# ðŸ”¢ Find X-Sum of All K-Long Subarrays II - Two TreeSet Optimization

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-ii/description/?envType=daily-question&envId=2025-11-05)

Given:
- An array `nums`
- Integers `k` (subarray length) and `x`
- For each subarray of length `k`, find the **x-sum**

**X-Sum Definition:**
- Sort numbers in subarray by frequency (descending)
- If same frequency, sort by value (descending)
- Take top `x` distinct numbers
- For each distinct number, multiply by its frequency
- Sum these products

Find:
- Array containing x-sum for each k-length subarray

**Key Difference from Version I:**
- Larger constraints requiring more efficient solution
- Uses TreeSet for O(log n) operations instead of O(k log k)

**Constraints:**
- `1 <= k <= nums.length <= 10^5`
- `1 <= x <= 10^5`
- `1 <= nums[i] <= 10^5`

## ðŸ§  Intuition
The solution uses:
1. **Two TreeSet Structure**: Maintain `top` (current top x) and `rest` (remaining elements)
2. **Sliding Window**: Efficiently update as window moves
3. **Custom Entry Objects**: Store (frequency, value) pairs for sorting
4. **Lazy Updates**: Only update affected entries when frequencies change

Key Insights:
- Maintain exactly `x` elements in `top` set at all times
- `rest` set contains all other elements sorted for quick promotion
- Update only the specific entry when frequency changes
- Use TreeSet for O(log n) insert/remove operations

## âš™ï¸ Approach
1. **Data Structures**:
   - `freq`: HashMap tracking current frequencies
   - `top`: TreeSet with top x elements (by frequency then value)
   - `rest`: TreeSet with remaining elements
   - `currSum`: Running sum of top x elements

2. **Operations**:
   - `insertVal`: Add/update value in structure
   - `eraseVal`: Remove/decrease value from structure
   - Maintain invariant: `top.size() == min(x, distinct_count)`

3. **Sliding Window**:
   - Initialize with first k elements
   - For each slide: remove left, add right, update sum

## âœ… Optimized Solution
```java
import java.util.*;

class Solution {
    // Custom Entry class to store (frequency, value) pairs
    private static final class Entry {
        final int f;  // frequency
        final int v;  // value
        
        Entry(int f, int v) { 
            this.f = f; 
            this.v = v; 
        }

        @Override 
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Entry)) return false;
            Entry e = (Entry) o;
            return f == e.f && v == e.v;
        }
        
        @Override 
        public int hashCode() { 
            return Objects.hash(f, v); 
        }
    }

    // Comparator: first by frequency (desc), then by value (desc)
    private final Comparator<Entry> byFreqDescValDesc = (a, b) -> {
        if (a.f != b.f) return Integer.compare(b.f, a.f); // Higher frequency first
        return Integer.compare(b.v, a.v); // Higher value first if same frequency
    };

    private Map<Integer, Integer> freq;      // value -> frequency
    private TreeSet<Entry> top, rest;        // top x elements and remaining elements
    private long currSum;                    // current x-sum

    // Insert or update a value in the structure
    private void insertVal(int v, int x) {
        int currentFreq = freq.getOrDefault(v, 0);
        
        // Remove old entry if it exists
        if (currentFreq > 0) {
            Entry oldEntry = new Entry(currentFreq, v);
            if (top.remove(oldEntry)) {
                currSum -= (long) currentFreq * v;
            } else {
                rest.remove(oldEntry);
            }
        }
        
        // Insert new entry with updated frequency
        currentFreq += 1;
        freq.put(v, currentFreq);
        Entry newEntry = new Entry(currentFreq, v);
        
        top.add(newEntry);
        currSum += (long) currentFreq * v;
        
        // If top has more than x elements, move smallest to rest
        if (top.size() > x) {
            Entry smallestTop = top.last(); // Last in sorted order = smallest
            currSum -= (long) smallestTop.f * smallestTop.v;
            rest.add(smallestTop);
            top.remove(smallestTop);
        }
    }

    // Remove or decrease a value from the structure
    private void eraseVal(int v, int x) {
        Integer currentFreq = freq.get(v);
        if (currentFreq == null || currentFreq == 0) return;
        
        Entry currentEntry = new Entry(currentFreq, v);
        
        // Remove from appropriate set
        if (top.remove(currentEntry)) {
            currSum -= (long) currentFreq * v;
        } else {
            rest.remove(currentEntry);
        }
        
        // Update frequency
        currentFreq -= 1;
        if (currentFreq == 0) {
            freq.remove(v);
        } else {
            freq.put(v, currentFreq);
            Entry updatedEntry = new Entry(currentFreq, v);
            rest.add(updatedEntry);
        }
        
        // If top has less than x elements, promote from rest
        if (top.size() < x && !rest.isEmpty()) {
            Entry bestRest = rest.first(); // First in sorted order = largest
            rest.remove(bestRest);
            top.add(bestRest);
            currSum += (long) bestRest.f * bestRest.v;
        }
    }

    public long[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int resultSize = n - k + 1;
        long[] result = new long[resultSize];
        
        // Initialize data structures
        freq = new HashMap<>();
        top = new TreeSet<>(byFreqDescValDesc);
        rest = new TreeSet<>(byFreqDescValDesc);
        currSum = 0L;
        
        // Build initial window
        for (int i = 0; i < k; i++) {
            insertVal(nums[i], x);
        }
        result[0] = currSum;
        
        // Slide window and update
        for (int left = 1, right = k; right < n; left++, right++) {
            eraseVal(nums[left - 1], x);  // Remove left element
            insertVal(nums[right], x);    // Add right element
            result[left] = currSum;       // Store current sum
        }
        
        return result;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n log n) | n operations Ã— O(log n) TreeSet operations |
| **Space**       | O(n)       | Storage for frequency map and TreeSets |

## ðŸ“Š Example Walkthrough
**Input:** nums = [1,1,2,2,3], k = 3, x = 2

**Initial Window [1,1,2]:**
- Frequencies: {1:2, 2:1}
- Top: [1(f=2), 2(f=1)] â†’ Sum = 1Ã—2 + 2Ã—1 = 4

**Slide to [1,2,2]:**
- Remove nums[0]=1: {1:1, 2:2}
- Top: [2(f=2), 1(f=1)] â†’ Sum = 2Ã—2 + 1Ã—1 = 5

**Slide to [2,2,3]:**
- Remove nums[1]=1: {2:2, 3:1}
- Top: [2(f=2), 3(f=1)] â†’ Sum = 2Ã—2 + 3Ã—1 = 7

**Output:** [4,5,7] âœ“

## ðŸ’¡ Key Features
- **Two-Set Optimization**: Maintains top x efficiently
- **O(log n) Operations**: TreeSet provides fast updates
- **Lazy Updates**: Only modify affected entries
- **Sliding Window**: Constant time per window after setup

## ðŸš€ When to Use
- Large constraint sliding window problems
- When maintaining top-k elements efficiently
- Problems requiring frequent updates to sorted collections
- Real-time statistics on data streams

## âš ï¸ Edge Cases
- **x = 0**: Empty top set, sum = 0
- **x > distinct numbers**: Top contains all distinct numbers
- **All same numbers**: Single entry in top
- **Large values**: Use long for sum to prevent overflow

## ðŸ›  Variations
1. **Priority Queue Only**:
```java
// Simpler but O(k log k) per window
```

2. **Bucket Sort**:
```java
// For bounded values, use frequency buckets
```

3. **Fenwick Tree**:
```java
// For range queries on frequencies
```

## Mathematical Insight
The solution leverages:
- **Invariant Maintenance**: Always keep exactly min(x, distinct) in top set
- **Sorted Collection Properties**: TreeSet provides ordering and fast access
- **Sliding Window Amortization**: Each element processed twice (insert+remove)
- **Entry-based Updates**: Track (frequency, value) pairs instead of recomputing

**Key Invariants:**
1. `top` contains exactly min(x, total_distinct) elements
2. `top` contains the largest elements by (frequency, value) ordering
3. `rest` contains remaining elements sorted for quick promotion
4. `currSum` always equals sum of (f Ã— v) for entries in `top`

This optimized approach handles the large constraints efficiently by avoiding the O(k log k) sorting per window and instead maintaining the top x elements in sorted order with O(log n) updates per operation.