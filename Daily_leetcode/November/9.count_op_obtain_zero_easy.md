# ðŸ”¢ Count Operations to Obtain Zero - Modified Euclidean Algorithm

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/count-operations-to-obtain-zero/description/?envType=daily-question&envId=2025-11-09)

Given:
- Two non-negative integers `num1` and `num2`
- In one operation:
  - If `num1 >= num2`, set `num1 = num1 - num2`
  - If `num2 >= num1`, set `num2 = num2 - num1`

Find:
- The **number of operations** needed to make at least one of the numbers zero

**Operation Rules:**
- In each operation, subtract the smaller number from the larger number
- If both numbers are equal, subtract either from the other
- Continue until at least one number becomes 0

**Constraints:**
- `0 <= num1, num2 <= 10^5`

**Example:**
```text
Input: num1 = 2, num2 = 3
Output: 3

Explanation:
Operation 1: num1=2, num2=3 â†’ num2 > num1 â†’ num2 = 3-2=1
Operation 2: num1=2, num2=1 â†’ num1 > num2 â†’ num1 = 2-1=1  
Operation 3: num1=1, num2=1 â†’ equal â†’ num1 = 1-1=0
Now num1=0, stop. Total operations: 3

Input: num1 = 10, num2 = 10
Output: 1
Operation: 10-10=0 (either way)
```

## ðŸ§  Intuition
The solution uses:
1. **Modified Euclidean Algorithm**: Similar to GCD calculation but counting operations
2. **Iterative Subtraction**: Repeatedly subtract smaller from larger
3. **Termination Condition**: Stop when either number becomes zero
4. **Operation Counting**: Increment counter for each operation

Key Insights:
- This is essentially the Euclidean algorithm for GCD
- Each operation reduces the larger number
- The process terminates when we reach GCD (but we continue to zero)
- Number of operations = steps in Euclidean algorithm to reach zero

## âš™ï¸ Approach
1. **Initialize**: Start with count = 0
2. **Iterate While Both Non-Zero**:
   - If num1 â‰¥ num2: subtract num2 from num1
   - If num2 > num1: subtract num1 from num2  
   - Increment operation count
3. **Terminate**: When either number becomes zero
4. **Return**: Total operation count

## âœ… Optimized Solution
```java
class Solution {
    public int countOperations(int num1, int num2) {
        int operations = 0;
        
        // Continue until one number becomes zero
        while (num1 != 0 && num2 != 0) {
            if (num1 >= num2) {
                num1 = num1 - num2;
            } else {
                num2 = num2 - num1;
            }
            operations++;
        }
        
        return operations;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(log(min(num1, num2))) | Euclidean algorithm complexity |
| **Space**       | O(1)       | Only a few variables |

**Note:** The time complexity is logarithmic due to the Euclidean algorithm property

## ðŸ“Š Example Walkthrough
**Input:** num1 = 2, num2 = 3

**Step-by-step:**
1. **Operation 1**: num1=2, num2=3 â†’ num2 > num1 â†’ num2 = 3-2=1, count=1
2. **Operation 2**: num1=2, num2=1 â†’ num1 > num2 â†’ num1 = 2-1=1, count=2  
3. **Operation 3**: num1=1, num2=1 â†’ equal â†’ num1 = 1-1=0, count=3
4. **Terminate**: num1=0

**Output:** 3 âœ“

**Another Example:** num1 = 10, num2 = 10
- Operation 1: num1=10, num2=10 â†’ equal â†’ num1=0, count=1
- Output: 1 âœ“

**Example:** num1 = 0, num2 = 5
- Already num1=0 â†’ no operations
- Output: 0 âœ“

## ðŸ’¡ Key Features
- **Euclidean Algorithm**: Efficient subtraction-based approach
- **Simple Logic**: Easy to understand and implement
- **Optimal Solution**: Minimum possible operations
- **Early Termination**: Stops as soon as possible

## ðŸš€ When to Use
- Euclidean algorithm variations
- Problems involving repeated subtraction
- GCD-related calculations
- Simulation-based counting problems

## âš ï¸ Edge Cases
- **Both zero**: Return 0 (already done)
- **One zero**: Return 0 (already have a zero)
- **Large numbers**: Efficient due to logarithmic complexity
- **Equal numbers**: Single operation to make one zero

## ðŸ›  Variations
1. **Recursive Approach**:
```java
public int countOperations(int num1, int num2) {
    if (num1 == 0 || num2 == 0) return 0;
    return 1 + countOperations(Math.min(num1, num2), Math.abs(num1 - num2));
}
```

2. **Mathematical Optimization**:
```java
public int countOperations(int num1, int num2) {
    int operations = 0;
    while (num1 != 0 && num2 != 0) {
        if (num1 >= num2) {
            operations += num1 / num2;
            num1 %= num2;
        } else {
            operations += num2 / num1;
            num2 %= num1;
        }
    }
    return operations;
}
```

3. **GCD-based Approach**:
```java
public int countOperations(int num1, int num2) {
    if (num1 == 0 || num2 == 0) return 0;
    int gcd = gcd(num1, num2);
    return (num1 + num2) / gcd - 1; // Alternative formula
}

private int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```

## Alternative Implementation (With Division Optimization)
```java
class Solution {
    public int countOperations(int num1, int num2) {
        int operations = 0;
        
        while (num1 != 0 && num2 != 0) {
            if (num1 >= num2) {
                // Instead of subtracting repeatedly, use division
                operations += num1 / num2;
                num1 %= num2;
            } else {
                operations += num2 / num1;
                num2 %= num1;
            }
        }
        
        return operations;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Euclidean Algorithm**: Foundation for GCD calculation
- **Operation Counting**: Each subtraction step counts as one operation
- **Termination Guarantee**: Numbers decrease monotonically
- **Worst-case**: Fibonacci numbers (slowest convergence)

**Key Properties:**
- This is essentially the number of steps in the Euclidean algorithm
- For Fibonacci pairs (consecutive Fibonacci numbers), this gives the maximum number of operations
- The process always terminates due to monotonic decrease

**Complexity Analysis:**
- Worst-case: O(log Ï†(min(a,b))) where Ï† is the golden ratio
- This occurs with consecutive Fibonacci numbers
- In practice, very efficient even for large numbers

The algorithm provides an elegant and efficient solution by directly implementing the operation rules while leveraging the mathematical properties of the Euclidean algorithm, ensuring optimal performance even for the upper constraint limits.