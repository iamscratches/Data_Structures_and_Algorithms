# ðŸ”¢ Find Minimum Operations to Make All Elements Divisible by Three - Remainder Analysis

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/find-minimum-operations-to-make-all-elements-divisible-by-three/description/?envType=daily-question&envId=2025-11-22)

Given:
- An array `nums` of integers
- In one operation, you can **increment or decrement** any element by 1

Find:
- The **minimum number of operations** to make all elements divisible by 3

**Operation Rules:**
- You can add 1 or subtract 1 from any element
- Each change counts as one operation
- Goal: Make every number divisible by 3 (remainder 0 when divided by 3)

**Constraints:**
- `1 <= nums.length <= 100`
- `1 <= nums[i] <= 1000`

**Example:**
```text
Input: nums = [1,2,3,4]
Output: 3

Explanation:
- 1 â†’ 0 (1 operation: -1) or 1 â†’ 3 (2 operations: +2) â†’ choose -1
- 2 â†’ 3 (1 operation: +1) or 2 â†’ 0 (2 operations: -2) â†’ choose +1  
- 3 â†’ 3 (0 operations) âœ“
- 4 â†’ 3 (1 operation: -1) or 4 â†’ 6 (2 operations: +2) â†’ choose -1
Total: 1 + 1 + 0 + 1 = 3 operations

Input: nums = [3,6,9]
Output: 0 (already all divisible by 3)
```

## ðŸ§  Intuition
The solution uses:
1. **Remainder Analysis**: Focus on each number's remainder when divided by 3
2. **Optimal Adjustment**: For each remainder, find cheapest way to reach multiple of 3
3. **Symmetric Choices**: Can add or subtract to reach nearest multiple of 3
4. **Minimum Distance**: Operations needed = min(distance to next lower or higher multiple of 3)

Key Insights:
- Numbers with remainder 0: already divisible â†’ 0 operations
- Numbers with remainder 1: can subtract 1 or add 2 â†’ min(1, 2) = 1 operation
- Numbers with remainder 2: can add 1 or subtract 2 â†’ min(1, 2) = 1 operation
- General formula: `min(remainder, 3 - remainder)`

## âš™ï¸ Approach
1. **Process Each Number**:
   - Calculate remainder when divided by 3: `r = num % 3`
   - Operations needed = `min(r, 3 - r)`
   - Add to total operations
2. **Return**: Sum of operations for all numbers

## âœ… Optimized Solution
```java
class Solution {
    public int minimumOperations(int[] nums) {
        int totalOperations = 0;
        
        for (int num : nums) {
            int remainder = num % 3;
            // Minimum operations to make divisible by 3
            totalOperations += Math.min(remainder, 3 - remainder);
        }
        
        return totalOperations;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through the array |
| **Space**       | O(1)       | Only a few variables |

## ðŸ“Š Example Walkthrough
**Input:** nums = [1,2,3,4]

**Step-by-step:**
1. **num=1**: remainder=1 â†’ min(1, 2)=1
2. **num=2**: remainder=2 â†’ min(2, 1)=1  
3. **num=3**: remainder=0 â†’ min(0, 3)=0
4. **num=4**: remainder=1 â†’ min(1, 2)=1

**Total:** 1+1+0+1=3 âœ“

**Another Example:** nums = [5,8,11]
- 5%3=2 â†’ min(2,1)=1
- 8%3=2 â†’ min(2,1)=1  
- 11%3=2 â†’ min(2,1)=1
**Total:** 3

**Verification:**
- 5â†’6 (+1) or 5â†’3 (-2) â†’ choose +1
- 8â†’9 (+1) or 8â†’6 (-2) â†’ choose +1
- 11â†’12 (+1) or 11â†’9 (-2) â†’ choose +1
Total: 3 âœ“

## ðŸ’¡ How It Works
The mathematical insight:
- Any number can be written as `3k + r` where `r = 0, 1, or 2`
- To make it divisible by 3:
  - If `r=0`: already divisible â†’ 0 operations
  - If `r=1`: subtract 1 (cost 1) or add 2 (cost 2) â†’ choose subtraction
  - If `r=2`: add 1 (cost 1) or subtract 2 (cost 2) â†’ choose addition

This gives the formula: `min(r, 3-r)`

## ðŸ’¡ Key Features
- **Mathematical Elegance**: Simple formula based on remainders
- **Efficient**: Linear time complexity
- **Optimal**: Always finds minimum operations for each number
- **Simple Logic**: Easy to understand and implement

## ðŸš€ When to Use
- Problems involving divisibility constraints
- When operations involve small increments/decrements
- Remainder-based optimization problems
- Distance to nearest multiple calculations

## âš ï¸ Edge Cases
- **All divisible by 3**: Return 0
- **Single element**: Simple case
- **Large numbers**: Formula works regardless of magnitude
- **Negative numbers**: Not in constraints, but `%` behaves differently

## ðŸ›  Variations
1. **Explicit Case Handling**:
```java
public int minimumOperations(int[] nums) {
    int operations = 0;
    for (int num : nums) {
        int remainder = num % 3;
        if (remainder == 1) {
            operations += 1; // Subtract 1
        } else if (remainder == 2) {
            operations += 1; // Add 1
        }
        // remainder == 0: no operations needed
    }
    return operations;
}
```

2. **Ternary Operator**:
```java
public int minimumOperations(int[] nums) {
    int operations = 0;
    for (int num : nums) {
        int r = num % 3;
        operations += r == 0 ? 0 : 1;
    }
    return operations;
}
```

3. **Stream API**:
```java
public int minimumOperations(int[] nums) {
    return Arrays.stream(nums)
                .map(num -> Math.min(num % 3, 3 - num % 3))
                .sum();
}
```

## Alternative Implementation (With Explanation)
```java
class Solution {
    public int minimumOperations(int[] nums) {
        int totalOps = 0;
        
        for (int num : nums) {
            // Get distance to nearest multiple of 3
            int remainder = num % 3;
            
            if (remainder == 0) {
                // Already divisible by 3
                continue;
            } else if (remainder == 1) {
                // Either go down to previous multiple (cost 1)
                // Or go up to next multiple (cost 2)
                totalOps += 1;
            } else { // remainder == 2
                // Either go up to next multiple (cost 1)
                // Or go down to previous multiple (cost 2)
                totalOps += 1;
            }
        }
        
        return totalOps;
    }
}
```

## Mathematical Insight
The solution leverages:
- **Modular Arithmetic**: Properties of division remainders
- **Symmetric Distance**: Distance to nearest multiple is symmetric around multiples of 3
- **Optimal Choice**: Always choose the closer multiple (1 operation vs 2 operations)
- **Additive Property**: Total operations = sum of individual operations

**Key Formula:**
For any integer n:
```
operations(n) = min(n % 3, 3 - n % 3)
```

This works because:
- The distance to the previous multiple of 3 = `n % 3`
- The distance to the next multiple of 3 = `3 - (n % 3)`
- We always take the minimum distance

The algorithm elegantly solves the problem by recognizing that each number can be independently adjusted to the nearest multiple of 3, and the optimal strategy is simply to choose the closer multiple for each number.