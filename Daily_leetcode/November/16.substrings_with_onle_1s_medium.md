# ðŸ”¢ Number of Substrings with Only 1s - Contiguous Ones Counting

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/number-of-substrings-with-only-1s/description/?envType=daily-question&envId=2025-11-16)

Given:
- A binary string `s` containing only '0's and '1's

Find:
- The number of **substrings** that contain only '1's
- Return answer modulo 10^9 + 7

**Substring Definition:**
- A contiguous sequence of characters within the string
- We only count substrings that contain **exclusively '1's** (no '0's allowed)

**Constraints:**
- `1 <= s.length <= 10^5`
- `s[i]` is either '0' or '1'

**Example:**
```text
Input: s = "0110111"
Output: 9

Explanation:
Substrings containing only '1's:
- "1" at index 1
- "1" at index 2
- "11" at indices 1-2
- "1" at index 4  
- "1" at index 5
- "1" at index 6
- "11" at indices 4-5
- "11" at indices 5-6
- "111" at indices 4-6
Total: 9 substrings
```

## ðŸ§  Intuition
The solution uses:
1. **Contiguous Segment Processing**: Count consecutive '1's
2. **Triangular Number Pattern**: For k consecutive '1's, there are kÃ—(k+1)/2 substrings
3. **Running Counter**: Track current streak of '1's
4. **Incremental Addition**: Add streak length at each position
5. **Modulo Arithmetic**: Handle large numbers

Key Insights:
- Each new '1' in a streak creates new substrings ending at that position
- Number of new substrings = current streak length
- Reset counter when encountering '0'
- Total = sum of streak lengths at each position

## âš™ï¸ Approach
1. **Initialize**:
   - `currentStreak` = 0 (consecutive '1's count)
   - `totalSubstrings` = 0 (total valid substrings)
   - `MOD` = 10^9 + 7
2. **Process Each Character**:
   - If character is '1':
     - Increment `currentStreak`
     - Add `currentStreak` to `totalSubstrings`
   - If character is '0':
     - Reset `currentStreak` to 0
3. **Return**: `totalSubstrings % MOD`

## âœ… Optimized Solution
```java
class Solution {
    public int numSub(String s) {
        long currentStreak = 0;           // Current consecutive ones count
        long totalSubstrings = 0;         // Total valid substrings
        final long MOD = 1000000007;      // 10^9 + 7
        
        for (int i = 0; i < s.length(); i++) {
            char currentChar = s.charAt(i);
            
            if (currentChar == '1') {
                // Continue the streak and count new substrings
                currentStreak++;
                totalSubstrings = (totalSubstrings + currentStreak) % MOD;
            } else {
                // Break the streak when we encounter '0'
                currentStreak = 0;
            }
        }
        
        return (int) totalSubstrings;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through the string |
| **Space**       | O(1)       | Only a few variables |

## ðŸ“Š Example Walkthrough
**Input:** s = "0110111"

**Step-by-step processing:**
1. **i=0**: '0' â†’ currentStreak=0, total=0
2. **i=1**: '1' â†’ currentStreak=1, total=0+1=1
3. **i=2**: '1' â†’ currentStreak=2, total=1+2=3
4. **i=3**: '0' â†’ currentStreak=0, total=3
5. **i=4**: '1' â†’ currentStreak=1, total=3+1=4
6. **i=5**: '1' â†’ currentStreak=2, total=4+2=6
7. **i=6**: '1' â†’ currentStreak=3, total=6+3=9

**Output:** 9 âœ“

**Mathematical Verification:**
- Segment 1: "11" (indices 1-2) â†’ 2 ones â†’ substrings: 1 + 2 = 3
- Segment 2: "111" (indices 4-6) â†’ 3 ones â†’ substrings: 1 + 2 + 3 = 6
- Total: 3 + 6 = 9 âœ“

## ðŸ’¡ How It Works
The algorithm leverages the mathematical fact that:
- For a contiguous segment of k '1's, the number of substrings is the triangular number T_k = kÃ—(k+1)/2
- Instead of computing this separately for each segment, we compute it incrementally
- At each position with '1', the number of new substrings ending at that position equals the current streak length

**Example:** For "111" (k=3):
- Position 0: streak=1 â†’ +1 substrings ("1")
- Position 1: streak=2 â†’ +2 substrings ("1", "11")  
- Position 2: streak=3 â†’ +3 substrings ("1", "11", "111")
Total: 1 + 2 + 3 = 6 = 3Ã—4/2

## ðŸ’¡ Key Features
- **Efficient**: Linear time complexity
- **Mathematical**: Uses triangular number pattern implicitly
- **Incremental**: Processes string in single pass
- **Space Optimal**: Constant extra space
- **Modulo Safe**: Handles large numbers correctly

## ðŸš€ When to Use
- Counting contiguous segments with specific properties
- Substring counting problems
- When pattern follows triangular number sequence
- Problems with cumulative counting

## âš ï¸ Edge Cases
- **Empty string**: n=0 â†’ return 0
- **All zeros**: "000" â†’ return 0
- **All ones**: "111" â†’ return 6 (3Ã—4/2=6)
- **Single '1'**: "1" â†’ return 1
- **Single '0'**: "0" â†’ return 0
- **Alternating**: "10101" â†’ return 3 (three single '1's)

## ðŸ›  Alternative Implementations
1. **Explicit Segment Processing**:
```java
public int numSub(String s) {
    long total = 0, mod = 1000000007;
    int start = 0;
    
    while (start < s.length()) {
        if (s.charAt(start) == '1') {
            int end = start;
            while (end < s.length() && s.charAt(end) == '1') {
                end++;
            }
            long length = end - start;
            total = (total + length * (length + 1) / 2) % mod;
            start = end;
        } else {
            start++;
        }
    }
    return (int) total;
}
```

2. **Split and Calculate**:
```java
public int numSub(String s) {
    long total = 0, mod = 1000000007;
    String[] segments = s.split("0");
    
    for (String segment : segments) {
        long n = segment.length();
        total = (total + n * (n + 1) / 2) % mod;
    }
    
    return (int) total;
}
```

3. **Two Pointer Approach**:
```java
public int numSub(String s) {
    long total = 0, mod = 1000000007;
    int left = 0;
    
    for (int right = 0; right < s.length(); right++) {
        if (s.charAt(right) == '1') {
            // Number of substrings ending at right = (right - left + 1)
            total = (total + (right - left + 1)) % mod;
        } else {
            left = right + 1;
        }
    }
    
    return (int) total;
}
```

## Mathematical Insight
The solution leverages:
- **Triangular Numbers**: T_n = n(n+1)/2
- **Combinatorial Counting**: Each segment of k '1's has C(k+1, 2) substrings
- **Linearity**: Total = sum over all segments of T_{segment_length}
- **Incremental Computation**: Can compute T_k incrementally as 1 + 2 + ... + k

**Key Formula:**
For a segment of k consecutive '1's:
```
Number of substrings = Î£_{i=1}^k i = k(k+1)/2
```

The algorithm provides an elegant O(n) solution by recognizing that we can compute the triangular numbers incrementally as we process the string, without explicitly identifying segment boundaries or storing intermediate results.