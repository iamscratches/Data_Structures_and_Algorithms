# 4ï¸âƒ£ Power of Four - Bit Manipulation and Division Approach

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/power-of-four/description/?envType=daily-question&envId=2025-08-15)

Given:
- An integer `n`

Determine:
If `n` is a power of four (i.e., can be expressed as 4áµ where k is a non-negative integer)

**Constraints:**
- -2Â³Â¹ â‰¤ n â‰¤ 2Â³Â¹ - 1

**Example:**
```text
Input: n = 16
Output: true
Explanation: 16 = 4Â²

Input: n = 5
Output: false
Explanation: No integer k exists such that 4áµ = 5
```

## ðŸ§  Intuition
The solution uses:
1. **Early Negative Check**: Immediately eliminates negative numbers
2. **Base Case Handling**: Directly checks for n = 1 (4â°)
3. **Division by Four**: Repeatedly divides by 4 using bit shifting
4. **Termination Condition**: Verifies if final result is 1

Key Insights:
- Powers of four have exactly one '1' bit in binary representation at odd positions
- Division by 4 is equivalent to right-shifting by 2 bits
- Negative numbers and zero cannot be powers of four

## âš™ï¸ Approach
1. **Edge Case Handling**:
   - Return false for non-positive numbers
   - Return true for n = 1
2. **Division Loop**:
   - While n > 1, check divisibility by 4
   - If not divisible, return false
   - Right-shift by 2 bits (equivalent to division by 4)
3. **Final Check**:
   - Return true if loop completes (n == 1)

## âœ… Optimized Solution
```java
class Solution {
    public boolean isPowerOfFour(int n) {
        // Handle edge cases
        if (n <= 0) {
            return false;
        }
        if (n == 1) {
            return true;
        }
        
        // Continue dividing by 4 while possible
        while (n > 1) {
            if ((n & 0b11) != 0) {  // Check last 2 bits
                return false;
            }
            n >>= 2;  // Equivalent to n /= 4
        }
        
        return true;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(logâ‚„n)   | Worst case requires logâ‚„n divisions |
| **Space**       | O(1)       | Constant space used |

## ðŸ“Š Example Walkthrough
**Input:** n = 16 (10000 in binary)

**Execution:**
1. n = 16 (positive, not 1)
2. 16 & 0b11 = 0 â†’ divisible by 4
3. n = 16 >> 2 = 4
4. 4 & 0b11 = 0 â†’ divisible by 4
5. n = 4 >> 2 = 1
6. Final check: n == 1 â†’ true

**Input:** n = 20
1. n = 20 (positive, not 1)
2. 20 & 0b11 = 0 â†’ divisible by 4
3. n = 5
4. 5 & 0b11 â‰  0 â†’ return false

## ðŸ’¡ Key Features
- **Efficient Division**: Uses bit shifting for performance
- **Early Termination**: Exits at first non-divisible case
- **Clear Logic**: Directly follows mathematical definition
- **Bitwise Checks**: Efficient divisibility testing

## ðŸš€ When to Use
- Checking power properties
- Number verification problems
- When bit manipulation is applicable
- Problems involving base-4 numbers

## âš ï¸ Edge Cases
- **n = 0**: Returns false
- **n = 1**: Returns true (4â°)
- **Negative numbers**: Immediately returns false
- **Non-power numbers**: Correctly identifies false cases

## ðŸ›  Variations
1. **Mathematical Approach**:
```java
return n > 0 && (Math.log10(n)/Math.log10(4)) % 1 == 0;
```

2. **Bitmask Verification**:
```java
return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;
```

3. **Recursive Version**:
```java
if (n == 1) return true;
if (n % 4 != 0 || n == 0) return false;
return isPowerOfFour(n/4);
```

4. **Precomputed Set**:
```java
// For repeated queries, store powers of four
```

5. **String Conversion**:
```java
// Check base-4 representation (less efficient)
```

## Mathematical Insight
The solution leverages:
- Properties of exponents
- Binary representation patterns
- Bitwise operation efficiency
- Division as inverse of multiplication

## Alternative Implementation (Bitmask)
```java
class Solution {
    public boolean isPowerOfFour(int n) {
        // Check: positive, single bit set, and bit in odd position
        return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;
    }
}
```
Note: This version uses bitmask tricks for O(1) time complexity but may be less intuitive. The iterative solution better demonstrates the mathematical concept.