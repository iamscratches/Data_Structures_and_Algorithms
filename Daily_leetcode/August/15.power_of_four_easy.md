# 4️⃣ Power of Four - Bit Manipulation and Division Approach

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/power-of-four/description/?envType=daily-question&envId=2025-08-15)

Given:
- An integer `n`

Determine:
If `n` is a power of four (i.e., can be expressed as 4ᵏ where k is a non-negative integer)

**Constraints:**
- -2³¹ ≤ n ≤ 2³¹ - 1

**Example:**
```text
Input: n = 16
Output: true
Explanation: 16 = 4²

Input: n = 5
Output: false
Explanation: No integer k exists such that 4ᵏ = 5
```

## 🧠 Intuition
The solution uses:
1. **Early Negative Check**: Immediately eliminates negative numbers
2. **Base Case Handling**: Directly checks for n = 1 (4⁰)
3. **Division by Four**: Repeatedly divides by 4 using bit shifting
4. **Termination Condition**: Verifies if final result is 1

Key Insights:
- Powers of four have exactly one '1' bit in binary representation at odd positions
- Division by 4 is equivalent to right-shifting by 2 bits
- Negative numbers and zero cannot be powers of four

## ⚙️ Approach
1. **Edge Case Handling**:
   - Return false for non-positive numbers
   - Return true for n = 1
2. **Division Loop**:
   - While n > 1, check divisibility by 4
   - If not divisible, return false
   - Right-shift by 2 bits (equivalent to division by 4)
3. **Final Check**:
   - Return true if loop completes (n == 1)

## ✅ Optimized Solution
```java
class Solution {
    public boolean isPowerOfFour(int n) {
        // Handle edge cases
        if (n <= 0) {
            return false;
        }
        if (n == 1) {
            return true;
        }
        
        // Continue dividing by 4 while possible
        while (n > 1) {
            if ((n & 0b11) != 0) {  // Check last 2 bits
                return false;
            }
            n >>= 2;  // Equivalent to n /= 4
        }
        
        return true;
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(log₄n)   | Worst case requires log₄n divisions |
| **Space**       | O(1)       | Constant space used |

## 📊 Example Walkthrough
**Input:** n = 16 (10000 in binary)

**Execution:**
1. n = 16 (positive, not 1)
2. 16 & 0b11 = 0 → divisible by 4
3. n = 16 >> 2 = 4
4. 4 & 0b11 = 0 → divisible by 4
5. n = 4 >> 2 = 1
6. Final check: n == 1 → true

**Input:** n = 20
1. n = 20 (positive, not 1)
2. 20 & 0b11 = 0 → divisible by 4
3. n = 5
4. 5 & 0b11 ≠ 0 → return false

## 💡 Key Features
- **Efficient Division**: Uses bit shifting for performance
- **Early Termination**: Exits at first non-divisible case
- **Clear Logic**: Directly follows mathematical definition
- **Bitwise Checks**: Efficient divisibility testing

## 🚀 When to Use
- Checking power properties
- Number verification problems
- When bit manipulation is applicable
- Problems involving base-4 numbers

## ⚠️ Edge Cases
- **n = 0**: Returns false
- **n = 1**: Returns true (4⁰)
- **Negative numbers**: Immediately returns false
- **Non-power numbers**: Correctly identifies false cases

## 🛠 Variations
1. **Mathematical Approach**:
```java
return n > 0 && (Math.log10(n)/Math.log10(4)) % 1 == 0;
```

2. **Bitmask Verification**:
```java
return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;
```

3. **Recursive Version**:
```java
if (n == 1) return true;
if (n % 4 != 0 || n == 0) return false;
return isPowerOfFour(n/4);
```

4. **Precomputed Set**:
```java
// For repeated queries, store powers of four
```

5. **String Conversion**:
```java
// Check base-4 representation (less efficient)
```

## Mathematical Insight
The solution leverages:
- Properties of exponents
- Binary representation patterns
- Bitwise operation efficiency
- Division as inverse of multiplication

## Alternative Implementation (Bitmask)
```java
class Solution {
    public boolean isPowerOfFour(int n) {
        // Check: positive, single bit set, and bit in odd position
        return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;
    }
}
```
Note: This version uses bitmask tricks for O(1) time complexity but may be less intuitive. The iterative solution better demonstrates the mathematical concept.