# üß∫ Fruit Into Baskets - Sliding Window Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/fruit-into-baskets/description/?envType=daily-question&envId=2025-08-04)

Given:
- An integer array `fruits` where `fruits[i]` is the type of fruit at position `i`

Find:
The maximum number of fruits you can pick following these rules:
1. You have exactly two baskets
2. Each basket can hold only one type of fruit
3. You must pick fruits in order (subarray)

**Constraints:**
- 1 ‚â§ fruits.length ‚â§ 10‚Åµ
- 0 ‚â§ fruits[i] < fruits.length

**Example:**
```text
Input: fruits = [1,2,1]
Output: 3
Explanation: Can pick all fruits since there are only two types
```

## üß† Intuition
The solution uses:
1. **Sliding Window**: Tracks current valid subarray
2. **Fruit Tracking**: Maintains last seen indices of two fruit types
3. **Window Adjustment**: Shrinks window when third fruit type appears
4. **Max Calculation**: Updates maximum count after each window adjustment

Key Insights:
- The problem reduces to finding the longest subarray with at most two distinct values
- Only need to track the last two fruit types encountered
- Window adjustment maintains valid fruit types efficiently

## ‚öôÔ∏è Approach
1. **Initialize Pointers**:
   - Track indices and types of two most recent fruits
2. **Expand Window**:
   - Move right pointer through the array
3. **Handle New Fruit**:
   - Adjust window when third fruit type appears
4. **Update Maximum**:
   - Compare current window size with maximum
5. **Final Check**:
   - Ensure last window is considered

## ‚úÖ Optimized Solution
```java
class Solution {
    public int totalFruit(int[] fruits) {
        int firstType = fruits[0];      // First fruit type in current window
        int firstIndex = 0;            // Start index of first type
        int secondType = -1;           // Second fruit type (initially none)
        int secondIndex = -1;          // Start index of second type
        int maxFruits = 0;             // Maximum fruits collected
        
        for (int i = 0; i < fruits.length; i++) {
            // Current fruit matches one of our two types
            if (fruits[i] == firstType || (secondIndex != -1 && fruits[i] == secondType)) {
                continue;
            }
            
            // Encountering second type for the first time
            if (secondIndex == -1) {
                secondType = fruits[i];
                secondIndex = i;
            } 
            // Encountering a third type - need to adjust window
            else {
                // Update maximum before adjusting window
                maxFruits = Math.max(maxFruits, i - firstIndex);
                
                // Find where the previous streak of same fruit ends
                int prevFruit = fruits[i-1];
                int newStart = i-1;
                while (newStart >= 0 && fruits[newStart] == prevFruit) {
                    newStart--;
                }
                newStart++;
                
                // Update window to exclude the older fruit type
                firstType = prevFruit;
                firstIndex = newStart;
                secondType = fruits[i];
                secondIndex = i;
            }
        }
        
        // Final check for the last window
        return Math.max(maxFruits, fruits.length - firstIndex);
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through the array |
| **Space**       | O(1)       | Constant space for pointers |

## üìä Example Walkthrough
**Input:** fruits = [1,2,1,2,3]

**Execution:**
1. Initialize: firstType=1, firstIndex=0, secondType=-1, max=0
2. i=1 (fruit 2):
   - New second type: secondType=2, secondIndex=1
3. i=2 (fruit 1):
   - Matches existing types
4. i=3 (fruit 2):
   - Matches existing types
5. i=4 (fruit 3):
   - New type found, update max=4-0=4
   - Adjust window: firstType=2, firstIndex=3
   - Set secondType=3, secondIndex=4
6. Final max: max(4, 5-3) = 4

## üí° Key Features
- **Efficient Window Management**: Maintains valid two-type window
- **Linear Time**: Processes array in single pass
- **Minimal Space**: Only tracks necessary indices
- **Edge Case Handling**: Properly handles array endings

## üöÄ When to Use
- Problems requiring longest subarray with ‚â§ k distinct elements
- Sliding window applications
- Array processing with constraints
- Similar to "Longest Substring Without Repeating Characters"

## ‚ö†Ô∏è Edge Cases
- **Single Fruit Type**: Returns array length
- **All Fruits Distinct**: Returns 2
- **Empty Array**: Returns 0 (though constraints prevent this)
- **Two Types Alternating**: Full array length

## üõ† Variations
1. **Hash Map Approach**:
```java
// Use map to track fruit counts
```

2. **Generalized for K Types**:
```java
// Extend solution for k baskets
```

3. **Early Termination**:
```java
// Exit if remaining elements can't beat current max
```

4. **Visualization**:
```java
// Print window boundaries during processing
```

5. **Memory Optimization**:
```java
// Use bit manipulation for small fruit types
```

## Mathematical Insight
The solution leverages:
- Sliding window properties
- Contiguous subarray constraints
- Last occurrence tracking
- Efficient window resizing

## Alternative Implementation (Hash Map)
```java
class Solution {
    public int totalFruit(int[] fruits) {
        Map<Integer, Integer> basket = new HashMap<>();
        int left = 0, max = 0;
        
        for (int right = 0; right < fruits.length; right++) {
            basket.put(fruits[right], basket.getOrDefault(fruits[right], 0) + 1);
            
            while (basket.size() > 2) {
                basket.put(fruits[left], basket.get(fruits[left]) - 1);
                if (basket.get(fruits[left]) == 0) {
                    basket.remove(fruits[left]);
                }
                left++;
            }
            
            max = Math.max(max, right - left + 1);
        }
        
        return max;
    }
}
```
Note: This version uses a hash map for more general cases but has higher constant factors. The original solution is more efficient for exactly two types.