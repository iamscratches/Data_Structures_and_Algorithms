# üî∑ Length of Longest V-Shaped Diagonal Segment - DFS with Memoization

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/length-of-longest-v-shaped-diagonal-segment/description/?envType=daily-question&envId=2025-08-27)

Given:
- A 2D binary grid (values 0 or 1)
- A "V-shaped diagonal segment" consists of alternating 1s and 0s in diagonal directions with exactly one turn

Find:
- The length of the longest V-shaped diagonal segment

**Constraints:**
- m == grid.length
- n == grid[i].length
- 1 ‚â§ m, n ‚â§ 100
- grid[i][j] is either 0 or 1

**Example:**
```text
Input: grid = [[1,0,1],[0,1,0],[1,0,1]]
Output: 5
Explanation: 
Longest V-shaped segment: 1‚Üí0‚Üí1‚Üí0‚Üí1 with one turn
```

## üß† Intuition
The solution uses:
1. **DFS with Memoization**: Explores all possible diagonal paths with memoization
2. **Direction Handling**: 4 diagonal directions (NE, NW, SW, SE)
3. **Turn Management**: Allows exactly one 90-degree turn per segment
4. **Alternating Values**: Requires values to alternate between 1 and 0

Key Insights:
- V-shaped segments have exactly one turn (like a "V")
- Values must alternate (1,0,1,0,... or 0,1,0,1,...)
- Need to explore all starting points and directions
- Memoization prevents recomputation of same states

## ‚öôÔ∏è Approach
1. **Initialization**:
   - 4D memo array [row][col][direction][turn_used]
   - Initialize all memo values to -1 (uncomputed)
2. **DFS Exploration**:
   - For each cell with value 1, try all 4 directions
   - Recursively explore paths with and without turns
3. **State Tracking**:
   - Current position, direction, turn status, next expected value
4. **Result Calculation**: Maximum length found across all starting points

## ‚úÖ Optimized Solution
```java
class Solution {

    private static final int[][] DIRS = {
        { 1, 1 },
        { 1, -1 },
        { -1, -1 },
        { -1, 1 },
    };
    private int[][][][] memo;
    private int[][] grid;
    private int m, n;

    public int lenOfVDiagonal(int[][] grid) {
        this.grid = grid;
        this.m = grid.length;
        this.n = grid[0].length;
        this.memo = new int[m][n][4][2];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < 4; k++) {
                    Arrays.fill(memo[i][j][k], -1);
                }
            }
        }

        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    for (int direction = 0; direction < 4; direction++) {
                        res = Math.max(res, dfs(i, j, direction, true, 2) + 1);
                    }
                }
            }
        }
        return res;
    }

    private int dfs(int cx, int cy, int direction, boolean turn, int target) {
        int nx = cx + DIRS[direction][0];
        int ny = cy + DIRS[direction][1];
        /* If it goes beyond the boundary or the next node's value is not the target value, then return */
        if (nx < 0 || ny < 0 || nx >= m || ny >= n || grid[nx][ny] != target) {
            return 0;
        }

        int turnInt = turn ? 1 : 0;
        if (memo[nx][ny][direction][turnInt] != -1) {
            return memo[nx][ny][direction][turnInt];
        }

        /* Continue walking in the original direction. */
        int maxStep = dfs(nx, ny, direction, turn, 2 - target);
        if (turn) {
            /* Clockwise rotate 90 degrees turn */
            maxStep = Math.max(
                maxStep,
                dfs(nx, ny, (direction + 1) % 4, false, 2 - target)
            );
        }
        memo[nx][ny][direction][turnInt] = maxStep + 1;
        return maxStep + 1;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(m√ón√ó4√ó2) | Memoization with 8 states per cell |
| **Space**       | O(m√ón√ó8)   | 4D memoization array |

## üìä Example Walkthrough
**Input:** grid = [[1,0,1],[0,1,0],[1,0,1]]

**Execution:**
1. Start at (0,0) value=1, direction=SE
2. Next should be 0 at (1,1) ‚Üí found
3. Next should be 1 at (2,2) ‚Üí found
4. Length=3 without turn
5. With turn at (1,1): continue in new direction
6. Total length=5 with one turn

## üí° Key Features
- **Memoization**: Avoids recomputation of same states
- **Direction Handling**: 4 diagonal directions
- **Turn Flexibility**: Allows clockwise and counter-clockwise turns
- **Alternating Pattern**: Enforces 1-0-1-0 sequence

## üöÄ When to Use
- Grid path finding with constraints
- When paths have specific patterns and turns
- Problems requiring DFS with memoization
- Pattern matching in grids

## ‚ö†Ô∏è Edge Cases
- **Single Cell**: Returns 1 if value=1
- **No Valid Path**: Returns 0 if no V-shape found
- **Grid Boundaries**: Proper boundary checking
- **Alternation Enforcement**: Strict 1-0-1-0 pattern

## üõ† Variations
1. **BFS Approach**:
```java
// Level-based exploration of paths
```

2. **DP with State Machine**:
```java
// Dynamic programming with state transitions
```

3. **Bi-directional Search**:
```java
// Search from both ends of segments
```

4. **Visualization**:
```java
// Print discovered V-shaped paths
```

5. **Generalized for k Turns**:
```java
// Allow more than one turn
```

## Mathematical Insight
The solution leverages:
- Graph traversal algorithms
- State space optimization
- Combinatorial path counting
- Memoization techniques

## Alternative Implementation (Iterative DP)
```java
// More complex but possible with careful state management
```
Note: The DFS with memoization approach is well-suited for this problem due to the multiple states (position, direction, turn status) and the relatively small grid constraints (100x100).