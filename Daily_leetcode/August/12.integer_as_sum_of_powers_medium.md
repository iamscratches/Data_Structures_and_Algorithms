# 🔢 Ways to Express an Integer as Sum of Powers - Dynamic Programming Approach

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/description/?envType=daily-question&envId=2025-08-12)

Given:
- Two integers `n` and `x`

Find:
The number of ways to express `n` as a sum of unique xth powers of distinct positive integers, modulo 10⁹ + 7.

**Constraints:**
- 1 ≤ n ≤ 300
- 1 ≤ x ≤ 5

**Example:**
```text
Input: n = 10, x = 2
Output: 1
Explanation: 
10 can be expressed as 1² + 3² = 1 + 9
No other combinations of distinct squares sum to 10
```

## 🧠 Intuition
The solution uses:
1. **Dynamic Programming**: Builds up solution using smaller subproblems
2. **Unbounded Knapsack**: Similar to coin change problem but with unique items
3. **Reverse Iteration**: Prevents duplicate combinations by processing sums backwards
4. **Modulo Arithmetic**: Ensures results fit within standard integer limits

Key Insights:
- Each number's xth power can be used at most once
- The order of addition doesn't matter (1²+3² same as 3²+1²)
- DP array tracks number of ways to achieve each sum

## ⚙️ Approach
1. **Initialize DP Array**:
   - `dp[0] = 1` (one way to make sum 0 - use no numbers)
2. **Generate Powers**:
   - For each integer i where iˣ ≤ n
3. **Update DP**:
   - For each possible sum from n down to iˣ
   - Add ways to make (sum - iˣ) to current sum's count
4. **Return Result**:
   - `dp[n]` contains the final count modulo 10⁹ + 7

## ✅ Optimized Solution
```java
class Solution {
    private static final int MOD = 1_000_000_007;
    
    public int numberOfWays(int n, int x) {
        long[] dp = new long[n + 1];
        dp[0] = 1; // Base case: 1 way to make sum 0
        
        // Iterate through all possible base numbers
        for (int i = 1; Math.pow(i, x) <= n; i++) {
            int power = (int) Math.pow(i, x);
            
            // Update dp array in reverse to avoid duplicate combinations
            for (int sum = n; sum >= power; sum--) {
                dp[sum] = (dp[sum] + dp[sum - power]) % MOD;
            }
        }
        
        return (int) dp[n];
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n√n)     | For x=2, i goes up to √n |
| **Space**       | O(n)       | DP array size |

## 📊 Example Walkthrough
**Input:** n = 10, x = 2

**Execution:**
1. Initialize dp = [1,0,0,0,0,0,0,0,0,0,0]
2. i=1 (1²=1):
   - Update sums 10 down to 1: dp[1] += dp[0] → dp = [1,1,0,...]
3. i=2 (4):
   - Update sums 10 down to 4: dp[4] += dp[0], dp[5] += dp[1], etc.
4. i=3 (9):
   - Update sums 10 down to 9: dp[9] += dp[0], dp[10] += dp[1]
   - dp[10] becomes 1 (1² + 3²)
5. Final result: dp[10] = 1

## 💡 Key Features
- **Efficient Counting**: Avoids duplicate combinations
- **Modulo Handling**: Prevents integer overflow
- **Reverse Iteration**: Ensures uniqueness
- **Clear Base Case**: dp[0] initialization

## 🚀 When to Use
- Combinatorial sum problems
- Counting unique combinations
- When order doesn't matter
- Problems with distinct element constraints

## ⚠️ Edge Cases
- **n = 0**: Returns 1 (empty combination)
- **n = 1**: Only 1ˣ combination
- **Large n**: Handled by modulo
- **x = 1**: Becomes subset sum problem

## 🛠 Variations
1. **Memoization**:
```java
// Recursive solution with memoization
```

2. **Parallel Processing**:
```java
// Process different power ranges in parallel
```

3. **Early Termination**:
```java
// Stop when remaining powers can't reach sum
```

4. **Visualization**:
```java
// Print DP array at each step
```

5. **Generalized for k Summands**:
```java
// Count combinations with exactly k numbers
```

## Mathematical Insight
The solution leverages:
- Dynamic programming principles
- Properties of powers
- Combinatorial mathematics
- Inclusion-exclusion principle

## Alternative Implementation (Memoization)
```java
class Solution {
    private int MOD = 1_000_000_007;
    private Map<String, Integer> memo = new HashMap<>();
    
    public int numberOfWays(int n, int x) {
        return helper(n, x, 1);
    }
    
    private int helper(int remaining, int x, int current) {
        if (remaining == 0) return 1;
        String key = remaining + "," + current;
        if (memo.containsKey(key)) return memo.get(key);
        
        int ways = 0;
        int power = (int)Math.pow(current, x);
        if (power <= remaining) {
            ways = (ways + helper(remaining - power, x, current + 1)) % MOD;
        }
        ways = (ways + helper(remaining, x, current + 1)) % MOD;
        
        memo.put(key, ways);
        return ways;
    }
}
```
Note: This recursive solution may be more intuitive but less efficient for larger n due to stack overhead. The DP solution is preferred.