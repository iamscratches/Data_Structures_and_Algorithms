# üçá Maximum Fruits Harvested After At Most K Steps - Sliding Window Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/description/?envType=daily-question&envId=2025-08-03)

Given:
- Array `fruits` where fruits[i] = [positioni, amounti]
- Starting position `startPos`
- Maximum steps `k`

Find:
The maximum number of fruits you can collect in at most `k` steps where:
- Each step moves you 1 unit left or right
- You can collect fruits at visited positions

**Constraints:**
- 1 ‚â§ fruits.length ‚â§ 10‚Åµ
- 0 ‚â§ startPos, positioni ‚â§ 2 * 10‚Åµ
- 1 ‚â§ amounti ‚â§ 10‚Å¥
- 0 ‚â§ k ‚â§ 2 * 10‚Åµ

**Example:**
```text
Input: fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4
Output: 9
Explanation:
Path: 5 ‚Üí 6 ‚Üí 2 ‚Üí 5 (4 steps)
Collect: 3 + 8 = 11 (but exceeds k=4)
Alternative path: 5 ‚Üí 6 ‚Üí 8 (3 steps)
Collect: 3 + 6 = 9
```

## üß† Intuition
The solution uses:
1. **Sliding Window**: Maintains valid fruit ranges within step limit
2. **Two-Way Path Calculation**: Considers both left-first and right-first paths
3. **Prefix Sum**: Efficiently calculates fruit sums in current window
4. **Optimal Harvesting**: Maximizes collection while respecting step constraints

Key Insights:
- The optimal path will be a contiguous segment
- Can approach from either left or right first
- Window maintains fruits collectible within k steps

## ‚öôÔ∏è Approach
1. **Initialize Window**:
   - Left pointer at start, current sum and max at 0
2. **Expand Window**:
   - Add fruits to right of window
3. **Validate Window**:
   - Shrink from left if steps exceed k
4. **Update Maximum**:
   - Track best valid window sum
5. **Path Calculation**:
   - Compute steps for both left-first and right-first paths

## ‚úÖ Optimized Solution
```java
class Solution {
    public int maxTotalFruits(int[][] fruits, int startPos, int k) {
        int left = 0;          // Left boundary of window
        int currentSum = 0;     // Current sum of fruits in window
        int maxFruits = 0;      // Maximum fruits collected
        
        for (int right = 0; right < fruits.length; right++) {
            // Add fruits at current right position
            currentSum += fruits[right][1];
            
            // Shrink window from left if steps exceed k
            while (left <= right && 
                   minSteps(fruits[left][0], fruits[right][0], startPos) > k) {
                currentSum -= fruits[left][1];
                left++;
            }
            
            // Update maximum fruits collected
            maxFruits = Math.max(maxFruits, currentSum);
        }
        
        return maxFruits;
    }

    private int minSteps(int leftPos, int rightPos, int start) {
        // Calculate steps for left-first path
        int goLeftFirst = Math.abs(start - leftPos) + (rightPos - leftPos);
        // Calculate steps for right-first path
        int goRightFirst = Math.abs(start - rightPos) + (rightPos - leftPos);
        // Return minimum steps between two paths
        return Math.min(goLeftFirst, goRightFirst);
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through fruits array |
| **Space**       | O(1)       | Constant extra space |

## üìä Example Walkthrough
**Input:** fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4

**Execution:**
1. Initialize: left=0, sum=0, max=0
2. right=0 (position 2):
   - sum=8
   - steps=min(5‚Üí2‚Üí5=6, 5‚Üí2‚Üí5=6) >4 ‚Üí shrink
3. right=1 (position 6):
   - sum=3
   - steps=min(5‚Üí6‚Üí5=2, 5‚Üí6‚Üí5=2) ‚â§4
   - max=3
4. right=2 (position 8):
   - sum=9
   - steps=min(5‚Üí6‚Üí8=3, 5‚Üí8‚Üí6=5) ‚â§4
   - max=9
5. Final result: 9

## üí° Key Features
- **Efficient Window Management**: Maintains valid harvest range
- **Two-Path Optimization**: Considers both movement directions
- **Linear Complexity**: Handles large input sizes
- **Real-Time Calculation**: Updates maximum during iteration

## üöÄ When to Use
- Contiguous subarray problems with constraints
- Path optimization with movement costs
- Problems requiring sliding window technique
- Harvesting/collection scenarios with movement limits

## ‚ö†Ô∏è Edge Cases
- **No Fruits**: Returns 0
- **Single Fruit**: Returns its amount if reachable
- **k=0**: Only collects at start position
- **All Fruits Reachable**: Returns total sum

## üõ† Variations
1. **Prefix Sum Array**:
```java
// Precompute sums for O(1) range queries
```

2. **Binary Search**:
```java
// Search for optimal window size
```

3. **Two Pointers**:
```java
// Alternative window management
```

4. **Early Termination**:
```java
// Exit if remaining fruits can't improve max
```

5. **Visualization**:
```java
// Print collected fruits at each step
```

## Mathematical Insight
The solution leverages:
- Triangle inequality for path optimization
- Sliding window properties
- Contiguous segment maximization
- Movement cost calculations

## Alternative Implementation (Prefix Sum)
```java
class Solution {
    public int maxTotalFruits(int[][] fruits, int startPos, int k) {
        int[] prefix = new int[fruits.length + 1];
        for (int i = 0; i < fruits.length; i++) {
            prefix[i+1] = prefix[i] + fruits[i][1];
        }
        
        int max = 0;
        for (int left = 0, right = 0; right < fruits.length; right++) {
            while (left <= right && minSteps(fruits[left][0], fruits[right][0], startPos) > k) {
                left++;
            }
            if (left <= right) {
                max = Math.max(max, prefix[right+1] - prefix[left]);
            }
        }
        return max;
    }
    // minSteps remains same
}
```
Note: This version uses prefix sums but maintains the same window logic. The original solution is more space-efficient for large arrays.