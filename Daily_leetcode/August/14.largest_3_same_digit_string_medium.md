# üî¢ Largest 3-Same-Digit Number in String - Priority Search Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/largest-3-same-digit-number-in-string/description/?envType=daily-question&envId=2025-08-14)

Given:
- A string `num` representing a large integer

Find:
- The largest 3-digit substring where all digits are identical
- Return empty string if no such substring exists

**Constraints:**
- 3 ‚â§ num.length ‚â§ 1000
- num consists only of digits (0-9)

**Example:**
```text
Input: num = "6777133339"
Output: "777"
Explanation: "777" is the largest 3-digit substring with identical digits

Input: num = "2300019"
Output: "000"
Explanation: "000" is valid despite leading zeros
```

## üß† Intuition
The solution uses:
1. **Priority Search**: Checks for triplets in descending order (999 to 000)
2. **Early Termination**: Returns immediately when first match found
3. **String Matching**: Simple substring existence check
4. **Efficiency**: Stops at highest possible valid triplet

Key Insights:
- Only 10 possible valid triplets exist (000-999)
- Checking in descending order ensures largest match
- No need to scan entire string if higher triplet exists

## ‚öôÔ∏è Approach
1. **Predefined Triplets**: Create all possible 3-same-digit strings in descending order
2. **Priority Check**: Iterate through triplets from largest to smallest
3. **Substring Search**: Check if current triplet exists in input string
4. **Return Result**: Return first found triplet or empty string

## ‚úÖ Optimized Solution
```java
class Solution {
    public String largestGoodInteger(String num) {
        // All possible 3-same-digit strings in descending order
        String[] candidates = {"999", "888", "777", "666", 
                              "555", "444", "333", "222", 
                              "111", "000"};
        
        // Check each candidate in priority order
        for (String triplet : candidates) {
            if (num.contains(triplet)) {
                return triplet;
            }
        }
        
        return ""; // No valid triplet found
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Worst case scans entire string |
| **Space**       | O(1)       | Fixed-size candidates array |

## üìä Example Walkthrough
**Input:** num = "6777133339"

**Execution:**
1. Check "999" ‚Üí not found
2. Check "888" ‚Üí not found
3. Check "777" ‚Üí found at index 2-4
4. Return "777" immediately

**Input:** num = "2300019"
1. Check "999" to "111" ‚Üí not found
2. Check "000" ‚Üí found at index 2-4
3. Return "000"

## üí° Key Features
- **Priority-Based Search**: Ensures largest result
- **Simple Implementation**: Easy to understand
- **Early Termination**: Optimizes performance
- **Complete Coverage**: Checks all possible cases

## üöÄ When to Use
- Pattern matching in strings
- When searching for specific numeric patterns
- Problems with fixed-size substring requirements
- When priority ordering matters

## ‚ö†Ô∏è Edge Cases
- **No Triplets**: Returns empty string
- **Multiple Triplets**: Returns largest
- **Leading Zeros**: "000" is valid
- **Short String**: "111" in "111" returns "111"

## üõ† Variations
1. **Sliding Window**:
```java
// Scan string once with sliding window
```

2. **Regex Approach**:
```java
// Use regular expression matching
```

3. **Early Stop Optimization**:
```java
// Track highest possible remaining candidate
```

4. **Parallel Search**:
```java
// Check multiple candidates concurrently
```

5. **Visualization**:
```java
// Print search progress for debugging
```

## Mathematical Insight
The solution leverages:
- Finite possible combinations (only 10)
- Total ordering of digit sequences
- String search efficiency
- Greedy algorithm principles

## Alternative Implementation (Sliding Window)
```java
class Solution {
    public String largestGoodInteger(String num) {
        String max = "";
        for (int i = 0; i <= num.length() - 3; i++) {
            String current = num.substring(i, i + 3);
            if (current.charAt(0) == current.charAt(1) && 
                current.charAt(1) == current.charAt(2)) {
                if (current.compareTo(max) > 0) {
                    max = current;
                }
            }
        }
        return max;
    }
}
```
Note: This version scans the string once but may be less efficient for very large strings with early matches. The priority search is optimal when high-value triplets are likely.