# üÉè 24 Game - Backtracking with DFS Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/24-game/description/?envType=daily-question&envId=2025-08-18)

Given:
- An array of 4 integers (cards) between 1 and 9

Determine:
- If these numbers can be combined using +, -, *, / operations to make 24
- Each number must be used exactly once
- Parentheses can be used to dictate operation order

**Constraints:**
- cards.length == 4
- 1 ‚â§ cards[i] ‚â§ 9

**Example:**
```text
Input: [4, 1, 8, 7]
Output: true
Explanation: (8 - (4 / (1 + 7))) = 24
```

## üß† Intuition
The solution uses:
1. **Depth-First Search (DFS)**: Explores all possible operation combinations
2. **Backtracking**: Tries different operation orders and rolls back if unsuccessful
3. **Floating-Point Precision Handling**: Uses epsilon (1e-6) to compare results
4. **Operation Permutations**: Considers all binary operations (+, -, *, /) in both orders

Key Insights:
- Need to try all combinations of numbers and operations
- Division must account for non-zero denominators
- Parentheses are implicitly handled via operation order
- Intermediate results can be non-integers

## ‚öôÔ∏è Approach
1. **Convert to Doubles**: Handle division cases properly
2. **Base Case**: When one number remains, check if ‚âà24
3. **Number Selection**: Pick all distinct pairs of numbers
4. **Operation Application**: Apply all valid operations to the pair
5. **Recursive Check**: Continue with reduced number set
6. **Backtrack**: Undo operations to try alternatives

## ‚úÖ Optimized Solution
```java
class Solution {
    final double EPS = 1e-6; // For floating-point comparison

    public boolean judgePoint24(int[] cards) {
        List<Double> nums = new ArrayList<>();
        for (int n : cards) nums.add((double) n);
        return dfs(nums);
    }

    private boolean dfs(List<Double> nums) {
        // Base case: single number remaining
        if (nums.size() == 1) {
            return Math.abs(nums.get(0) - 24.0) < EPS;
        }

        // Try all pairs of numbers
        for (int i = 0; i < nums.size(); i++) {
            for (int j = 0; j < nums.size(); j++) {
                if (i == j) continue; // Must be distinct numbers

                List<Double> next = new ArrayList<>();
                // Add remaining numbers not being operated on
                for (int k = 0; k < nums.size(); k++) {
                    if (k != i && k != j) next.add(nums.get(k));
                }

                // Try all possible operations
                for (double val : compute(nums.get(i), nums.get(j))) {
                    next.add(val);
                    if (dfs(next)) return true;
                    next.remove(next.size() - 1); // Backtrack
                }
            }
        }
        return false;
    }

    // Generate all possible operation results
    private List<Double> compute(double a, double b) {
        List<Double> res = new ArrayList<>();
        res.add(a + b);
        res.add(a - b);
        res.add(b - a);
        res.add(a * b);
        if (Math.abs(b) > EPS) res.add(a / b); // Avoid division by zero
        if (Math.abs(a) > EPS) res.add(b / a);
        return res;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(1)       | Fixed 4 cards ‚Üí constant time |
| **Space**       | O(1)       | Maximum recursion depth of 4 |

## üìä Example Walkthrough
**Input:** [4, 1, 8, 7]

**Execution:**
1. Initial numbers: [4.0, 1.0, 8.0, 7.0]
2. Try operation 8 / (1 + 7) = 1.0 ‚Üí new numbers: [4.0, 1.0]
3. Then 4 / 1.0 = 4.0 ‚Üí new numbers: [4.0]
4. Finally 8 - 4.0 = 4.0 ‚â† 24 ‚Üí backtrack
5. Find successful path: (8 - (4 / (1 + 7))) = 24

## üí° Key Features
- **Exhaustive Search**: Checks all possible operation combinations
- **Precision Handling**: Uses epsilon for floating-point comparison
- **Backtracking**: Efficiently explores solution space
- **Operation Symmetry**: Considers both a-b and b-a

## üöÄ When to Use
- Combinatorial problems with operations
- When exhaustive search is feasible
- Problems requiring operation ordering
- Game strategy implementations

## ‚ö†Ô∏è Edge Cases
- **Division by Zero**: Handled with epsilon check
- **All Identical Numbers**: e.g., [8,8,8,8] ‚Üí 8+8+8+8=32‚â†24
- **Precision Issues**: Floating-point comparisons
- **Non-Integer Results**: Intermediate divisions

## üõ† Variations
1. **Memoization**:
```java
// Cache previously computed states
```

2. **Breadth-First Search**:
```java
// Level-order exploration of operations
```

3. **Operation Pruning**:
```java
// Skip obviously too large/small intermediates
```

4. **Parallel Processing**:
```java
// Explore different operation paths concurrently
```

5. **Visualization**:
```java
// Print operation sequences
```

## Mathematical Insight
The solution leverages:
- Permutation of operations
- Properties of arithmetic operations
- Recursive problem decomposition
- Backtracking algorithm principles

## Alternative Implementation (Iterative)
```java
// Not recommended due to complexity, but possible with stacks
```
Note: The recursive DFS approach is more natural for this problem due to its tree-like exploration of possibilities. The solution efficiently handles the fixed input size (4 cards) through systematic combination checking.