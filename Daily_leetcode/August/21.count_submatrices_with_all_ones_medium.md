# üî≥ Count Submatrices with All Ones - Histogram and Dynamic Programming Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/count-submatrices-with-all-ones/?envType=daily-question&envId=2025-08-21)

Given:
- An `m x n` binary matrix `mat` filled with 0s and 1s

Find:
- The total number of rectangular submatrices with all ones

**Constraints:**
- 1 ‚â§ m, n ‚â§ 150
- mat[i][j] is either 0 or 1

**Example:**
```text
Input: mat = [[1,0,1],[1,1,0],[1,1,0]]
Output: 13
Explanation: 
There are 6 rectangles of size 1x1, 3 of size 1x2, 2 of size 2x1, 
1 of size 2x2, and 1 of size 3x1
Total = 6 + 3 + 2 + 1 + 1 = 13
```

## üß† Intuition
The solution uses:
1. **Prefix Count Array**: Stores consecutive ones to the right for each cell
2. **Column-wise Processing**: For each column, treats rows as histogram bars
3. **Minimum Chain Calculation**: For each starting cell, calculates minimum width across rows
4. **Efficient Counting**: Accumulates all possible rectangles ending at each cell

Key Insights:
- Convert 2D problem to 1D by processing columns independently
- For each column j, consider it as the left boundary of rectangles
- The number of rectangles starting at (i,j) depends on minimum consecutive ones in subsequent rows

## ‚öôÔ∏è Approach
1. **Precompute Consecutive Ones**:
   - For each row, calculate consecutive ones to the right (including current)
2. **Count Rectangles**:
   - For each column j, for each starting row i
   - Track minimum consecutive ones from row i downward
   - Add min value to accumulate all valid rectangles

## ‚úÖ Optimized Solution
```java
class Solution {
    public int numSubmat(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        int total = 0;
        
        // Precompute consecutive ones to the right for each cell
        int[][] consecutiveOnes = new int[m][n];
        for (int i = 0; i < m; i++) {
            int count = 0;
            for (int j = n - 1; j >= 0; j--) {
                if (mat[i][j] == 1) {
                    count++;
                } else {
                    count = 0;
                }
                consecutiveOnes[i][j] = count;
            }
        }
        
        // Count all rectangles
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int minWidth = Integer.MAX_VALUE;
                // For each starting row i, check all rows below
                for (int k = i; k < m; k++) {
                    minWidth = Math.min(minWidth, consecutiveOnes[k][j]);
                    total += minWidth;
                }
            }
        }
        
        return total;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(m¬≤√ón)    | Triple nested loops |
| **Space**       | O(m√ón)     | Storage for consecutive ones array |

## üìä Example Walkthrough
**Input:** mat = [[1,0,1],[1,1,0],[1,1,0]]

**Step 1: Precompute consecutiveOnes:**
```
Row 0: [1,0,1] ‚Üí [1,0,1]
Row 1: [1,1,0] ‚Üí [2,1,0] 
Row 2: [1,1,0] ‚Üí [2,1,0]
```

**Step 2: Count rectangles for column 0:**
- Starting at (0,0): min(1,2,2)=1 ‚Üí +1
- Starting at (1,0): min(2,2)=2 ‚Üí +2
- Starting at (2,0): min(2)=2 ‚Üí +2
Total for column 0: 5

**Final total:** Sum across all columns = 13

## üí° Key Features
- **Efficient Preprocessing**: O(m√ón) time for consecutive ones
- **Systematic Counting**: Ensures all rectangles are counted
- **Column-wise Processing**: Reduces 2D problem to 1D
- **Early Minimum Tracking**: Optimizes rectangle height calculation

## üöÄ When to Use
- Counting rectangular submatrices
- Problems involving consecutive ones
- When matrix dimensions are moderate
- Histogram-based approaches

## ‚ö†Ô∏è Edge Cases
- **All Zeros**: Returns 0
- **All Ones**: Maximum number of rectangles
- **Single Row**: Handles 1D case
- **Large Matrix**: Works within constraints

## üõ† Variations
1. **Monotonic Stack Optimization**:
```java
// Use stack to reduce time complexity to O(m√ón)
```

2. **Dynamic Programming**:
```java
// Alternative DP approach for rectangle counting
```

3. **Parallel Processing**:
```java
// Process columns in parallel
```

4. **Visualization**:
```java
// Print consecutive ones array
```

5. **Space Optimization**:
```java
// Compute consecutive ones on the fly
```

## Mathematical Insight
The solution leverages:
- Properties of rectangular areas
- Minimum value chains
- Cumulative counting techniques
- Matrix decomposition principles

## Alternative Implementation (Optimized)
```java
class Solution {
    public int numSubmat(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int total = 0;
        int[] height = new int[n];
        
        for (int i = 0; i < m; i++) {
            // Update height array for current row
            for (int j = 0; j < n; j++) {
                height[j] = mat[i][j] == 1 ? height[j] + 1 : 0;
            }
            total += countRectangles(height);
        }
        return total;
    }
    
    private int countRectangles(int[] heights) {
        // Use monotonic stack to count rectangles efficiently
        int n = heights.length;
        int[] sum = new int[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int j = 0; j < n; j++) {
            while (!stack.isEmpty() && heights[stack.peek()] >= heights[j]) {
                stack.pop();
            }
            if (stack.isEmpty()) {
                sum[j] = heights[j] * (j + 1);
            } else {
                int prev = stack.peek();
                sum[j] = sum[prev] + heights[j] * (j - prev);
            }
            stack.push(j);
        }
        
        int total = 0;
        for (int s : sum) total += s;
        return total;
    }
}
```
Note: This optimized version uses monotonic stacks to achieve O(m√ón) time complexity, but the original solution is more straightforward for understanding the concept.