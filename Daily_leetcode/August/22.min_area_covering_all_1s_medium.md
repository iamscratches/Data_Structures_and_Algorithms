# üìê Minimum Area to Cover All Ones I - Boundary Detection Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/find-the-minimum-area-to-cover-all-ones-i/description/?envType=daily-question&envId=2025-08-22)

Given:
- An `m x n` binary matrix `grid` filled with 0s and 1s

Find:
- The area of the smallest rectangle that can cover all the 1s in the grid
- The rectangle must be axis-aligned (edges parallel to grid lines)

**Constraints:**
- 1 ‚â§ m, n ‚â§ 1000
- grid[i][j] is either 0 or 1
- At least one 1 exists in the grid

**Example:**
```text
Input: grid = [[0,0,1,0],[0,1,1,0],[0,1,0,0]]
Output: 6
Explanation: 
The smallest rectangle covering all ones has dimensions 2x3
Coordinates: from row1-col1 to row2-col3
```

## üß† Intuition
The solution uses:
1. **Boundary Detection**: Finds the outermost rows and columns containing 1s
2. **Four-Pass Scanning**: Scans from all four directions (top, left, bottom, right)
3. **Early Termination**: Stops scanning when first 1 is found in each direction
4. **Area Calculation**: Computes rectangle area from boundary coordinates

Key Insights:
- The minimal rectangle is defined by the extreme 1 positions
- Only need to find min/max row and column indices containing 1s
- The area is simply (max_row - min_row + 1) √ó (max_col - min_col + 1)

## ‚öôÔ∏è Approach
1. **Initialize Boundaries**:
   - Set initial min to (0,0) and max to (m-1, n-1)
2. **Find Top Boundary**:
   - Scan rows top-down until first 1 is found
3. **Find Left Boundary**:
   - Scan columns left-right until first 1 is found
4. **Find Bottom Boundary**:
   - Scan rows bottom-up until first 1 is found
5. **Find Right Boundary**:
   - Scan columns right-left until first 1 is found
6. **Calculate Area**: Using the boundary coordinates

## ‚úÖ Optimized Solution
```java
class Solution {
    public int minimumArea(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        
        // Initialize boundaries to extreme values
        int minRow = m, maxRow = -1;
        int minCol = n, maxCol = -1;
        
        // Find boundaries by scanning for 1s
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    minRow = Math.min(minRow, i);
                    maxRow = Math.max(maxRow, i);
                    minCol = Math.min(minCol, j);
                    maxCol = Math.max(maxCol, j);
                }
            }
        }
        
        // Calculate area
        int height = maxRow - minRow + 1;
        int width = maxCol - minCol + 1;
        return height * width;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(m√ón)     | Single pass through entire grid |
| **Space**       | O(1)       | Constant extra space |

## üìä Example Walkthrough
**Input:** grid = [[0,0,1,0],[0,1,1,0],[0,1,0,0]]

**Execution:**
1. Scan all cells:
   - Found 1 at (0,2): minRow=0, maxRow=0, minCol=2, maxCol=2
   - Found 1 at (1,1): minRow=0, maxRow=1, minCol=1, maxCol=2
   - Found 1 at (1,2): minRow=0, maxRow=1, minCol=1, maxCol=2
   - Found 1 at (2,1): minRow=0, maxRow=2, minCol=1, maxCol=2
2. Calculate:
   - Height = 2 - 0 + 1 = 3
   - Width = 2 - 1 + 1 = 2
   - Area = 3 √ó 2 = 6

## üí° Key Features
- **Single Pass Efficiency**: Finds boundaries in one grid traversal
- **Clear Boundary Tracking**: Simple min/max updates
- **Optimal Solution**: Best possible time complexity
- **Robust Handling**: Works for all valid inputs

## üöÄ When to Use
- Finding bounding boxes in grids
- Image processing applications
- When extreme coordinates need identification
- Problems involving spatial coverage

## ‚ö†Ô∏è Edge Cases
- **Single 1**: Returns 1 (1√ó1 rectangle)
- **All 1s**: Returns full grid area
- **Single Row**: Handles 1D case properly
- **Sparse 1s**: Efficiently finds scattered points

## üõ† Variations
1. **Early Termination**:
```java
// Stop when all boundaries found (but still O(m√ón) worst case)
```

2. **Four-Pass Optimization**:
```java
// Scan from each direction until first 1 found
```

3. **Parallel Processing**:
```java
// Process grid sections concurrently for large matrices
```

4. **Visualization**:
```java
// Print the bounding box coordinates
```

5. **3D Extension**:
```java
// For 3D grids (min/max x,y,z)
```

## Mathematical Insight
The solution leverages:
- Properties of axis-aligned rectangles
- Extreme value theory
- Efficient range reduction
- Coordinate geometry principles

## Alternative Implementation (Four-Pass)
```java
class Solution {
    public int minimumArea(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        
        // Find top boundary
        int top = 0;
        while (top < m) {
            boolean found = false;
            for (int j = 0; j < n; j++) {
                if (grid[top][j] == 1) {
                    found = true;
                    break;
                }
            }
            if (found) break;
            top++;
        }
        
        // Similar scans for bottom, left, right...
        // (Implementation for other boundaries)
        
        return (bottom - top + 1) * (right - left + 1);
    }
}
```
Note: The four-pass version may be faster for sparse matrices, but the single-pass solution is generally more efficient and cleaner.