# üçé Rearranging Fruits - Optimal Swap Strategy

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/rearranging-fruits/description/?envType=daily-question&envId=2025-08-02)

Given:
- Two fruit baskets `basket1` and `basket2` containing integer-valued fruits

Find:
The minimum cost to make both baskets have exactly the same multiset of fruits, where:
- Each swap operation costs `min(swapped_fruit1, swapped_fruit2)`
- Return -1 if impossible

**Constraints:**
- 1 ‚â§ basket1.length, basket2.length ‚â§ 10‚Åµ
- 1 ‚â§ basket1[i], basket2[i] ‚â§ 10‚Åπ

**Example:**
```text
Input: basket1 = [4,2,2,2], basket2 = [1,4,1,2]
Output: 1
Explanation:
Swap fruit 1 from basket2 with fruit 2 from basket1: cost = min(1,2) = 1
Final baskets:
- basket1 = [4,2,1,2]
- basket2 = [2,4,1,2]
```

## üß† Intuition
The solution uses:
1. **Frequency Analysis**: Checks if balanced distribution is possible
2. **Cost Optimization**: Minimizes swap costs using the smallest fruits
3. **Two-Way Swapping**: Considers both direct and indirect swap paths
4. **Global Minimum**: Leverages the cheapest fruit for optimal swaps

Key Insights:
- Total counts must be even for each fruit type
- The smallest fruit can help reduce swap costs
- Only half the differences need to be swapped

## ‚öôÔ∏è Approach
1. **Count Validation**:
   - Verify total counts are even for all fruits
   - Find global minimum fruit value
2. **Difference Calculation**:
   - Identify surplus/deficit fruits in each basket
   - Collect fruits needing swaps
3. **Cost Calculation**:
   - Sort fruits to prioritize cheapest swaps
   - Compare direct swap cost vs indirect (using min fruit)

## ‚úÖ Optimized Solution
```java
class Solution {
    public long minCost(int[] basket1, int[] basket2) {
        // Step 1: Calculate total counts of each fruit
        Map<Integer, Integer> totalCounts = new HashMap<>();
        for (int fruit : basket1) totalCounts.put(fruit, totalCounts.getOrDefault(fruit, 0) + 1);
        for (int fruit : basket2) totalCounts.put(fruit, totalCounts.getOrDefault(fruit, 0) + 1);

        // Step 2: Check if balanced distribution is possible and find global minimum
        long minVal = Long.MAX_VALUE;
        for (Map.Entry<Integer, Integer> entry : totalCounts.entrySet()) {
            if (entry.getValue() % 2 != 0) return -1;
            minVal = Math.min(minVal, entry.getKey());
        }

        // Step 3: Calculate differences and collect fruits to swap
        List<Long> swapFruits = new ArrayList<>();
        Map<Integer, Integer> count1 = new HashMap<>();
        for (int fruit : basket1) count1.put(fruit, count1.getOrDefault(fruit, 0) + 1);

        for (Map.Entry<Integer, Integer> entry : totalCounts.entrySet()) {
            int fruit = entry.getKey();
            int diff = count1.getOrDefault(fruit, 0) - (entry.getValue() / 2);
            for (int i = 0; i < Math.abs(diff); i++) {
                swapFruits.add((long)fruit);
            }
        }
        
        // Step 4: Sort and calculate minimum cost
        Collections.sort(swapFruits);
        long totalCost = 0;
        for (int i = 0; i < swapFruits.size() / 2; i++) {
            totalCost += Math.min(swapFruits.get(i), 2 * minVal);
        }
        
        return totalCost;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n log n) | Due to sorting of swap fruits |
| **Space**       | O(n)       | For storing frequency maps and swap list |

## üìä Example Walkthrough
**Input:** basket1 = [4,2,2,2], basket2 = [1,4,1,2]

**Execution:**
1. Total counts: {1:2, 2:4, 4:2} ‚Üí All even
2. Global minVal = 1
3. Differences:
   - basket1 has extra 2 (count=3 vs target=2)
   - basket2 has extra 1 (count=2 vs target=1)
4. Swap fruits: [1, 2]
5. Cost calculation:
   - min(1, 2*1) = 1
6. Total cost: 1

## üí° Key Features
- **Efficient Validation**: Quick parity check
- **Optimal Swapping**: Uses smallest fruits first
- **Two-Path Costing**: Considers direct and indirect swaps
- **Scalable**: Handles large input sizes

## üöÄ When to Use
- Balancing problems with swap operations
- Minimum cost transformation tasks
- Frequency distribution challenges
- Problems with pairwise operations

## ‚ö†Ô∏è Edge Cases
- **Identical Baskets**: Cost = 0
- **Impossible Case**: Returns -1
- **Single Fruit Type**: Simple even count check
- **Large Values**: Handles 10‚Åπ range

## üõ† Variations
1. **Early Termination**:
```java
// Exit early if odd count detected
```

2. **Parallel Processing**:
```java
// Process baskets concurrently for large inputs
```

3. **Bucket Sort**:
```java
// Use when fruit values have limited range
```

4. **Visualization**:
```java
// Print swap operations for debugging
```

5. **Memory Optimization**:
```java
// Use arrays instead of HashMaps for known small ranges
```

## Mathematical Insight
The solution leverages:
- Parity checking for feasibility
- Optimal transport theory
- Greedy algorithm principles
- Sorting for cost minimization

## Alternative Implementation (Early Count Check)
```java
class Solution {
    public long minCost(int[] basket1, int[] basket2) {
        Map<Integer, Integer> count = new HashMap<>();
        long minVal = Long.MAX_VALUE;
        
        // First pass: count and find min
        for (int fruit : basket1) {
            count.put(fruit, count.getOrDefault(fruit, 0) + 1);
            minVal = Math.min(minVal, fruit);
        }
        for (int fruit : basket2) {
            count.put(fruit, count.getOrDefault(fruit, 0) + 1);
            minVal = Math.min(minVal, fruit);
        }
        
        // Immediate check for odd counts
        for (int val : count.values()) {
            if (val % 2 != 0) return -1;
        }
        
        // Rest of implementation same as before...
    }
}
```
Note: This version performs the odd count check earlier but maintains the same core logic. The original solution is equally efficient.