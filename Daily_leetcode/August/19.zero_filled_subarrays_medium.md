# 0Ô∏è‚É£ Number of Zero-Filled Subarrays - Linear Scan Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/number-of-zero-filled-subarrays/description/?envType=daily-question&envId=2025-08-19)

Given:
- An integer array `nums`

Find:
- The number of contiguous subarrays filled entirely with 0s

**Constraints:**
- 1 ‚â§ nums.length ‚â§ 10‚Åµ
- -10‚Åπ ‚â§ nums[i] ‚â§ 10‚Åπ

**Example:**
```text
Input: nums = [1,3,0,0,2,0,0,4]
Output: 6
Explanation: 
Zero-filled subarrays are:
[0], [0], [0,0], [0], [0], [0,0]
```

## üß† Intuition
The solution uses:
1. **Linear Scanning**: Processes the array in one pass
2. **Running Counter**: Tracks length of current zero sequence
3. **Triangular Number Formula**: Counts subarrays in a zero sequence (n*(n+1)/2)
4. **Efficient Counting**: Updates total count incrementally

Key Insights:
- Each new zero in a sequence adds (current length + 1) new subarrays
- Non-zero numbers reset the current zero sequence counter
- No need to store all subarrays explicitly

## ‚öôÔ∏è Approach
1. **Initialize Counters**:
   - `totalCount` for final result
   - `currentStreak` for current zero sequence length
2. **Array Traversal**:
   - For each zero: increment `currentStreak` and add to `totalCount`
   - For non-zero: reset `currentStreak`
3. **Return Result**: Total count of zero-filled subarrays

## ‚úÖ Optimized Solution
```java
class Solution {
    public long zeroFilledSubarray(int[] nums) {
        long totalCount = 0;
        int currentStreak = 0;
        
        for (int num : nums) {
            if (num == 0) {
                currentStreak++;
                totalCount += currentStreak;
            } else {
                currentStreak = 0;
            }
        }
        
        return totalCount;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through array |
| **Space**       | O(1)       | Constant extra space |

## üìä Example Walkthrough
**Input:** nums = [0,0,0,2,0,0]

**Execution:**
1. Initialize: total=0, streak=0
2. First 0: streak=1, total=1
3. Second 0: streak=2, total=3 (adds [0] and [0,0])
4. Third 0: streak=3, total=6 (adds [0], [0,0], [0,0,0])
5. 2: reset streak=0
6. First 0: streak=1, total=7
7. Second 0: streak=2, total=9
8. Final result: 9

## üí° Key Features
- **Efficient Counting**: O(n) time with O(1) space
- **Incremental Update**: Computes count without storing subarrays
- **Simple Logic**: Easy to understand and implement
- **Handles Large Inputs**: Suitable for constraints

## üöÄ When to Use
- Counting contiguous sequences
- Subarray enumeration problems
- When optimal O(n) solution is needed
- Problems with sequential pattern detection

## ‚ö†Ô∏è Edge Cases
- **All Zeros**: Maximum subarrays (n*(n+1)/2)
- **No Zeros**: Returns 0
- **Single Zero**: Returns 1
- **Alternating Zeros**: Proper streak resetting

## üõ† Variations
1. **Prefix Sum Approach**:
```java
// Alternative using prefix sums of zero positions
```

2. **Grouping Zeros First**:
```java
// First identify all zero sequences, then calculate
```

3. **Parallel Processing**:
```java
// For very large arrays, process chunks in parallel
```

4. **Visualization**:
```java
// Print identified zero sequences
```

5. **Sliding Window**:
```java
// Alternative implementation using window technique
```

## Mathematical Insight
The solution leverages:
- Properties of triangular numbers
- Arithmetic progression sums
- Linear scanning efficiency
- Combinatorial counting principles

## Alternative Implementation (Grouping)
```java
class Solution {
    public long zeroFilledSubarray(int[] nums) {
        long total = 0;
        int start = -1;
        
        for (int i = 0; i <= nums.length; i++) {
            if (i < nums.length && nums[i] == 0) {
                if (start == -1) start = i;
            } else if (start != -1) {
                long len = i - start;
                total += len * (len + 1) / 2;
                start = -1;
            }
        }
        
        return total;
    }
}
```
Note: This version first identifies zero sequences then calculates counts, but the original incremental approach is more efficient for this problem.