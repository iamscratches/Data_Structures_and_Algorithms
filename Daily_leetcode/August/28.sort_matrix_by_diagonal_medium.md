# üîÑ Sort Matrix by Diagonals - Diagonal Grouping and Sorting Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/sort-matrix-by-diagonals/?envType=daily-question&envId=2025-08-28)

Given:
- An `n x n` matrix `grid`

Task:
- Sort each diagonal of the matrix in ascending order
- Diagonals should be sorted from top-left to bottom-right
- Return the modified matrix

**Constraints:**
- n == grid.length == grid[i].length
- 1 ‚â§ n ‚â§ 100
- 1 ‚â§ grid[i][j] ‚â§ 100

**Example:**
```text
Input: grid = [[3,2,1],[1,2,3],[2,3,1]]
Output: [[1,2,3],[1,2,3],[2,3,1]]
Explanation:
Main diagonal [3,2,1] sorted to [1,2,3]
Other diagonals also sorted appropriately
```

## üß† Intuition
The solution uses:
1. **Diagonal Grouping**: Collects elements from each diagonal into separate lists
2. **Sorting**: Sorts each diagonal list in ascending order
3. **Reconstruction**: Places sorted elements back into the matrix in proper order
4. **Index Mapping**: Uses mathematical mapping between matrix coordinates and diagonal indices

Key Insights:
- Diagonals can be identified by constant (i-j) or (i+j) values
- Main diagonal has i = j
- Upper diagonals have i < j, lower diagonals have i > j
- Sorting order matters for reconstruction

## ‚öôÔ∏è Approach
1. **Diagonal Collection**:
   - Create lists for each diagonal (2n-1 diagonals total)
   - For each cell (i,j), calculate diagonal index
   - Add element to corresponding diagonal list
2. **Sorting**:
   - Sort each diagonal list in ascending order
3. **Matrix Reconstruction**:
   - For each cell, retrieve appropriate element from sorted diagonal list
   - Maintain original diagonal ordering (TL‚ÜíBR)

## ‚úÖ Optimized Solution
```java
class Solution {
    public int[][] sortMatrix(int[][] grid) {
        int n = grid.length;
        List<List<Integer>> diagonals = new ArrayList<>();
        
        // Initialize lists for all diagonals (2n-1 total)
        for (int i = 0; i < 2 * n - 1; i++) {
            diagonals.add(new ArrayList<>());
        }
        
        // Collect elements from each diagonal
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int diagIndex = getDiagonalIndex(i, j, n);
                diagonals.get(diagIndex).add(grid[i][j]);
            }
        }
        
        // Sort each diagonal
        for (List<Integer> diagonal : diagonals) {
            Collections.sort(diagonal);
        }
        
        // Reconstruct matrix with sorted diagonals
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int diagIndex = getDiagonalIndex(i, j, n);
                if(i<j){
                    grid[i][j] = diagonals.get(diagIndex).remove(0);
                }
                else{
                    grid[i][j] = diagonals.get(diagIndex).remove(diagonals.get(diagIndex).size()-1);
                }
                
            }
        }
        
        return grid;
    }
    
    private int getDiagonalIndex(int i, int j, int n) {
        // Diagonal index calculation:
        // Main diagonal: n-1
        // Upper diagonals: n-1 - (j-i)
        // Lower diagonals: n-1 + (i-j)
        if (i == j) return n - 1;
        if (i < j) return n - 1 - (j - i);
        return n - 1 + (i - j);
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n¬≤ log n) | Sorting n diagonals with average n elements |
| **Space**       | O(n¬≤)      | Storage for all diagonal elements |

## üìä Example Walkthrough
**Input:** grid = [[3,2,1],[1,2,3],[2,3,1]]

**Diagonal Groups:**
- Main diagonal (i=j): [3,2,1] ‚Üí sorted [1,2,3]
- Upper diagonal (i<j): [2,1] ‚Üí sorted [1,2]  
- Lower diagonal (i>j): [1,2] ‚Üí sorted [1,2]

**Reconstruction:**
- (0,0): main diag[0]=1
- (0,1): upper diag[0]=1
- (0,2): (needs proper indexing)
- etc...

## üí° Key Features
- **Clear Grouping**: Logical diagonal identification
- **Efficient Sorting**: Leverages Java's optimized sort
- **Proper Reconstruction**: Maintains diagonal ordering
- **Mathematical Indexing**: Precise coordinate mapping

## üöÄ When to Use
- Matrix diagonal processing
- When elements need grouping by diagonal
- Problems requiring coordinated sorting
- Grid transformation tasks

## ‚ö†Ô∏è Edge Cases
- **1x1 Matrix**: Single element
- **All Equal Elements**: Sorting doesn't change matrix
- **Already Sorted**: No changes needed
- **Large n**: Handles maximum constraint (n=100)

## üõ† Variations
1. **In-place Sorting**:
```java
// More complex but possible with careful element swapping
```

2. **Different Sort Orders**:
```java
// Descending or custom sorting
```

3. **Parallel Processing**:
```java
// Sort diagonals concurrently
```

4. **Visualization**:
```java
// Print diagonal groups before/after sorting
```

5. **Generalized for Rectangular Matrices**:
```java
// Handle non-square matrices
```

## Mathematical Insight
The solution leverages:
- Properties of matrix diagonals (constant i-j)
- Sorting algorithm efficiency
- Coordinate transformation mathematics
- Group theory principles

## Alternative Implementation (Alternative Indexing)
```java
class Solution {
    public int[][] sortMatrix(int[][] grid) {
        int n = grid.length;
        // Alternative indexing: use i-j difference
        Map<Integer, List<Integer>> diagMap = new HashMap<>();
        
        // Collect elements
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int key = i - j;
                diagMap.putIfAbsent(key, new ArrayList<>());
                diagMap.get(key).add(grid[i][j]);
            }
        }
        
        // Sort diagonals
        for (List<Integer> diagonal : diagMap.values()) {
            Collections.sort(diagonal);
        }
        
        // Reconstruct
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int key = i - j;
                grid[i][j] = diagMap.get(key).remove(0);
            }
        }
        
        return grid;
    }
}
```
Note: This alternative uses i-j as the diagonal key, which is simpler but requires proper ordering during reconstruction. The original solution maintains the top-left to bottom-right ordering more explicitly.