# üß© Minimum Area to Cover All Ones II - Three-Rectangle Partition with Rotation

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/find-the-minimum-area-to-cover-all-ones-ii/description/?envType=daily-question&envId=2025-08-23)

Given:
- An `m x n` binary matrix `grid` filled with 0s and 1s

Find:
- The minimum total area of three non-overlapping axis-aligned rectangles that together cover all the 1s in the grid
- The rectangles must not overlap and must cover all 1s

**Constraints:**
- 1 ‚â§ m, n ‚â§ 30
- grid[i][j] is either 0 or 1
- At least one 1 exists in the grid

**Example:**
```text
Input: grid = [[1,0,1],[1,1,1],[0,0,1]]
Output: 6
Explanation: 
Three rectangles needed to cover all ones with minimum total area
```

## üß† Intuition
The solution uses:
1. **Rotation Handling**: Considers 4 orientations (0¬∞, 90¬∞, 180¬∞, 270¬∞)
2. **Three-Partition Search**: Tries all possible ways to split grid into 3 parts
3. **Recursive Area Calculation**: Computes minimum bounding box for each partition
4. **Exhaustive Search**: Given small constraints (30√ó30), tries all possibilities

Key Insights:
- The three rectangles can be arranged in various configurations
- Rotating the grid simplifies partition logic
- Need to consider both horizontal and vertical splits
- The solution explores all possible partitions systematically

## ‚öôÔ∏è Approach
1. **Rotation Loop**: Try all 4 rotations of the grid
2. **Partition Exploration**:
   - For each rotation, try all possible split points
   - Consider both horizontal splits (two cuts) and mixed splits
3. **Area Calculation**:
   - For each partition, compute minimum bounding box area
4. **Result Tracking**: Keep minimum total area found

## ‚úÖ Optimized Solution
```java
class Solution {
    public int minimumSum(int[][] grid) {
        int minTotal = Integer.MAX_VALUE;
        
        // Try all 4 rotations
        for (int rotation = 0; rotation < 4; rotation++) {
            int rows = grid.length;
            int cols = grid[0].length;
            
            // Try all possible horizontal splits
            for (int split1 = 1; split1 < rows; split1++) {
                // First partition: rows [0, split1-1]
                int[][] part1 = getSubgrid(grid, 0, split1, 0, cols);
                int area1 = getMinArea(part1);
                
                // Remaining rows: [split1, rows-1]
                int[][] remaining = getSubgrid(grid, split1, rows, 0, cols);
                
                // Try vertical split on remaining rows
                for (int split2 = 1; split2 < cols; split2++) {
                    int[][] part2 = getSubgrid(remaining, 0, remaining.length, 0, split2);
                    int[][] part3 = getSubgrid(remaining, 0, remaining.length, split2, cols);
                    minTotal = Math.min(minTotal, area1 + getMinArea(part2) + getMinArea(part3));
                }
                
                // Try horizontal split on remaining rows
                for (int split2 = 1; split2 < remaining.length; split2++) {
                    int[][] part2 = getSubgrid(remaining, 0, split2, 0, cols);
                    int[][] part3 = getSubgrid(remaining, split2, remaining.length, 0, cols);
                    minTotal = Math.min(minTotal, area1 + getMinArea(part2) + getMinArea(part3));
                }
            }
            
            grid = rotateGrid(grid);
        }
        
        return minTotal;
    }
    
    private int[][] getSubgrid(int[][] grid, int startRow, int endRow, int startCol, int endCol) {
        int rows = endRow - startRow;
        int cols = endCol - startCol;
        int[][] subgrid = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            System.arraycopy(grid[startRow + i], startCol, subgrid[i], 0, cols);
        }
        return subgrid;
    }
    
    private int getMinArea(int[][] grid) {
        if (grid.length == 0 || grid[0].length == 0) return 0;
        int minRow = Integer.MAX_VALUE, maxRow = -1;
        int minCol = Integer.MAX_VALUE, maxCol = -1;
        boolean hasOne = false;
        
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    hasOne = true;
                    minRow = Math.min(minRow, i);
                    maxRow = Math.max(maxRow, i);
                    minCol = Math.min(minCol, j);
                    maxCol = Math.max(maxCol, j);
                }
            }
        }
        return hasOne ? (maxRow - minRow + 1) * (maxCol - minCol + 1) : 0;
    }
    
    private int[][] rotateGrid(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;
        int[][] rotated = new int[cols][rows];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                rotated[j][rows - 1 - i] = grid[i][j];
            }
        }
        return rotated;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(4 √ó m¬≤ √ó n¬≤) | 4 rotations √ó m splits √ó n splits |
| **Space**       | O(m√ón)     | For storing subgrids during processing |

## üìä Example Walkthrough
**Input:** grid = [[1,0,1],[1,1,1],[0,0,1]]

**Execution:**
1. Rotation 0: Try splits
2. Horizontal split after row 1:
   - Part1: [[1,0,1]] ‚Üí area = 3
   - Remaining: [[1,1,1],[0,0,1]]
   - Vertical split at col 1: areas 2 and 2 ‚Üí total 7
   - Horizontal split after row 1: areas 3 and 1 ‚Üí total 7
3. Find better split: total area 6
4. Return minimum across all rotations

## üí° Key Features
- **Rotation Handling**: Covers all rectangle orientations
- **Systematic Partitioning**: Explores all split possibilities
- **Efficient Area Calculation**: Uses bounding box method
- **Complete Coverage**: Guaranteed to find optimal solution

## üöÄ When to Use
- Multiple rectangle coverage problems
- When exhaustive search is feasible due to small constraints
- Problems requiring spatial partitioning
- Computer vision and image processing applications

## ‚ö†Ô∏è Edge Cases
- **All 1s in one cell**: Three 1√ó1 rectangles
- **Sparse 1s**: Efficient bounding box calculation
- **Empty Partitions**: Handles zero-area cases
- **Small Grids**: Works for minimum sizes

## üõ† Variations
1. **Dynamic Programming**:
```java
// Could use DP for more efficient solution
```

2. **Memoization**:
```java
// Cache computed areas for subgrids
```

3. **Parallel Processing**:
```java
// Process different rotations in parallel
```

4. **Visualization**:
```java
// Print the partition boundaries
```

5. **Generalized for k Rectangles**:
```java
// Extend to k rectangles instead of 3
```

## Mathematical Insight
The solution leverages:
- Combinatorial optimization
- Spatial partitioning theory
- Rotation and reflection symmetry
- Exhaustive search principles

## Alternative Implementation (Optimized)
```java
// The current solution is already optimized for the constraints
// Further optimizations might include:
// - Early termination when current sum exceeds best found
// - Memoization of subgrid areas
// - More efficient bounding box tracking
```
Note: Given the small constraints (30√ó30), the exhaustive approach is practical and guarantees finding the optimal solution.