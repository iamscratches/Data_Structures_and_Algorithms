# üé≤ New 21 Game - Dynamic Programming with Sliding Window Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/new-21-game/description/?envType=daily-question&envId=2025-08-17)

Given:
- Three integers `n`, `k`, and `maxPts`
- Game rules:
  - Start with 0 points
  - Draw numbers from [1, maxPts] with equal probability
  - Stop when points ‚â• k

Find:
- Probability that the final score is ‚â§ n

**Constraints:**
- 0 ‚â§ k ‚â§ n ‚â§ 10‚Å¥
- 1 ‚â§ maxPts ‚â§ 10‚Å¥

**Example:**
```text
Input: n = 21, k = 17, maxPts = 10
Output: 0.73278
Explanation: Probability of ending with ‚â§ 21 when stopping at ‚â• 17
```

## üß† Intuition
The solution uses:
1. **Base Cases Handling**: Immediate returns for certain conditions
2. **Sliding Window**: Maintains a running sum of probabilities
3. **Dynamic Programming**: Stores and reuses computed probabilities
4. **Backward Calculation**: Computes probabilities from k-1 down to 0

Key Insights:
- When k = 0 or k+maxPts ‚â§ n, probability is 1.0
- Probability at any point depends on next maxPts states
- Window sliding efficiently updates the probability sum

## ‚öôÔ∏è Approach
1. **Handle Base Cases**:
   - If k = 0 or k+maxPts ‚â§ n, return 1.0
2. **Initialize Window Sum**:
   - Calculate initial window sum for positions k to k+maxPts-1
3. **Backward DP Calculation**:
   - Compute probabilities from k-1 down to 0
   - Update window sum by adding current probability and removing expired probability
4. **Return Result**: Probability at position 0

## ‚úÖ Optimized Solution
```java
class Solution {
    public double new21Game(int n, int k, int maxPts) {
        if(k==0 || k+maxPts<=n){
            return 1.0;
        }
        double windowSum = 0.0;
        Map<Integer, Double> mapDP = new HashMap<>();
        double remove = 0.0;
        for(int i=k; i<k+maxPts; i++){
            windowSum+=i<=n?1:0;
        }
        for(int i=k-1; i>=0; i--){
            mapDP.put(i, windowSum/(double)maxPts);
            remove = 0.0;
            if(i+maxPts<=n){
                remove = mapDP.getOrDefault(i+maxPts, 1.0);
            }
            windowSum+=mapDP.get(i)-remove;
        }
        return mapDP.get(0);
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through DP array |
| **Space**       | O(n)       | For storing DP probabilities |

## üìä Example Walkthrough
**Input:** n = 21, k = 17, maxPts = 10

**Execution:**
1. Check base cases: 17 + 10 > 21 ‚Üí proceed
2. Initialize window sum for points 17-26:
   - Count 1.0 for 17-21 (5 values)
   - Window sum = 5.0
3. Backward calculation:
   - dp[16] = 5.0/10 = 0.5
   - Update window sum: 5.0 + 0.5 - 1.0 = 4.5
   - Continue until dp[0]
4. Final result: dp[0] ‚âà 0.73278

## üí° Key Features
- **Efficient Probability Calculation**: Sliding window maintains running sum
- **Base Case Optimization**: Early return for certain conditions
- **Backward DP**: Computes probabilities from end to start
- **Space Optimization**: Uses array instead of map for better performance

## üöÄ When to Use
- Probability calculation problems
- Games with stopping conditions
- When current state depends on future states
- Problems with sliding window applications

## ‚ö†Ô∏è Edge Cases
- **k = 0**: Always return 1.0
- **maxPts = 1**: Simple binary probability
- **n = k**: Must draw exactly k points
- **Large maxPts**: Handled by window mechanism

## üõ† Variations
1. **Forward DP**:
```java
// Calculate probabilities from start to end
```

2. **Space Optimized**:
```java
// Use circular buffer to reduce space
```

3. **Precision Control**:
```java
// Handle very small probabilities
```

4. **Memoization**:
```java
// Recursive solution with memoization
```

5. **Visualization**:
```java
// Print probability distribution
```

## Mathematical Insight
The solution leverages:
- Law of total probability
- Markov property (current state depends only on previous states)
- Sliding window technique
- Dynamic programming principles

## Alternative Implementation (Forward DP)
```java
class Solution {
    public double new21Game(int n, int k, int maxPts) {
        if (k == 0 || n >= k + maxPts) return 1.0;
        
        double[] dp = new double[n + 1];
        dp[0] = 1.0;
        double windowSum = 1.0, res = 0.0;
        
        for (int i = 1; i <= n; i++) {
            dp[i] = windowSum / maxPts;
            if (i < k) windowSum += dp[i];
            else res += dp[i];
            if (i >= maxPts) windowSum -= dp[i - maxPts];
        }
        return res;
    }
}
```
Note: This forward version computes probabilities from 0 to n but may be less intuitive. The backward solution better matches the problem's stopping condition logic.