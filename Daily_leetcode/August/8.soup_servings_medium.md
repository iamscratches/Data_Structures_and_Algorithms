# 🍜 Soup Servings - Dynamic Programming with Memoization

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/soup-servings/description/?envType=daily-question&envId=2025-08-08)

Given:
- Two types of soup (A and B) with initial volumes `n` ml each
- Four serving operations (each with 25% probability):
  1. Serve 100ml of A and 0ml of B
  2. Serve 75ml of A and 25ml of B
  3. Serve 50ml of A and 50ml of B
  4. Serve 25ml of A and 75ml of B

Find:
The probability that soup A will be empty first, plus half the probability that both soups become empty at the same time.

**Constraints:**
- 0 ≤ n ≤ 10⁹

**Example:**
```text
Input: n = 50
Output: 0.625
Explanation:
All possible outcomes:
1. Serve 100ml A → A empty first (probability 0.25)
2. Serve 75ml A and 25ml B → leads to base cases
3. Serve 50ml A and 50ml B → both empty (probability 0.25 * 0.5)
4. Serve 25ml A and 75ml B → B empty first
Total probability = 0.25 + (0.25 * 0.5) = 0.375 → Need correction
```

## 🧠 Intuition
The solution uses:
1. **Memoization**: Caches computed probabilities to avoid redundant calculations
2. **Base Cases**: Handles terminal states (empty soups) with defined probabilities
3. **Probability Aggregation**: Combines results from all possible operations
4. **Optimization**: Returns 1.0 for large n (empirical observation)

Key Insights:
- Recursive breakdown of all possible serving sequences
- Memoization drastically reduces computation time
- For n > 4800, probability approaches 1.0 within acceptable error

## ⚙️ Approach
1. **Base Case Handling**:
   - A empty first → return 1.0
   - Both empty → return 0.5
   - B empty first → return 0.0
2. **Memoization Check**:
   - Return cached result if available
3. **Recursive Calculation**:
   - Compute probabilities for all four operations
   - Combine with equal 25% weighting
4. **Large n Optimization**:
   - Return 1.0 immediately for n > 4800

## ✅ Optimized Solution
```java
class Solution {
    public double soupServings(int n) {
        // Optimization for large n (probability approaches 1.0)
        if (n > 4800) {
            return 1.0;
        }
        
        // Initialize memoization table with -1 (uncomputed)
        double[][] dp = new double[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= n; j++) {
                dp[i][j] = -1;
            }
        }
        
        return computeProbability(n, n, dp);
    }
    
    private double computeProbability(int a, int b, double[][] dp) {
        // Base cases
        if (a <= 0 && b > 0) return 1.0;    // A empty first
        if (a <= 0 && b <= 0) return 0.5;    // Both empty simultaneously
        if (a > 0 && b <= 0) return 0.0;     // B empty first
        
        // Return cached result if available
        if (dp[a][b] != -1) {
            return dp[a][b];
        }
        
        // Recursively compute all possible operations
        double prob = 0.25 * (computeProbability(a - 100, b, dp) +
                      0.25 * (computeProbability(a - 75, b - 25, dp) +
                      0.25 * (computeProbability(a - 50, b - 50, dp) +
                      0.25 * (computeProbability(a - 25, b - 75, dp));
        
        // Cache and return result
        return dp[a][b] = prob;
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n²)      | Due to memoization table of size n×n |
| **Space**       | O(n²)      | For storing the DP table |

## 📊 Example Walkthrough
**Input:** n = 50

**Execution:**
1. computeProbability(50, 50):
   - Try all 4 operations (recursive calls):
     - (50-100=-50, 50) → returns 1.0 (A empty)
     - (50-75=-25, 50-25=25) → returns 1.0 (A empty)
     - (50-50=0, 50-50=0) → returns 0.5 (both empty)
     - (50-25=25, 50-75=-25) → returns 0.0 (B empty)
   - Combined: 0.25*(1 + 1 + 0.5 + 0) = 0.625
2. Final result: 0.625

## 💡 Key Features
- **Efficient Memoization**: Avoids redundant calculations
- **Clear Base Cases**: Well-defined termination conditions
- **Probability Combination**: Properly weights all operations
- **Large n Optimization**: Handles edge case efficiently

## 🚀 When to Use
- Probability calculation problems
- Recursive problems with overlapping subproblems
- When exact results can be approximated for large inputs
- Problems with multiple decision branches

## ⚠️ Edge Cases
- **n = 0**: Returns 0.5 (both empty immediately)
- **Very Large n**: Returns 1.0 (optimization)
- **Single Operation**: Small n values
- **Equal Consumption**: When operations empty both soups

## 🛠 Variations
1. **Iterative DP**:
```java
// Bottom-up dynamic programming approach
```

2. **Space Optimization**:
```java
// Use rolling array to reduce space complexity
```

3. **Probability Threshold**:
```java
// Early termination when probability stabilizes
```

4. **Visualization**:
```java
// Print probability matrix for debugging
```

5. **Monte Carlo Simulation**:
```java
// Alternative approach for verification
```

## Mathematical Insight
The solution leverages:
- Recursive probability decomposition
- Law of total probability
- Memoization for efficiency
- Convergence properties for large n

## Alternative Implementation (Iterative DP)
```java
class Solution {
    public double soupServings(int n) {
        if (n > 4800) return 1.0;
        n = (n + 24) / 25; // Convert to 25ml units
        double[][] dp = new double[n+1][n+1];
        
        for (int a = 0; a <= n; a++) {
            for (int b = 0; b <= n; b++) {
                if (a == 0 && b > 0) dp[a][b] = 1.0;
                else if (a == 0 && b == 0) dp[a][b] = 0.5;
                else if (a > 0 && b == 0) dp[a][b] = 0.0;
                else if (a > 0 && b > 0) {
                    dp[a][b] = 0.25 * (dp[Math.max(0, a-4)][b] +
                                     dp[Math.max(0, a-3)][Math.max(0, b-1)] +
                                     dp[Math.max(0, a-2)][Math.max(0, b-2)] +
                                     dp[Math.max(0, a-1)][Math.max(0, b-3)]);
                }
            }
        }
        return dp[n][n];
    }
}
```
Note: This version uses bottom-up DP and unit conversion for potentially better performance, though the recursive solution is more intuitive.