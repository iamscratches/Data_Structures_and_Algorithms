# üß© Sudoku Solver - Backtracking with Constraint Propagation

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/sudoku-solver/?envType=daily-question&envId=2025-08-31)

Given:
- A 9√ó9 Sudoku board partially filled with digits (1-9) and empty cells ('.')

Task:
- Solve the Sudoku puzzle by filling all empty cells following Sudoku rules:
  1. Each row must contain digits 1-9 without repetition
  2. Each column must contain digits 1-9 without repetition
  3. Each 3√ó3 sub-box must contain digits 1-9 without repetition

**Constraints:**
- board.length == 9
- board[i].length == 9
- board[i][j] is a digit 1-9 or '.'
- The input board has exactly one solution

**Example:**
```text
Input: board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]

Output: Solved board with all empty cells filled
```

## üß† Intuition
The solution uses:
1. **Backtracking Algorithm**: Systematically tries all possible digits for empty cells
2. **Constraint Propagation**: Tracks used digits in rows, columns, and boxes using bit masks
3. **Recursive DFS**: Explores possible solutions depth-first
4. **Early Pruning**: Eliminates invalid choices using constraint checks

Key Insights:
- Maintain three 9√ó9 arrays to track used digits in rows, columns, and boxes
- Convert cell coordinates to box index: `(i/3)*3 + j/3`
- Use 0-indexed digit tracking (digit-1 maps to index 0-8)
- Backtrack when no valid digit found for a cell

## ‚öôÔ∏è Approach
1. **Initialization**:
   - Precompute initial state of rows, columns, and boxes from given board
   - Mark pre-filled digits as used in corresponding constraints
2. **Recursive Solving**:
   - Process cells in row-major order (index 0 to 80)
   - Skip pre-filled cells
   - For empty cells, try digits 1-9 that satisfy all constraints
   - Recursively solve remaining cells
   - Backtrack if current digit leads to dead end
3. **Termination**: When all 81 cells are processed (index=81)

## ‚úÖ Optimized Solution
```java
class Solution {
    public void solveSudoku(char[][] board) {
        int[][] row = new int[9][9];  // row[i][d] = 1 if digit d+1 used in row i
        int[][] col = new int[9][9];  // col[j][d] = 1 if digit d+1 used in column j
        int[][] box = new int[9][9];  // box[b][d] = 1 if digit d+1 used in box b
        
        // Initialize constraints from given board
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') {
                    int digit = board[i][j] - '1';  // Convert to 0-8 index
                    int boxIndex = (i / 3) * 3 + (j / 3);
                    row[i][digit] = 1;
                    col[j][digit] = 1;
                    box[boxIndex][digit] = 1;
                }
            }
        }
        
        solve(board, row, col, box, 0);
    }
    
    private boolean solve(char[][] board, int[][] row, int[][] col, int[][] box, int index) {
        if (index == 81) return true;  // All cells filled
        
        int i = index / 9, j = index % 9;  // Convert index to coordinates
        int boxIndex = (i / 3) * 3 + (j / 3);
        
        // Skip pre-filled cells
        if (board[i][j] != '.') {
            return solve(board, row, col, box, index + 1);
        }
        
        // Try digits 1-9
        for (int digit = 0; digit < 9; digit++) {
            if (row[i][digit] == 0 && col[j][digit] == 0 && box[boxIndex][digit] == 0) {
                // Place digit
                board[i][j] = (char) ('1' + digit);
                row[i][digit] = 1;
                col[j][digit] = 1;
                box[boxIndex][digit] = 1;
                
                // Recursively solve next cell
                if (solve(board, row, col, box, index + 1)) {
                    return true;
                }
                
                // Backtrack
                board[i][j] = '.';
                row[i][digit] = 0;
                col[j][digit] = 0;
                box[boxIndex][digit] = 0;
            }
        }
        
        return false;  // No valid digit found
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(9^(n))   | Worst case, but heavily pruned by constraints |
| **Space**       | O(1)       | Fixed-size auxiliary arrays |

## üìä Example Walkthrough
**Solving cell (0,2):**
- Empty cell, try digits 1-9
- Check constraints: row 0 has [5,3,7], column 2 has [8], box 0 has [5,3,6,9,8]
- Valid digits: 1,2,4 ‚Üí try 1
- Update constraints and proceed to next cell
- If leads to solution, return true; else backtrack and try 2, then 4

## üí° Key Features
- **Efficient Constraint Checking**: O(1) digit validation
- **Systematic Backtracking**: Guaranteed to find solution
- **Memory Efficient**: Uses simple 2D arrays for constraints
- **Clean State Management**: Proper backtracking with state reset

## üöÄ When to Use
- Constraint satisfaction problems
- When exhaustive search with pruning is needed
- Problems with well-defined constraints
- Puzzle solving algorithms

## ‚ö†Ô∏è Edge Cases
- **Already Solved Board**: Returns immediately
- **Single Empty Cell**: Quickly filled with valid digit
- **Multiple Solutions**: Finds first valid solution (problem guarantees exactly one)
- **Hard Puzzles**: Handles difficult Sudoku configurations

## üõ† Variations
1. **Most Constrained First**:
```java
// Choose cell with fewest possible digits first
```

2. **Forward Checking**:
```java
// Propagate constraints more aggressively
```

3. **Bit Mask Optimization**:
```java
// Use integer bit masks instead of 2D arrays
```

4. **Parallel Solving**:
```java
// Explore different branches in parallel
```

5. **Visualization**:
```java
// Print solving progress
```

## Mathematical Insight
The solution leverages:
- Backtracking algorithm principles
- Constraint propagation techniques
- Combinatorial search optimization
- Recursive problem decomposition

## Alternative Implementation (Bit Masks)
```java
class Solution {
    public void solveSudoku(char[][] board) {
        int[] rows = new int[9], cols = new int[9], boxes = new int[9];
        
        // Initialize constraints
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') {
                    int digit = board[i][j] - '1';
                    int mask = 1 << digit;
                    int boxIndex = (i/3)*3 + j/3;
                    rows[i] |= mask;
                    cols[j] |= mask;
                    boxes[boxIndex] |= mask;
                }
            }
        }
        solve(board, rows, cols, boxes, 0);
    }
    
    private boolean solve(char[][] board, int[] rows, int[] cols, int[] boxes, int index) {
        if (index == 81) return true;
        int i = index/9, j = index%9;
        if (board[i][j] != '.') return solve(board, rows, cols, boxes, index+1);
        
        int boxIndex = (i/3)*3 + j/3;
        int used = rows[i] | cols[j] | boxes[boxIndex];
        
        for (int digit = 0; digit < 9; digit++) {
            int mask = 1 << digit;
            if ((used & mask) == 0) {
                board[i][j] = (char)('1' + digit);
                rows[i] |= mask;
                cols[j] |= mask;
                boxes[boxIndex] |= mask;
                
                if (solve(board, rows, cols, boxes, index+1)) return true;
                
                board[i][j] = '.';
                rows[i] &= ~mask;
                cols[j] &= ~mask;
                boxes[boxIndex] &= ~mask;
            }
        }
        return false;
    }
}
```
Note: This version uses bit masks for more efficient constraint storage and checking. The original 2D array solution is more readable for understanding the concept.