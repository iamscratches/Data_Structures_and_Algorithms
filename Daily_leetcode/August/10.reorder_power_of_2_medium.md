# üî¢ Reordered Power of 2 - Frequency Counting Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/reordered-power-of-2/description/?envType=daily-question&envId=2025-08-10)

Given:
- A positive integer `n`

Determine:
If we can reorder the digits of `n` to form a power of two (including leading zeros, though the problem likely excludes this)

**Constraints:**
- 1 ‚â§ n ‚â§ 10‚Åπ

**Example:**
```text
Input: n = 46
Output: true
Explanation: 64 is a power of 2 (2‚Å∂) and can be formed by reordering 46
```

## üß† Intuition
The solution uses:
1. **Precomputation**: Generates all possible powers of 2 up to 2¬≥‚Å∞
2. **Digit Frequency**: Compares digit counts rather than exact numbers
3. **Normalization**: Converts numbers to sorted digit strings for easy comparison
4. **Efficient Lookup**: Checks against precomputed power-of-2 digit patterns

Key Insights:
- Two numbers are digit rearrangements if they have identical digit frequencies
- Only need to check powers of 2 within the same digit length
- Preprocessing enables O(1) lookups for each query

## ‚öôÔ∏è Approach
1. **Precompute Powers**:
   - Generate all powers of 2 from 2‚Å∞ to 2¬≥‚Å∞
   - Convert each to its digit frequency signature
2. **Process Input**:
   - Convert input number to its digit frequency signature
3. **Comparison**:
   - Check if input's signature matches any power-of-2 signature

## ‚úÖ Optimized Solution
```java
class Solution {
    // Precomputed digit frequency signatures for all powers of 2 up to 2^30
    String[] powerOfTwoSignatures = new String[31];
    
    public boolean reorderedPowerOf2(int n) {
        // Precompute all power-of-2 signatures
        int power = 1;
        for (int i = 0; i < 31; i++) {
            powerOfTwoSignatures[i] = getDigitSignature(power);
            power <<= 1;
        }
        
        // Get signature of input number
        String inputSignature = getDigitSignature(n);
        
        // Check against all power-of-2 signatures
        for (String signature : powerOfTwoSignatures) {
            if (signature.equals(inputSignature)) {
                return true;
            }
        }
        return false;
    }
    
    // Generates a sorted string of digits representing the number's digit frequency
    private String getDigitSignature(int num) {
        int[] digitCounts = new int[10];
        while (num > 0) {
            digitCounts[num % 10]++;
            num /= 10;
        }
        
        StringBuilder signature = new StringBuilder();
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < digitCounts[i]; j++) {
                signature.append(i);
            }
        }
        return signature.toString();
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Preprocessing Time** | O(1) | Fixed 31 powers to process |
| **Query Time** | O(1) | Constant-time signature comparison |
| **Space** | O(1) | Fixed storage for 31 signatures |

## üìä Example Walkthrough
**Input:** n = 46

**Execution:**
1. Precompute signatures for all 2‚Å∞ to 2¬≥‚Å∞:
   - 1 ‚Üí "1"
   - 2 ‚Üí "2"
   - 4 ‚Üí "4"
   - ...
   - 64 ‚Üí "46" (sorted digits)
2. Generate input signature:
   - 46 ‚Üí digits [4,6] ‚Üí sorted "46"
3. Compare with precomputed signatures:
   - Matches 64's signature "46" ‚Üí return true

## üí° Key Features
- **Efficient Preprocessing**: One-time computation for all queries
- **Digit Frequency Matching**: Robust against digit reordering
- **Constant-Time Query**: Fast lookup after preprocessing
- **Numerical to String Conversion**: Enables easy comparison

## üöÄ When to Use
- Digit permutation problems
- When preprocessing is acceptable
- Problems involving number properties
- When comparing digit distributions

## ‚ö†Ô∏è Edge Cases
- **n = 1**: Smallest power of 2
- **n = 10‚Åπ**: Maximum input value
- **Numbers with duplicate digits**: e.g., 112
- **Leading zeros**: Not allowed in this problem

## üõ† Variations
1. **Array Comparison**:
```java
// Compare digit count arrays directly instead of strings
```

2. **Prime Factorization**:
```java
// Alternative approach using prime factors (less efficient)
```

3. **Bitmask Representation**:
```java
// Encode digit frequencies as bit patterns
```

4. **On-the-Fly Generation**:
```java
// Generate powers of 2 only up to n's digit length
```

5. **Parallel Preprocessing**:
```java
// Use multiple threads to generate signatures
```

## Mathematical Insight
The solution leverages:
- Digit frequency distributions
- Properties of powers of two
- String representations for easy comparison
- Precomputation for efficiency

## Alternative Implementation (Array Comparison)
```java
class Solution {
    public boolean reorderedPowerOf2(int n) {
        int[] inputDigits = countDigits(n);
        for (int i = 0; i < 31; i++) {
            if (Arrays.equals(inputDigits, countDigits(1 << i))) {
                return true;
            }
        }
        return false;
    }
    
    private int[] countDigits(int num) {
        int[] counts = new int[10];
        while (num > 0) {
            counts[num % 10]++;
            num /= 10;
        }
        return counts;
    }
}
```
Note: This version compares digit count arrays directly, avoiding string conversions. The string version may be more readable for some.