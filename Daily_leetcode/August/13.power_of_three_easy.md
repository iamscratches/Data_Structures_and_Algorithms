# 3️⃣ Power of Three - Iterative Division Approach

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/power-of-three/description/?envType=daily-question&envId=2025-08-13)

Given:
- An integer `n`

Determine:
If `n` is a power of three (i.e., can be expressed as 3ᵏ where k is an integer)

**Constraints:**
- -2³¹ ≤ n ≤ 2³¹ - 1

**Example:**
```text
Input: n = 27
Output: true
Explanation: 27 = 3³

Input: n = 45
Output: false
Explanation: No integer k exists such that 3ᵏ = 45
```

## 🧠 Intuition
The solution uses:
1. **Early Negative Check**: Immediately eliminates negative numbers
2. **Division by Three**: Repeatedly divides the number by 3 while divisible
3. **Termination Condition**: Checks if final result is 1 (3⁰)

Key Insights:
- All powers of three have only one '1' in their base-3 representation
- Negative numbers cannot be powers of three
- Zero is not a power of three

## ⚙️ Approach
1. **Edge Case Handling**:
   - Return false for non-positive numbers
2. **Division Loop**:
   - While n ≠ 1, check divisibility by 3
   - If not divisible, return false
3. **Final Check**:
   - Return true if loop completes (n == 1)

## ✅ Optimized Solution
```java
class Solution {
    public boolean isPowerOfThree(int n) {
        // Handle edge cases (non-positive numbers)
        if (n <= 0) {
            return false;
        }
        
        // Continuously divide by 3 while divisible
        while (n != 1) {
            if (n % 3 != 0) {
                return false;
            }
            n /= 3;
        }
        
        return true;
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(log₃n)   | Worst case requires log₃n divisions |
| **Space**       | O(1)       | Constant space used |

## 📊 Example Walkthrough
**Input:** n = 27

**Execution:**
1. n = 27 (positive, proceed)
2. 27 % 3 = 0 → n = 9
3. 9 % 3 = 0 → n = 3
4. 3 % 3 = 0 → n = 1
5. Final check: n == 1 → true

**Input:** n = 45
1. n = 45 (positive, proceed)
2. 45 % 3 = 0 → n = 15
3. 15 % 3 = 0 → n = 5
4. 5 % 3 ≠ 0 → return false

## 💡 Key Features
- **Simple Implementation**: Easy to understand and verify
- **Efficient**: Logarithmic time complexity
- **Early Termination**: Exits at first non-divisible case
- **Clear Logic**: Directly follows mathematical definition

## 🚀 When to Use
- Checking power properties
- Number property verification
- When simplicity is preferred over bit tricks
- Problems involving base-3 numbers

## ⚠️ Edge Cases
- **n = 0**: Returns false
- **n = 1**: Returns true (3⁰)
- **Negative numbers**: Immediately returns false
- **Large powers**: Handles up to 3¹⁹ (within int range)

## 🛠 Variations
1. **Mathematical Approach**:
```java
return n > 0 && (Math.log10(n)/Math.log10(3)) % 1 == 0;
```

2. **Base Conversion**:
```java
// Check if base-3 representation is 1 followed by 0s
```

3. **Integer Limitations**:
```java
// For constrained inputs, check against largest power
```

4. **Recursive Version**:
```java
if (n == 1) return true;
if (n % 3 != 0 || n == 0) return false;
return isPowerOfThree(n/3);
```

5. **Bit Manipulation**:
```java
// Not applicable (works for powers of 2)
```

## Mathematical Insight
The solution leverages:
- Fundamental theorem of arithmetic
- Properties of exponents
- Division as inverse of multiplication
- Base-3 representation properties

## Alternative Implementation (Logarithmic)
```java
class Solution {
    public boolean isPowerOfThree(int n) {
        // Logarithmic approach (may have precision issues)
        return n > 0 && (Math.log10(n) / Math.log10(3)) % 1 == 0;
    }
}
```
Note: This version is concise but may have floating-point precision issues. The iterative solution is more reliable.