# 🧺 Fruits Into Baskets III - Segment Tree Approach

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/fruits-into-baskets-iii/description/?envType=daily-question&envId=2025-08-06)

Given:
- An array `fruits` representing fruit sizes
- An array `baskets` representing basket capacities

Find:
The number of fruits that cannot be placed in any basket following these rules:
1. Each basket can hold at most one fruit
2. A fruit can only be placed in a basket with equal or greater capacity
3. Once a basket is used, it cannot be reused

**Constraints:**
- 1 ≤ fruits.length, baskets.length ≤ 10⁵
- 1 ≤ fruits[i], baskets[i] ≤ 10⁹

**Example:**
```text
Input: fruits = [2,3,4], baskets = [3,3,3]
Output: 1
Explanation:
- Fruit 2 placed in basket (capacity 3)
- Fruit 3 placed in another basket (capacity 3)
- Fruit 4 cannot be placed (remaining basket capacity 3)
```

## 🧠 Intuition
The solution uses:
1. **Segment Tree**: Efficient range maximum queries and point updates
2. **Greedy Placement**: Always uses the smallest suitable basket first
3. **Dynamic Updates**: Marks used baskets by setting capacity to 0
4. **Efficient Search**: Finds first basket with sufficient capacity in O(log n) time

Key Insights:
- Segment tree enables efficient maximum capacity queries
- Greedy strategy minimizes unplaced fruits
- Optimal basket selection reduces wasted capacity

## ⚙️ Approach
1. **Build Segment Tree**:
   - Construct tree to track maximum basket capacities
2. **Process Fruits**:
   - For each fruit, find first basket with sufficient capacity
   - Mark used baskets by setting capacity to 0
3. **Count Unplaced Fruits**:
   - Increment count when no suitable basket found
4. **Return Result**: Total unplaced fruits count

## ✅ Optimized Solution
```java
class Solution {
    int n;
    int[] seg;
    
    // Update segment tree node with max of children
    void Update(int p) { 
        seg[p] = Math.max(seg[p << 1], seg[p << 1 | 1]); 
    }
    
    // Build segment tree recursively
    void Build(int p, int l, int r, int[] baskets) {
        if (l == r) {
            seg[p] = baskets[l];
            return;
        }
        int mid = (l + r) >> 1;
        Build(p << 1, l, mid, baskets);
        Build(p << 1 | 1, mid + 1, r, baskets);
        Update(p);
    }
    
    // Assign new value to basket position
    void Assign(int x, int v, int p, int l, int r) {
        if (x < l || x > r) return;
        if (l == r) {
            seg[p] = v;
            return;
        }
        int mid = (l + r) >> 1;
        Assign(x, v, p << 1, l, mid);
        Assign(x, v, p << 1 | 1, mid + 1, r);
        Update(p);
    }
    
    // Find first basket with capacity ≥ v
    int FirstLarger(int v, int p, int l, int r) {
        if (seg[p] < v) return r + 1; // Not found
        if (l == r) return r;         // Found
        
        int mid = (l + r) >> 1;
        int lf = FirstLarger(v, p << 1, l, mid);
        if (lf <= mid) return lf;     // Found in left subtree
        
        return FirstLarger(v, p << 1 | 1, mid + 1, r); // Search right
    }
    
    public int numOfUnplacedFruits(int[] fruits, int[] baskets) {
        n = baskets.length;
        seg = new int[4 * n + 1];     // Segment tree array
        Build(1, 0, n - 1, baskets);  // Build tree
        
        int res = 0;
        for (int x : fruits) {
            int pos = FirstLarger(x, 1, 0, n - 1);
            if (pos == n) {
                res++;  // No basket found
            } else {
                Assign(pos, 0, 1, 0, n - 1); // Mark basket as used
            }
        }
        return res;
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity       | Description |
|-----------------|------------------|-------------|
| **Time**        | O(n log n)       | Building tree + m queries |
| **Space**       | O(n)             | Segment tree storage |

## 📊 Example Walkthrough
**Input:** fruits = [2,3,4], baskets = [3,3,3]

**Execution:**
1. Build segment tree tracking [3,3,3] max capacities
2. Process fruit 2:
   - Find first basket ≥2 at position 0
   - Mark basket 0 as used (set to 0)
3. Process fruit 3:
   - Find next basket ≥3 at position 1
   - Mark basket 1 as used
4. Process fruit 4:
   - No baskets ≥4 remaining
   - Increment unplaced count
5. Final result: 1

## 💡 Key Features
- **Efficient Queries**: O(log n) basket search
- **Optimal Placement**: Uses smallest suitable basket first
- **Dynamic Updates**: Real-time basket availability tracking
- **Scalable**: Handles large input sizes efficiently

## 🚀 When to Use
- Problems requiring range queries and updates
- Resource allocation with dynamic availability
- When greedy strategies are optimal
- Large input size constraints

## ⚠️ Edge Cases
- **Empty Baskets**: All fruits unplaced
- **Large Fruits**: None can be placed
- **Identical Capacities**: All baskets equal
- **Single Basket**: Only one fruit placed

## 🛠 Variations
1. **Sorting + Binary Search**:
```java
// Alternative O(n log n) solution
```

2. **Priority Queue**:
```java
// Heap-based implementation
```

3. **Coordinate Compression**:
```java
// For large value ranges
```

4. **Parallel Processing**:
```java
// For very large inputs
```

5. **Visualization**:
```java
// Print tree structure for debugging
```

## Mathematical Insight
The solution leverages:
- Segment tree properties for range queries
- Greedy algorithm optimality
- Binary search efficiency
- In-place updates for dynamic tracking

## Alternative Implementation (Sorting)
```java
class Solution {
    public int numOfUnplacedFruits(int[] fruits, int[] baskets) {
        Arrays.sort(fruits);
        Arrays.sort(baskets);
        
        int res = 0;
        int j = 0;
        
        for (int fruit : fruits) {
            while (j < baskets.length && baskets[j] < fruit) {
                j++;
            }
            if (j < baskets.length) {
                j++;
            } else {
                res++;
            }
        }
        return res;
    }
}
```
Note: This sorting-based solution has the same time complexity but may be more cache-friendly. The segment tree approach is more flexible for dynamic scenarios.