# ⚡ Power of Two - Iterative Division Approach

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/power-of-two/description/?envType=daily-question&envId=2025-08-09)

Given:
- An integer `n`

Determine:
If `n` is a power of two (i.e., can be expressed as 2ˣ where x is a non-negative integer)

**Constraints:**
- -2³¹ ≤ n ≤ 2³¹ - 1

**Example:**
```text
Input: n = 16
Output: true
Explanation: 16 = 2⁴

Input: n = 3
Output: false
Explanation: No integer x exists such that 2ˣ = 3
```

## 🧠 Intuition
The solution uses:
1. **Early Negative Check**: Immediately eliminates negative numbers
2. **Division by Two**: Repeatedly divides the number by 2 while it's even
3. **Final Check**: Verifies if the remaining number is 1 (2⁰)

Key Insights:
- All powers of two have exactly one '1' bit in binary representation
- Negative numbers cannot be powers of two
- Zero is not a power of two

## ⚙️ Approach
1. **Handle Edge Cases**:
   - Return false for non-positive numbers
2. **Division Loop**:
   - While the number is even, keep dividing by 2
3. **Final Verification**:
   - Check if the remaining number equals 1

## ✅ Optimized Solution
```java
class Solution {
    public boolean isPowerOfTwo(int n) {
        // Handle edge cases (non-positive numbers)
        if (n <= 0) {
            return false;
        }
        
        // Continuously divide by 2 while even
        while (n % 2 == 0) {
            n /= 2;
        }
        
        // Check if final result is 1 (2^0)
        return n == 1;
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(log n)   | Worst case requires log₂n divisions |
| **Space**       | O(1)       | Constant space used |

## 📊 Example Walkthrough
**Input:** n = 16

**Execution:**
1. n = 16 (positive, proceed)
2. 16 % 2 = 0 → n = 8
3. 8 % 2 = 0 → n = 4
4. 4 % 2 = 0 → n = 2
5. 2 % 2 = 0 → n = 1
6. Final check: n == 1 → true

**Input:** n = 3
1. n = 3 (positive, proceed)
2. 3 % 2 ≠ 0 → exit loop
3. Final check: 3 != 1 → false

## 💡 Key Features
- **Simple Implementation**: Easy to understand and verify
- **Efficient**: Logarithmic time complexity
- **Early Termination**: Stops at first odd number
- **Clear Logic**: Directly follows mathematical definition

## 🚀 When to Use
- Checking power properties
- Number property verification
- Bit manipulation precursor
- When simplicity is preferred over bit tricks

## ⚠️ Edge Cases
- **n = 0**: Returns false
- **n = 1**: Returns true (2⁰)
- **Negative numbers**: Immediately returns false
- **Large powers**: Handles up to 2³⁰ (within int range)

## 🛠 Variations
1. **Bit Manipulation**:
```java
return n > 0 && (n & (n - 1)) == 0;
```

2. **Logarithmic Approach**:
```java
return n > 0 && (Math.log10(n)/Math.log10(2)) % 1 == 0;
```

3. **Precomputed Set**:
```java
// For repeated queries, store powers of two
```

4. **Recursive Version**:
```java
if (n == 1) return true;
if (n % 2 != 0 || n == 0) return false;
return isPowerOfTwo(n/2);
```

5. **Bit Count**:
```java
return n > 0 && Integer.bitCount(n) == 1;
```

## Mathematical Insight
The solution leverages:
- Fundamental theorem of arithmetic
- Properties of exponents
- Division as inverse of multiplication
- Binary representation patterns

## Alternative Implementation (Bit Manipulation)
```java
class Solution {
    public boolean isPowerOfTwo(int n) {
        // Powers of two have exactly one '1' bit
        // n & (n-1) clears the least significant '1' bit
        return n > 0 && (n & (n - 1)) == 0;
    }
}
```
Note: This bit manipulation version is more efficient (O(1) time) but less intuitive. The iterative solution better demonstrates the mathematical concept.