# âš¡ Power of Two - Iterative Division Approach

## ğŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/power-of-two/description/?envType=daily-question&envId=2025-08-09)

Given:
- An integer `n`

Determine:
If `n` is a power of two (i.e., can be expressed as 2Ë£ where x is a non-negative integer)

**Constraints:**
- -2Â³Â¹ â‰¤ n â‰¤ 2Â³Â¹ - 1

**Example:**
```text
Input: n = 16
Output: true
Explanation: 16 = 2â´

Input: n = 3
Output: false
Explanation: No integer x exists such that 2Ë£ = 3
```

## ğŸ§  Intuition
The solution uses:
1. **Early Negative Check**: Immediately eliminates negative numbers
2. **Division by Two**: Repeatedly divides the number by 2 while it's even
3. **Final Check**: Verifies if the remaining number is 1 (2â°)

Key Insights:
- All powers of two have exactly one '1' bit in binary representation
- Negative numbers cannot be powers of two
- Zero is not a power of two

## âš™ï¸ Approach
1. **Handle Edge Cases**:
   - Return false for non-positive numbers
2. **Division Loop**:
   - While the number is even, keep dividing by 2
3. **Final Verification**:
   - Check if the remaining number equals 1

## âœ… Optimized Solution
```java
class Solution {
    public boolean isPowerOfTwo(int n) {
        // Handle edge cases (non-positive numbers)
        if (n <= 0) {
            return false;
        }
        
        // Continuously divide by 2 while even
        while (n % 2 == 0) {
            n /= 2;
        }
        
        // Check if final result is 1 (2^0)
        return n == 1;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(log n)   | Worst case requires logâ‚‚n divisions |
| **Space**       | O(1)       | Constant space used |

## ğŸ“Š Example Walkthrough
**Input:** n = 16

**Execution:**
1. n = 16 (positive, proceed)
2. 16 % 2 = 0 â†’ n = 8
3. 8 % 2 = 0 â†’ n = 4
4. 4 % 2 = 0 â†’ n = 2
5. 2 % 2 = 0 â†’ n = 1
6. Final check: n == 1 â†’ true

**Input:** n = 3
1. n = 3 (positive, proceed)
2. 3 % 2 â‰  0 â†’ exit loop
3. Final check: 3 != 1 â†’ false

## ğŸ’¡ Key Features
- **Simple Implementation**: Easy to understand and verify
- **Efficient**: Logarithmic time complexity
- **Early Termination**: Stops at first odd number
- **Clear Logic**: Directly follows mathematical definition

## ğŸš€ When to Use
- Checking power properties
- Number property verification
- Bit manipulation precursor
- When simplicity is preferred over bit tricks

## âš ï¸ Edge Cases
- **n = 0**: Returns false
- **n = 1**: Returns true (2â°)
- **Negative numbers**: Immediately returns false
- **Large powers**: Handles up to 2Â³â° (within int range)

## ğŸ›  Variations
1. **Bit Manipulation**:
```java
return n > 0 && (n & (n - 1)) == 0;
```

2. **Logarithmic Approach**:
```java
return n > 0 && (Math.log10(n)/Math.log10(2)) % 1 == 0;
```

3. **Precomputed Set**:
```java
// For repeated queries, store powers of two
```

4. **Recursive Version**:
```java
if (n == 1) return true;
if (n % 2 != 0 || n == 0) return false;
return isPowerOfTwo(n/2);
```

5. **Bit Count**:
```java
return n > 0 && Integer.bitCount(n) == 1;
```

## Mathematical Insight
The solution leverages:
- Fundamental theorem of arithmetic
- Properties of exponents
- Division as inverse of multiplication
- Binary representation patterns

## Alternative Implementation (Bit Manipulation)
```java
class Solution {
    public boolean isPowerOfTwo(int n) {
        // Powers of two have exactly one '1' bit
        // n & (n-1) clears the least significant '1' bit
        return n > 0 && (n & (n - 1)) == 0;
    }
}
```
Note: This bit manipulation version is more efficient (O(1) time) but less intuitive. The iterative solution better demonstrates the mathematical concept.