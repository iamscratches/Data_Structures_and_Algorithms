# 6Ô∏è‚É£9Ô∏è‚É£ Maximum 69 Number - Greedy Digit Replacement Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/maximum-69-number/description/?envType=daily-question&envId=2025-08-16)

Given:
- A positive integer `num` consisting only of digits 6 and 9

Find:
- The maximum number by changing at most one digit (6 ‚Üí 9 or 9 ‚Üí 6)

**Constraints:**
- 1 ‚â§ num ‚â§ 10‚Å¥
- num consists only of 6 and 9 digits

**Example:**
```text
Input: num = 9669
Output: 9969
Explanation: Changing first 6 to 9 gives the maximum number

Input: num = 9996
Output: 9999
Explanation: Changing last 6 to 9 gives the maximum number
```

## üß† Intuition
The solution uses:
1. **String Conversion**: Treats the number as a string for easy digit manipulation
2. **Greedy Replacement**: Changes the leftmost '6' to '9' for maximum impact
3. **Early Termination**: Stops after first replacement to satisfy "at most one" condition
4. **String Building**: Efficiently constructs the result string

Key Insights:
- Changing leftmost '6' yields greatest value increase
- Only one change is needed for maximum improvement
- No benefit in changing '9's to '6's

## ‚öôÔ∏è Approach
1. **Convert to String**: Enables character-level manipulation
2. **Scan Left to Right**:
   - Find first '6'
   - Replace it with '9'
3. **Construct Result**:
   - Keep digits before the change
   - Append the '9'
   - Append remaining digits unchanged
4. **Convert Back to Number**: Parse the modified string

## ‚úÖ Optimized Solution
```java
class Solution {
    public int maximum69Number(int num) {
        char[] digits = String.valueOf(num).toCharArray();
        
        // Find and replace first '6' with '9'
        for (int i = 0; i < digits.length; i++) {
            if (digits[i] == '6') {
                digits[i] = '9';
                break; // Only one replacement allowed
            }
        }
        
        return Integer.parseInt(new String(digits));
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Where n is number of digits |
| **Space**       | O(n)       | For character array storage |

## üìä Example Walkthrough
**Input:** num = 9669

**Execution:**
1. Convert to char array: ['9','6','6','9']
2. Scan digits:
   - First digit '9' ‚Üí skip
   - Second digit '6' ‚Üí change to '9'
3. Result array: ['9','9','6','9']
4. Parse to integer: 9969

**Input:** num = 9996
1. Convert to char array: ['9','9','9','6']
2. Scan digits:
   - First three digits '9' ‚Üí skip
   - Fourth digit '6' ‚Üí change to '9'
3. Result array: ['9','9','9','9']
4. Parse to integer: 9999

## üí° Key Features
- **Greedy Strategy**: Optimal single-digit replacement
- **Early Termination**: Efficient after first change
- **Simple Conversion**: String manipulation simplifies digit access
- **Clear Logic**: Easy to understand and verify

## üöÄ When to Use
- Digit manipulation problems
- When greedy approaches apply
- Problems with single-operation constraints
- Number transformation challenges

## ‚ö†Ô∏è Edge Cases
- **All 9s**: Returns original number
- **Single Digit 6**: Returns 9
- **Multiple 6s**: Only changes leftmost
- **Minimum Input**: num = 6 ‚Üí returns 9

## üõ† Variations
1. **Mathematical Approach**:
```java
// Find position of first 6 using logarithms
```

2. **Without String Conversion**:
```java
// Use division/modulo to find digits
```

3. **Rightmost Replacement**:
```java
// Alternative strategy if different rules apply
```

4. **Multiple Replacements**:
```java
// If more changes were allowed
```

5. **Visualization**:
```java
// Print digit replacement process
```

## Mathematical Insight
The solution leverages:
- Place value significance (leftmost digits matter most)
- Single-operation optimization
- String/Number conversion properties
- Greedy algorithm principles

## Alternative Implementation (Mathematical)
```java
class Solution {
    public int maximum69Number(int num) {
        int temp = num;
        int index = -1;
        int currentDigit = 0;
        
        // Find position of first 6
        while (temp > 0) {
            if (temp % 10 == 6) {
                index = currentDigit;
            }
            temp /= 10;
            currentDigit++;
        }
        
        // Add 3*10^index if 6 found
        return index == -1 ? num : num + 3 * (int)Math.pow(10, index);
    }
}
```
Note: This version avoids string conversion but may be less intuitive. The string solution is more straightforward for this problem.