# üß∫ Fruits Into Baskets II - Greedy Matching Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/fruits-into-baskets-ii/description/?envType=daily-question&envId=2025-08-05)

Given:
- An array `fruits` representing fruit sizes
- An array `baskets` representing basket capacities

Find:
The number of fruits that cannot be placed in any basket following these rules:
1. Each basket can hold at most one fruit
2. A fruit can only be placed in a basket with equal or greater capacity
3. Once a basket is used, it cannot be reused

**Constraints:**
- 1 ‚â§ fruits.length, baskets.length ‚â§ 10‚Åµ
- 1 ‚â§ fruits[i], baskets[i] ‚â§ 10‚Åπ

**Example:**
```text
Input: fruits = [2,3,4], baskets = [3,3,3]
Output: 1
Explanation:
- Fruit 2 can go in any basket
- Fruit 3 can go in remaining two baskets
- Fruit 4 cannot fit in remaining basket (capacity 3)
```

## üß† Intuition
The solution uses:
1. **Greedy Matching**: Tries to place each fruit in the smallest suitable basket
2. **Early Termination**: Stops when no suitable baskets remain
3. **Destructive Placement**: Marks used baskets to prevent reuse
4. **Linear Scanning**: Simple but effective for the problem constraints

Key Insights:
- Optimal to use baskets with smallest sufficient capacity first
- Sorting could improve efficiency but isn't necessary for small inputs
- Problem reduces to bipartite matching with capacity constraints

## ‚öôÔ∏è Approach
1. **Process Each Fruit**:
   - For each fruit, scan baskets for first suitable match
2. **Mark Used Baskets**:
   - Set basket capacity to -1 when used
3. **Count Unplaced Fruits**:
   - Increment count when no suitable basket found
4. **Return Result**: Total unplaced fruits count

## ‚úÖ Optimized Solution
```java
class Solution {
    public int numOfUnplacedFruits(int[] fruits, int[] baskets) {
        int unplacedCount = 0;
        
        for (int fruit : fruits) {
            boolean placed = false;
            
            // Try to place fruit in first suitable basket
            for (int i = 0; i < baskets.length; i++) {
                if (baskets[i] != -1 && baskets[i] >= fruit) {
                    baskets[i] = -1; // Mark basket as used
                    placed = true;
                    break;
                }
            }
            
            if (!placed) {
                unplacedCount++;
            }
        }
        
        return unplacedCount;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity       | Description |
|-----------------|------------------|-------------|
| **Time**        | O(m√ón)           | For m fruits and n baskets |
| **Space**       | O(1)             | No additional space needed |

## üìä Example Walkthrough
**Input:** fruits = [2,3,4], baskets = [3,3,3]

**Execution:**
1. Fruit 2:
   - Places in first basket (3)
   - Baskets: [-1,3,3]
2. Fruit 3:
   - Places in second basket (3)
   - Baskets: [-1,-1,3]
3. Fruit 4:
   - Cannot place in remaining basket (capacity 3)
   - unplacedCount = 1
4. Final result: 1

## üí° Key Features
- **Simple Implementation**: Easy to understand and verify
- **In-Place Modification**: Uses input array for tracking
- **Greedy Strategy**: Makes locally optimal choices
- **Early Exit**: Stops when basket is found

## üöÄ When to Use
- Resource allocation problems
- Matching problems with capacity constraints
- Small to medium input sizes
- Problems requiring simple greedy solutions

## ‚ö†Ô∏è Edge Cases
- **No Baskets**: All fruits unplaced
- **Large Fruits**: None can be placed
- **Equal Sizes**: All fruits placed if enough baskets
- **Single Basket**: Only one fruit can be placed

## üõ† Variations
1. **Sorting Optimization**:
```java
// Sort both arrays for O(m log m + n log n) solution
```

2. **TreeSet Approach**:
```java
// Use TreeSet for O(n log n) basket lookups
```

3. **Counting Sort**:
```java
// When value range is limited
```

4. **Parallel Processing**:
```java
// For very large inputs
```

5. **Visualization**:
```java
// Print placement decisions
```

## Mathematical Insight
The solution leverages:
- Greedy algorithm principles
- Bipartite matching concepts
- Resource allocation strategies
- Linear search efficiency

## Alternative Implementation (Optimized)
```java
class Solution {
    public int numOfUnplacedFruits(int[] fruits, int[] baskets) {
        Arrays.sort(fruits);
        Arrays.sort(baskets);
        
        int unplaced = 0;
        int basketPtr = 0;
        
        for (int fruit : fruits) {
            while (basketPtr < baskets.length && baskets[basketPtr] < fruit) {
                basketPtr++;
            }
            
            if (basketPtr < baskets.length) {
                basketPtr++;
            } else {
                unplaced++;
            }
        }
        
        return unplaced;
    }
}
```
Note: This optimized version sorts both arrays first for O(n log n) performance. The original solution is better for small inputs due to lower constant factors.