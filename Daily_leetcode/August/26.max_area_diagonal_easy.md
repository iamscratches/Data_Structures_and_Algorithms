# 📏 Maximum Area of Longest Diagonal Rectangle - Geometric Property Approach

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/maximum-area-of-longest-diagonal-rectangle/description/?envType=daily-question&envId=2025-08-26)

Given:
- An array `dimensions` where each element is [lengthᵢ, widthᵢ] representing a rectangle

Find:
- The maximum area among all rectangles that have the longest diagonal
- If multiple rectangles have the same longest diagonal, choose the one with maximum area

**Constraints:**
- 1 ≤ dimensions.length ≤ 1000
- dimensions[i].length == 2
- 1 ≤ dimensions[i][0], dimensions[i][1] ≤ 1000

**Example:**
```text
Input: dimensions = [[9,3],[8,6]]
Output: 48
Explanation: 
Diagonals: √(9²+3²)=√90 ≈ 9.49, √(8²+6²)=√100=10
Longest diagonal is 10 → area = 8*6=48
```

## 🧠 Intuition
The solution uses:
1. **Diagonal Calculation**: Uses Pythagorean theorem to compute diagonal length
2. **Comparison Logic**: Tracks maximum diagonal and corresponding maximum area
3. **Tie Handling**: When diagonals are equal, selects rectangle with larger area
4. **Efficient Processing**: Single pass through all rectangles

Key Insights:
- Diagonal length = √(length² + width²)
- For rectangles with equal diagonals, area = length × width determines selection
- Only need to track the current maximum diagonal and associated maximum area

## ⚙️ Approach
1. **Initialize Trackers**:
   - `maxDiagonal` = 0 (stores longest diagonal found)
   - `maxArea` = 0 (stores area of rectangle with longest diagonal)
2. **Process Each Rectangle**:
   - Calculate diagonal using Pythagorean theorem
   - Compare with current maximum diagonal
   - Update trackers if longer diagonal found
   - For equal diagonals, update area if larger
3. **Return Result**: `maxArea` after processing all rectangles

## ✅ Optimized Solution
```java
class Solution {
    public int areaOfMaxDiagonal(int[][] dimensions) {
        double maxDiagonal = 0.0;
        int maxArea = 0;
        
        for (int[] rect : dimensions) {
            int length = rect[0];
            int width = rect[1];
            
            // Calculate diagonal using Pythagorean theorem
            double diagonal = Math.sqrt(length * length + width * width);
            
            // Update if longer diagonal found
            if (diagonal > maxDiagonal) {
                maxDiagonal = diagonal;
                maxArea = length * width;
            } 
            // For equal diagonals, choose larger area
            else if (Math.abs(diagonal - maxDiagonal) < 1e-9) {
                maxArea = Math.max(maxArea, length * width);
            }
        }
        
        return maxArea;
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through all rectangles |
| **Space**       | O(1)       | Constant extra space |

## 📊 Example Walkthrough
**Input:** dimensions = [[5,12],[6,8],[3,4]]

**Execution:**
1. Rectangle [5,12]:
   - Diagonal = √(25+144)=√169=13
   - Area=60 → maxDiagonal=13, maxArea=60
2. Rectangle [6,8]:
   - Diagonal = √(36+64)=√100=10
   - 10<13 → skip
3. Rectangle [3,4]:
   - Diagonal = √(9+16)=√25=5
   - 5<13 → skip
4. Final result: 60

**Equal Diagonal Example:** [[9,12],[8,12],[12,9]]
- All have diagonal=15
- Areas: 108, 96, 108 → maxArea=108

## 💡 Key Features
- **Geometric Calculation**: Proper diagonal computation
- **Precision Handling**: Uses epsilon for floating-point comparison
- **Efficient Comparison**: Single pass with optimal comparisons
- **Clear Logic**: Easy to understand and verify

## 🚀 When to Use
- Problems involving geometric properties
- When multiple criteria need comparison (primary: diagonal, secondary: area)
- Selection problems with tie-breaking rules
- Applications requiring Pythagorean theorem

## ⚠️ Edge Cases
- **Single Rectangle**: Returns its area
- **All Equal Diagonals**: Chooses maximum area
- **Integer Overflow**: 1000² + 1000² = 2,000,000 (fits in int)
- **Floating Precision**: Uses epsilon for comparisons

## 🛠 Variations
1. **Integer Diagonal Comparison**:
```java
// Compare squared diagonals to avoid floating-point
```

2. **Custom Comparator**:
```java
// Sort rectangles by diagonal then area
```

3. **Parallel Processing**:
```java
// Process rectangles concurrently for large inputs
```

4. **Visualization**:
```java
// Print diagonal and area calculations
```

5. **Generalized for k Criteria**:
```java
// Extend to multiple selection criteria
```

## Mathematical Insight
The solution leverages:
- Pythagorean theorem properties
- Comparison of real numbers with epsilon
- Lexicographical ordering (diagonal first, then area)
- Efficient maximum tracking

## Alternative Implementation (Integer Comparison)
```java
class Solution {
    public int areaOfMaxDiagonal(int[][] dimensions) {
        int maxDiagonalSq = 0;
        int maxArea = 0;
        
        for (int[] rect : dimensions) {
            int len = rect[0], wid = rect[1];
            int diagSq = len * len + wid * wid;
            int area = len * wid;
            
            if (diagSq > maxDiagonalSq) {
                maxDiagonalSq = diagSq;
                maxArea = area;
            } else if (diagSq == maxDiagonalSq) {
                maxArea = Math.max(maxArea, area);
            }
        }
        
        return maxArea;
    }
}
```
Note: This version avoids floating-point operations by comparing squared diagonals, which is more efficient and avoids precision issues. The original solution is more mathematically intuitive but less numerically stable.