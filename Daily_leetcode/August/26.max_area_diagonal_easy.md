# ðŸ“ Maximum Area of Longest Diagonal Rectangle - Geometric Property Approach

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/maximum-area-of-longest-diagonal-rectangle/description/?envType=daily-question&envId=2025-08-26)

Given:
- An array `dimensions` where each element is [lengtháµ¢, widtháµ¢] representing a rectangle

Find:
- The maximum area among all rectangles that have the longest diagonal
- If multiple rectangles have the same longest diagonal, choose the one with maximum area

**Constraints:**
- 1 â‰¤ dimensions.length â‰¤ 1000
- dimensions[i].length == 2
- 1 â‰¤ dimensions[i][0], dimensions[i][1] â‰¤ 1000

**Example:**
```text
Input: dimensions = [[9,3],[8,6]]
Output: 48
Explanation: 
Diagonals: âˆš(9Â²+3Â²)=âˆš90 â‰ˆ 9.49, âˆš(8Â²+6Â²)=âˆš100=10
Longest diagonal is 10 â†’ area = 8*6=48
```

## ðŸ§  Intuition
The solution uses:
1. **Diagonal Calculation**: Uses Pythagorean theorem to compute diagonal length
2. **Comparison Logic**: Tracks maximum diagonal and corresponding maximum area
3. **Tie Handling**: When diagonals are equal, selects rectangle with larger area
4. **Efficient Processing**: Single pass through all rectangles

Key Insights:
- Diagonal length = âˆš(lengthÂ² + widthÂ²)
- For rectangles with equal diagonals, area = length Ã— width determines selection
- Only need to track the current maximum diagonal and associated maximum area

## âš™ï¸ Approach
1. **Initialize Trackers**:
   - `maxDiagonal` = 0 (stores longest diagonal found)
   - `maxArea` = 0 (stores area of rectangle with longest diagonal)
2. **Process Each Rectangle**:
   - Calculate diagonal using Pythagorean theorem
   - Compare with current maximum diagonal
   - Update trackers if longer diagonal found
   - For equal diagonals, update area if larger
3. **Return Result**: `maxArea` after processing all rectangles

## âœ… Optimized Solution
```java
class Solution {
    public int areaOfMaxDiagonal(int[][] dimensions) {
        double maxDiagonal = 0.0;
        int maxArea = 0;
        
        for (int[] rect : dimensions) {
            int length = rect[0];
            int width = rect[1];
            
            // Calculate diagonal using Pythagorean theorem
            double diagonal = Math.sqrt(length * length + width * width);
            
            // Update if longer diagonal found
            if (diagonal > maxDiagonal) {
                maxDiagonal = diagonal;
                maxArea = length * width;
            } 
            // For equal diagonals, choose larger area
            else if (Math.abs(diagonal - maxDiagonal) < 1e-9) {
                maxArea = Math.max(maxArea, length * width);
            }
        }
        
        return maxArea;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through all rectangles |
| **Space**       | O(1)       | Constant extra space |

## ðŸ“Š Example Walkthrough
**Input:** dimensions = [[5,12],[6,8],[3,4]]

**Execution:**
1. Rectangle [5,12]:
   - Diagonal = âˆš(25+144)=âˆš169=13
   - Area=60 â†’ maxDiagonal=13, maxArea=60
2. Rectangle [6,8]:
   - Diagonal = âˆš(36+64)=âˆš100=10
   - 10<13 â†’ skip
3. Rectangle [3,4]:
   - Diagonal = âˆš(9+16)=âˆš25=5
   - 5<13 â†’ skip
4. Final result: 60

**Equal Diagonal Example:** [[9,12],[8,12],[12,9]]
- All have diagonal=15
- Areas: 108, 96, 108 â†’ maxArea=108

## ðŸ’¡ Key Features
- **Geometric Calculation**: Proper diagonal computation
- **Precision Handling**: Uses epsilon for floating-point comparison
- **Efficient Comparison**: Single pass with optimal comparisons
- **Clear Logic**: Easy to understand and verify

## ðŸš€ When to Use
- Problems involving geometric properties
- When multiple criteria need comparison (primary: diagonal, secondary: area)
- Selection problems with tie-breaking rules
- Applications requiring Pythagorean theorem

## âš ï¸ Edge Cases
- **Single Rectangle**: Returns its area
- **All Equal Diagonals**: Chooses maximum area
- **Integer Overflow**: 1000Â² + 1000Â² = 2,000,000 (fits in int)
- **Floating Precision**: Uses epsilon for comparisons

## ðŸ›  Variations
1. **Integer Diagonal Comparison**:
```java
// Compare squared diagonals to avoid floating-point
```

2. **Custom Comparator**:
```java
// Sort rectangles by diagonal then area
```

3. **Parallel Processing**:
```java
// Process rectangles concurrently for large inputs
```

4. **Visualization**:
```java
// Print diagonal and area calculations
```

5. **Generalized for k Criteria**:
```java
// Extend to multiple selection criteria
```

## Mathematical Insight
The solution leverages:
- Pythagorean theorem properties
- Comparison of real numbers with epsilon
- Lexicographical ordering (diagonal first, then area)
- Efficient maximum tracking

## Alternative Implementation (Integer Comparison)
```java
class Solution {
    public int areaOfMaxDiagonal(int[][] dimensions) {
        int maxDiagonalSq = 0;
        int maxArea = 0;
        
        for (int[] rect : dimensions) {
            int len = rect[0], wid = rect[1];
            int diagSq = len * len + wid * wid;
            int area = len * wid;
            
            if (diagSq > maxDiagonalSq) {
                maxDiagonalSq = diagSq;
                maxArea = area;
            } else if (diagSq == maxDiagonalSq) {
                maxArea = Math.max(maxArea, area);
            }
        }
        
        return maxArea;
    }
}
```
Note: This version avoids floating-point operations by comparing squared diagonals, which is more efficient and avoids precision issues. The original solution is more mathematically intuitive but less numerically stable.