# üî• Longest Subarray of 1's After Deleting One Element - Sliding Window with State Tracking

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/?envType=daily-question&envId=2025-08-24)

Given:
- A binary array `nums` containing 0s and 1s

Find:
- The length of the longest non-empty subarray containing only 1's after deleting exactly one element
- If all elements are 1's, you must still delete one element

**Constraints:**
- 1 ‚â§ nums.length ‚â§ 10‚Åµ
- nums[i] is either 0 or 1

**Example:**
```text
Input: nums = [1,1,0,1]
Output: 3
Explanation: 
After deleting the 0 at index 2, the subarray [1,1,1] has length 3

Input: nums = [1,1,1]
Output: 2
Explanation: 
Must delete one element, so best is [1,1] with length 2
```

## üß† Intuition
The solution uses:
1. **State Tracking**: Maintains current and previous consecutive 1's counts
2. **Zero Handling**: Resets counters and updates maximum when encountering 0
3. **Edge Case Handling**: Special case for all 1's array
4. **Single Pass**: Processes array in linear time with constant space

Key Insights:
- The problem is equivalent to finding the longest subarray with at most one 0
- When we encounter a 0, the maximum becomes previous + current (bridging two 1's sequences)
- For all 1's arrays, we must subtract one element

## ‚öôÔ∏è Approach
1. **Initialize Counters**:
   - `current`: Count of consecutive 1's in current segment
   - `previous`: Count of consecutive 1's in previous segment
   - `max`: Maximum length found
2. **Process Array**:
   - For each 1: increment `current`
   - For each 0: update `max`, shift `current` to `previous`, reset `current`
3. **Final Check**:
   - Handle case where array ends with 1's
   - Adjust for all 1's case

## ‚úÖ Optimized Solution
```java
class Solution {
    public int longestSubarray(int[] nums) {
        int current = 0;    // Current consecutive 1's count
        int previous = 0;   // Previous consecutive 1's count  
        int max = 0;        // Maximum length found
        
        for (int num : nums) {
            if (num == 1) {
                current++;
            } else {
                // Update max with sum of previous and current segments
                max = Math.max(max, previous + current);
                previous = current;  // Shift current to previous
                current = 0;         // Reset current
            }
        }
        
        // Handle array ending with 1's
        max = Math.max(max, previous + current);
        
        // If all elements are 1's, must delete one element
        if (current == nums.length) {
            return current - 1;
        }
        
        return max;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through array |
| **Space**       | O(1)       | Constant extra space |

## üìä Example Walkthrough
**Input:** nums = [1,1,0,1,1,0,1,1,1]

**Execution:**
1. current=2, previous=0 at first 0 ‚Üí max=2, previous=2, current=0
2. current=2 at next 1's ‚Üí then 0: max=Max(2,2+2)=4, previous=2, current=0
3. current=3 at final 1's ‚Üí max=Max(4,2+3)=5
4. Final result: 5

**All 1's case:** nums = [1,1,1]
- current=3, max=3
- But must delete one element ‚Üí return 2

## üí° Key Features
- **Efficient State Management**: Only two variables needed
- **Single Pass**: Optimal O(n) time complexity
- **Clean Logic**: Easy to understand and implement
- **Edge Case Handling**: Properly handles all 1's case

## üöÄ When to Use
- Consecutive element counting problems
- Sliding window variations
- When state transitions are simple
- Problems with binary arrays

## ‚ö†Ô∏è Edge Cases
- **All 1's**: Must return length-1
- **Single 0**: Should bridge two 1's segments
- **All 0's**: Returns 0 (after deleting one 0)
- **Single Element**: Returns 0 (array of [0] or [1])

## üõ† Variations
1. **Sliding Window**:
```java
// Maintain window with at most one 0
```

2. **Prefix/Suffix Arrays**:
```java
// Precompute consecutive 1's from left and right
```

3. **Generalized for k Deletions**:
```java
// Extend to allow k deletions instead of 1
```

4. **Early Termination**:
```java
// Stop if maximum possible already found
```

5. **Visualization**:
```java
// Print segment boundaries and counts
```

## Mathematical Insight
The solution leverages:
- Properties of consecutive sequences
- State machine principles
- Optimal substructure (maximum is always previous + current)
- The fact that exactly one deletion is required

## Alternative Implementation (Sliding Window)
```java
class Solution {
    public int longestSubarray(int[] nums) {
        int left = 0, zeroCount = 0, max = 0;
        
        for (int right = 0; right < nums.length; right++) {
            if (nums[right] == 0) zeroCount++;
            
            while (zeroCount > 1) {
                if (nums[left] == 0) zeroCount--;
                left++;
            }
            
            max = Math.max(max, right - left);
        }
        
        return max;
    }
}
```
Note: This sliding window approach is also valid and maintains a window with at most one 0. The original solution is more space-efficient and has better constant factors.