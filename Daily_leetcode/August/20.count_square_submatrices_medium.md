# üî≤ Count Square Submatrices with All Ones - Dynamic Programming Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/count-square-submatrices-with-all-ones/description/?envType=daily-question&envId=2025-08-20)

Given:
- An `m x n` binary matrix `matrix` filled with 0s and 1s

Find:
- The total number of square submatrices with all ones

**Constraints:**
- 1 ‚â§ m, n ‚â§ 300
- matrix[i][j] is either 0 or 1

**Example:**
```text
Input: matrix = [
  [0,1,1,1],
  [1,1,1,1],
  [0,1,1,1]
]
Output: 15
Explanation: 
There are 10 squares of side 1, 4 squares of side 2, and 1 square of side 3
Total = 10 + 4 + 1 = 15
```

## üß† Intuition
The solution uses:
1. **Dynamic Programming**: Stores maximum square size ending at each cell
2. **Optimal Substructure**: DP value depends on top, left, and top-left neighbors
3. **In-place Modification**: Reuses input matrix for DP storage
4. **Cumulative Sum**: Sum of all DP values gives total squares

Key Insights:
- A cell (i,j) can form a square of size k only if its neighbors form squares of size k-1
- The DP value at (i,j) represents the side length of the largest square ending there
- The sum of all DP values equals the total number of squares

## ‚öôÔ∏è Approach
1. **Initialize**: Use input matrix as DP table
2. **DP Table Population**:
   - For each cell (starting from [1,1])
   - If cell is 1, set DP[i][j] = min(top, left, top-left) + 1
3. **Result Calculation**: Sum all values in the DP table

## ‚úÖ Optimized Solution
```java
class Solution {
    public int countSquares(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        int totalSquares = 0;
        
        // First row and column remain unchanged (base cases)
        // Process remaining cells starting from [1,1]
        for (int row = 1; row < rows; row++) {
            for (int col = 1; col < cols; col++) {
                if (matrix[row][col] == 1) {
                    matrix[row][col] = Math.min(
                        Math.min(matrix[row-1][col], matrix[row][col-1]),
                        matrix[row-1][col-1]
                    ) + 1;
                }
            }
        }
        
        // Sum all values in the DP table
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                totalSquares += matrix[row][col];
            }
        }
        
        return totalSquares;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(m√ón)     | Two passes through the matrix |
| **Space**       | O(1)       | In-place modification (no extra space) |

## üìä Example Walkthrough
**Input:** matrix = [[1,1,1],[1,1,1],[1,1,1]]

**DP Table Evolution:**
```
Initial:     After DP:
[1,1,1]      [1,1,1]
[1,1,1]  ‚Üí   [1,2,2]
[1,1,1]      [1,2,3]
```

**Calculation:**
- Sum = 1+1+1 + 1+2+2 + 1+2+3 = 14 squares
- (9 size-1, 4 size-2, 1 size-3)

## üí° Key Features
- **In-place DP**: No extra memory required
- **Efficient Computation**: Single pass for DP update
- **Simple Implementation**: Easy to understand and code
- **Optimal Solution**: Best possible time and space complexity

## üöÄ When to Use
- Matrix pattern counting problems
- When optimal substructure exists
- Problems involving contiguous submatrices
- Dynamic programming applications

## ‚ö†Ô∏è Edge Cases
- **All Zeros**: Returns 0
- **Single Row/Column**: Handles 1D matrices
- **Single One**: Returns 1
- **Large Matrix**: Handles maximum constraints

## üõ† Variations
1. **Separate DP Table**:
```java
// Use new dp array to preserve input
```

2. **Different Directions**:
```java
// Process from bottom-right to top-left
```

3. **Parallel Processing**:
```java
// Process rows/columns in parallel for large matrices
```

4. **Visualization**:
```java
// Print DP table for debugging
```

5. **Max Square Size**:
```java
// Track maximum square size instead of count
```

## Mathematical Insight
The solution leverages:
- Properties of geometric progressions
- Dynamic programming principles
- Matrix traversal patterns
- Cumulative sum techniques

## Alternative Implementation (Separate DP Table)
```java
class Solution {
    public int countSquares(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        int[][] dp = new int[m][n];
        int total = 0;
        
        // Initialize first row and column
        for (int i = 0; i < m; i++) {
            dp[i][0] = matrix[i][0];
            total += dp[i][0];
        }
        for (int j = 1; j < n; j++) {
            dp[0][j] = matrix[0][j];
            total += dp[0][j];
        }
        
        // Fill DP table
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 1) {
                    dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;
                    total += dp[i][j];
                }
            }
        }
        
        return total;
    }
}
```
Note: This version preserves the input matrix but uses O(m√ón) extra space. The in-place solution is more space-efficient.