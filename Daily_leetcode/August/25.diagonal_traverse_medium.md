# ‚ÜóÔ∏è Diagonal Traverse - Directional Movement Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/diagonal-traverse/description/?envType=daily-question&envId=2025-08-25)

Given:
- An `m x n` matrix `mat`

Return:
- All elements of the matrix in diagonal order (alternating upward and downward directions)

**Constraints:**
- m == mat.length
- n == mat[i].length
- 1 ‚â§ m, n ‚â§ 10‚Å¥
- 1 ‚â§ m * n ‚â§ 10‚Å¥
- -10‚Åµ ‚â§ mat[i][j] ‚â§ 10‚Åµ

**Example:**
```text
Input: mat = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,4,7,5,3,6,8,9]
Explanation:
Diagonal order: 
[1], [2,4], [3,5,7], [6,8], [9]
Traversed as: 1, 2, 4, 7, 5, 3, 6, 8, 9
```

## üß† Intuition
The solution uses:
1. **Direction Tracking**: Alternates between upward (+1) and downward (-1) directions
2. **Boundary Handling**: Adjusts position when hitting matrix edges
3. **State Management**: Uses current position and direction to determine next move
4. **Efficient Traversal**: Processes all elements in single pass

Key Insights:
- Movement follows two main patterns: up-right and down-left
- Direction changes occur at matrix boundaries
- The next position depends on current direction and edge conditions

## ‚öôÔ∏è Approach
1. **Initialize**:
   - Start at (0,0) with upward direction
   - Create result array of size m√ón
2. **Traverse Matrix**:
   - While within bounds, add current element to result
   - Calculate next position based on current direction
3. **Handle Boundaries**:
   - If next position is out of bounds, change direction and adjust position
4. **Direction Flip**: Alternate direction after boundary hits

## ‚úÖ Optimized Solution
```java
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        if (mat == null || mat.length == 0) return new int[0];
        
        int rows = mat.length;
        int cols = mat[0].length;
        int[] result = new int[rows * cols];
        int index = 0;
        int row = 0, col = 0;
        int direction = 1; // 1 for upward, -1 for downward
        
        while (row < rows && col < cols) {
            result[index++] = mat[row][col];
            
            // Calculate next position in current direction
            int nextRow = row + (direction == 1 ? -1 : 1);
            int nextCol = col + (direction == 1 ? 1 : -1);
            
            // Check if next position is within bounds
            if (nextRow < 0 || nextRow >= rows || nextCol < 0 || nextCol >= cols) {
                if (direction == 1) { // Moving upward
                    if (col < cols - 1) col++; // Move right if possible
                    else row++;               // Otherwise move down
                } else { // Moving downward
                    if (row < rows - 1) row++; // Move down if possible
                    else col++;               // Otherwise move right
                }
                direction = -direction; // Flip direction
            } else {
                row = nextRow;
                col = nextCol;
            }
        }
        
        return result;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(m√ón)     | Visit each element exactly once |
| **Space**       | O(1)       | Constant extra space (excluding output) |

## üìä Example Walkthrough
**Input:** mat = [[1,2,3],[4,5,6],[7,8,9]]

**Execution:**
1. Start: (0,0) ‚Üí add 1, direction=up
2. Next: (-1,1) out of bounds ‚Üí move to (0,1), flip direction=down
3. (0,1) ‚Üí add 2, direction=down ‚Üí (1,0)
4. (1,0) ‚Üí add 4, direction=down ‚Üí (2,-1) out of bounds
5. Move to (1,1), flip direction=up ‚Üí continue

**Final order:** [1,2,4,7,5,3,6,8,9]

## üí° Key Features
- **Directional Intelligence**: Handles both movement patterns
- **Efficient Boundary Checks**: Minimal condition checking
- **Single Pass**: Optimal time complexity
- **Clean State Management**: Simple direction flipping

## üöÄ When to Use
- Matrix traversal problems
- When elements need specific ordering
- Problems with alternating patterns
- Grid-based navigation

## ‚ö†Ô∏è Edge Cases
- **Single Row**: Horizontal movement only
- **Single Column**: Vertical movement only
- **1x1 Matrix**: Single element
- **Rectangular Matrices**: Non-square dimensions

## üõ† Variations
1. **Coordinate Sum Method**:
```java
// Group elements by (i+j) sum
```

2. **Two Separate Loops**:
```java
// Handle upward and downward passes separately
```

3. **BFS Approach**:
```java
// Level-order traversal by diagonals
```

4. **Parallel Processing**:
```java
// Process different diagonals concurrently
```

5. **Visualization**:
```java
// Print movement path for debugging
```

## Mathematical Insight
The solution leverages:
- Properties of matrix diagonals (constant i+j)
- Directional movement patterns
- Boundary transition logic
- State machine principles

## Alternative Implementation (Coordinate Grouping)
```java
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        if (mat.length == 0) return new int[0];
        int rows = mat.length, cols = mat[0].length;
        int[] result = new int[rows * cols];
        int index = 0;
        List<Integer> intermediate = new ArrayList<>();
        
        for (int sum = 0; sum < rows + cols - 1; sum++) {
            intermediate.clear();
            int r = sum < cols ? 0 : sum - cols + 1;
            int c = sum < cols ? sum : cols - 1;
            
            while (r < rows && c >= 0) {
                intermediate.add(mat[r][c]);
                r++;
                c--;
            }
            
            if (sum % 2 == 0) Collections.reverse(intermediate);
            for (int num : intermediate) result[index++] = num;
        }
        return result;
    }
}
```
Note: This alternative groups elements by diagonal but may be less efficient due to reversals. The directional movement approach is more direct and efficient.