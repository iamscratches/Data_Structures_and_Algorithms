# üî§ Minimum Cost to Convert String II

## üìú Problem Statement

**Link:**
[https://leetcode.com/problems/minimum-cost-to-convert-string-ii/description/?envType=daily-question&envId=2026-01-30](https://leetcode.com/problems/minimum-cost-to-convert-string-ii/description/?envType=daily-question&envId=2026-01-30)

You‚Äôre given:

* `source` and `target` strings (same length)
* Arrays `original[]`, `changed[]`, and `cost[]`

  * You may replace **entire substrings** (not just single chars)
  * Each replacement has a cost
  * Replacements can be chained

Goal:

> Convert `source` ‚Üí `target` with **minimum total cost**, or return `-1` if impossible.

---

## üß† High-Level Idea

This problem combines **three classic techniques**:

1. **Trie** ‚Üí Efficient substring matching
2. **Graph (Floyd‚ÄìWarshall)** ‚Üí Cheapest conversion between substrings
3. **Dynamic Programming** ‚Üí Build answer left to right

Think of it as:

> ‚ÄúString DP with graph-powered substring transitions.‚Äù

---

## üß© Key Observations

* Substrings (not characters) are the atomic units
* Same substring can appear multiple times
* Conversion rules form a **directed weighted graph of substrings**
* We need **fast lookup** of substrings starting at a position ‚Üí Trie
* We need **cheapest chained transformations** ‚Üí Floyd‚ÄìWarshall
* We need **optimal segmentation** of the string ‚Üí DP

---

## üèóÔ∏è Step-by-Step Solution

---

## 1Ô∏è‚É£ Map All Strings to Unique IDs (Trie)

We build a Trie containing **all strings** from:

* `original`
* `changed`

Each complete word gets a unique integer ID.

Why Trie?

* Lets us test **all substrings starting at index `i`** in `O(length)`
* Much faster than checking all substrings naively

```text
Trie Node:
- next[26]
- id (>=0 if this node is a complete word)
```

---

## 2Ô∏è‚É£ Build the Conversion Graph

Each substring is a node.

* Edge: `original[i] ‚Üí changed[i]` with cost `cost[i]`
* Multiple edges allowed ‚Üí keep minimum

We store this as a matrix:

```
dist[u][v] = minimum cost to convert substring u ‚Üí v
```

Initialize:

* `dist[i][i] = 0`
* Others = `INF`

---

## 3Ô∏è‚É£ Floyd‚ÄìWarshall (All-Pairs Shortest Path)

Because:

* Transformations can be chained
* Number of unique substrings is manageable

Classic APSP:

```
dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
```

After this:

> `dist[u][v]` = cheapest way to convert substring `u` ‚Üí `v`

---

## 4Ô∏è‚É£ Dynamic Programming on the String

### DP Definition

```
dp[i] = minimum cost to convert source[0..i-1] ‚Üí target[0..i-1]
```

Answer = `dp[n]`

---

### Transitions (at index `i`)

#### ‚úÖ Option A: Single Character Match (Free)

If:

```
source[i] == target[i]
```

Then:

```
dp[i+1] = min(dp[i+1], dp[i])
```

---

#### üîÅ Option B: Substring Replacement (Trie + Graph)

We simultaneously walk the Trie for:

* `source[i..j]`
* `target[i..j]`

If both substrings:

* Exist in Trie
* Have valid IDs `u` and `v`
* `dist[u][v] != INF`

Then:

```
dp[j+1] = min(dp[j+1], dp[i] + dist[u][v])
```

This tries **all valid substring replacements starting at `i`**.

---

## ‚úÖ Full Code (Your Implementation)

```java []
class Solution {
    // Standard Trie Node
    class TrieNode {
        TrieNode[] next = new TrieNode[26];
        int id = -1; // Unique ID for this string (-1 if not a complete word)
    }

    private int uniqueIDCounter = 0;

    public long minimumCost(String source, String target, 
                            String[] original, String[] changed, int[] cost) {

        // 1. Build Trie and assign IDs
        TrieNode root = new TrieNode();
        for (String s : original) insert(root, s);
        for (String s : changed) insert(root, s);

        // 2. Graph initialization
        int numNodes = uniqueIDCounter;
        long[][] dist = new long[numNodes][numNodes];
        for (int i = 0; i < numNodes; i++) {
            Arrays.fill(dist[i], Long.MAX_VALUE);
            dist[i][i] = 0;
        }

        // Direct conversion costs
        for (int i = 0; i < cost.length; i++) {
            int u = getID(root, original[i]);
            int v = getID(root, changed[i]);
            dist[u][v] = Math.min(dist[u][v], (long) cost[i]);
        }

        // 3. Floyd‚ÄìWarshall
        for (int k = 0; k < numNodes; k++) {
            for (int i = 0; i < numNodes; i++) {
                if (dist[i][k] == Long.MAX_VALUE) continue;
                for (int j = 0; j < numNodes; j++) {
                    if (dist[k][j] == Long.MAX_VALUE) continue;
                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }

        // 4. DP
        int n = source.length();
        long[] dp = new long[n + 1];
        Arrays.fill(dp, Long.MAX_VALUE);
        dp[0] = 0;

        for (int i = 0; i < n; i++) {
            if (dp[i] == Long.MAX_VALUE) continue;

            // Option A: character match
            if (source.charAt(i) == target.charAt(i)) {
                dp[i + 1] = Math.min(dp[i + 1], dp[i]);
            }

            // Option B: substring replacement
            TrieNode p1 = root, p2 = root;
            for (int j = i; j < n; j++) {
                int cs = source.charAt(j) - 'a';
                int ct = target.charAt(j) - 'a';

                p1 = p1.next[cs];
                p2 = p2.next[ct];

                if (p1 == null || p2 == null) break;

                if (p1.id != -1 && p2.id != -1) {
                    if (dist[p1.id][p2.id] != Long.MAX_VALUE) {
                        dp[j + 1] = Math.min(dp[j + 1],
                                              dp[i] + dist[p1.id][p2.id]);
                    }
                }
            }
        }

        return dp[n] == Long.MAX_VALUE ? -1 : dp[n];
    }

    private void insert(TrieNode root, String s) {
        TrieNode node = root;
        for (char c : s.toCharArray()) {
            if (node.next[c - 'a'] == null)
                node.next[c - 'a'] = new TrieNode();
            node = node.next[c - 'a'];
        }
        if (node.id == -1)
            node.id = uniqueIDCounter++;
    }

    private int getID(TrieNode root, String s) {
        TrieNode node = root;
        for (char c : s.toCharArray())
            node = node.next[c - 'a'];
        return node.id;
    }
}
```

---

## ‚è±Ô∏è Complexity Analysis

Let:

* `N = source.length`
* `M = number of unique substrings`

| Part           | Complexity                      |
| -------------- | ------------------------------- |
| Trie build     | `O(total length of words)`      |
| Floyd‚ÄìWarshall | `O(M¬≥)`                         |
| DP + Trie walk | `O(N¬≤)` (bounded by Trie depth) |
| Space          | `O(M¬≤ + N)`                     |

---

## üéØ Why This Is Optimal

* Trie avoids substring enumeration
* Floyd‚ÄìWarshall guarantees cheapest chained conversions
* DP ensures optimal segmentation
* Clean separation of concerns

---

## üß† Interview Summary Line

> ‚ÄúI model substrings as nodes, precompute cheapest conversions using Floyd‚ÄìWarshall, then use DP with a Trie to efficiently try all valid substring replacements.‚Äù

---

## üî• Final Takeaways

* This is **String I + DP + Trie**
* Trie = substring acceleration
* Floyd‚ÄìWarshall = conversion closure
* DP = optimal global solution
