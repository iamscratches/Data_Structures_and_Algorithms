# ğŸ§® Construct the Minimum Bitwise Array II

## ğŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/construct-the-minimum-bitwise-array-ii/description/?envType=daily-question&envId=2026-01-21](https://leetcode.com/problems/construct-the-minimum-bitwise-array-ii/description/?envType=daily-question&envId=2026-01-21)

You are given a list of integers `nums`.
For each number `x` in `nums`, you must find the **minimum non-negative integer `a`** such that:

```
a | (a + 1) == x
```

If no such `a` exists, return **`âˆ’1`** for that position.

Return the array of answers.

---

## ğŸ§  Intuition

The bitwise expression:

```
a | (a + 1)
```

has a **specific pattern**:

* When you OR a number `a` with `a + 1`, the result sets:

  * the **least significant 0** in `a` â†’ 1
  * all bits to the right of that position â†’ 1
* So `a | (a + 1)` will always produce a number of the form:

```
...111...1
```

â€” a sequence of consecutive `1` bits starting at some position.

This means:

* The only values `x` that can be written as `a | (a + 1)` are **numbers with trailing 1s in binary**.
* If `x` is such a number, the corresponding `a` will be the same as `x` **but with the highest trailing 1 turned off**.

---

## ğŸ” Key Observation

Let the binary representation of `x` have the form:

```
...???0111...1
```

(where there is a block of trailing `1`s at the least significant bits).

Then the minimum `a` satisfying:

```
a | (a + 1) == x
```

is:

```
a = x with the **most significant** of the trailing 1s turned off
```

This corresponds to:

* Find the position of the **first 0 bit** after a block of trailing 1s
* Flip the bit just **below it** from `1` â†’ `0`
* This yields the smallest possible `a`

If `x` has no **zero bit** above the trailing 1s (e.g., `x == 2` which is `10â‚‚`), then **no solution exists** â†’ return `âˆ’1`.

---

## ğŸ›  Bitwise Insight

Example:

```
x = 0b10111 (23 in decimal)
```

Trailing 1s: `111`
Right before them: `0` at bit position 3

Then:

```
a = 0b10111 ^ (1 << (firstNonTrailingOne - 1))
  = 0b10111 ^ (1 << (3 âˆ’ 1))
  = 0b10111 ^ (1 << 2)
  = 0b10111 ^ 0b00100
  = 0b10011 (decimal 19)
```

Check:

```
19 | 20 == 23
```

---

## ğŸ§  When No Solution Exists

The only common case where **no `a` exists** is:

```
x == 2
```

Because:

* `2` in binary is `10`
* There is **only one trailing 1** (the LSB is zero)
* No proper higher 0 bit to flip â†’ impossible

So we return `âˆ’1`.

---

## âš™ï¸ Approach (Your Bitwise Code)

1. For each `x` in `nums`:

   * If `x == 2` â†’ `ans[i] = -1`
   * Otherwise:

     * Scan bits from **LSB upward**
     * Find first `0` bit
     * Flip the previous bit (to turn it off)
     * That yields the minimal `a`
2. Store result in `ans[i]`

---

## âœ… Code Implementation (Your Solution)

```java []
class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int[] ans = new int[nums.size()];
        for (int i = 0; i < nums.size(); ++i) {
            int x = nums.get(i);
            if (x == 2) {
                ans[i] = -1;
            } else {
                for (int b = 1; b < 32; ++b) {
                    // find the first 0 bit
                    if (((x >> b) & 1) == 0) {
                        ans[i] = x ^ (1 << (b - 1));
                        break;
                    }
                }
            }
        }
        return ans;
    }
}
```

---

## â± Complexity Analysis

| Metric                                      | Complexity            |
| ------------------------------------------- | --------------------- |
| **Time**                                    | O(n Ã— log max(nums))  |
| â€” Because we scan up to ~32 bits per number |                       |
| **Space**                                   | O(n) for result array |

---

## ğŸ§  Why This Works

* `a | (a + 1)` always produces a binary number with a block of trailing 1s
* The size and position of that block directly correspond to bits in `x`
* Flipping the correct bit yields the **smallest** possible `a` satisfying the OR condition
* Scanning bits yields answers in constant time per number

---

## ğŸ” Example Walkthrough

| x (decimal) | x (binary) | ans (decimal) | explanation |           |         |
| ----------- | ---------- | ------------- | ----------- | --------- | ------- |
| 3           | `11`       | 1             | 1           | 1 â†’ `1    | 2 == 3` |
| 7           | `111`      | 3             | 3           | 3 â†’ `3    | 4 == 7` |
| 23          | `10111`    | 19            | `19         | 20 == 23` |         |
| 2           | `10`       | -1            | no solution |           |         |

---

## âš  Edge Cases

| Input                     | Output                | Reason            |
| ------------------------- | --------------------- | ----------------- |
| [2]                       | [-1]                  | no valid `a`      |
| [3]                       | [1]                   | minimal valid a   |
| large odd `x`             | computed via bit scan | works efficiently |
| all bits are 1 except top | scan up to 32 bits    | correct           |

---

## ğŸ§  Interview One-Liner

> â€œThe expression `a | (a + 1)` yields a number with trailing 1s; to invert it, find the first 0 bit above the trailing 1s and flip the preceding bit to get the smallest valid `a`.â€

---

## ğŸš€ Key Takeaways

âœ” Uses **bit manipulation** efficiently
âœ” Avoids brute-force iteration up to `x`
âœ” **Edge case:** `x == 2` â†’ no solution
âœ” Optimized bit scan â†’ O(1) per number
