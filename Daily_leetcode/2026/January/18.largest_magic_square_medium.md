# üî≤ Largest Magic Square

## üìú Problem Statement

**Link:**
[https://leetcode.com/problems/largest-magic-square/?envType=daily-question&envId=2026-01-18](https://leetcode.com/problems/largest-magic-square/?envType=daily-question&envId=2026-01-18)

A **k √ó k magic square** is a subgrid where:

* Every **row sum** is equal
* Every **column sum** is equal
* Both **diagonals** sum to the same value

Given an `m √ó n` integer grid, return the **largest possible side length `k`** of a magic square.

> Every `1 √ó 1` grid is trivially a magic square.

---

## üß† Intuition

The most straightforward way is:

1. Try **every possible subgrid**
2. Check whether it satisfies the **magic square conditions**
3. Track the **maximum valid size**

Your solution follows exactly this **brute-force + validation** strategy.

---

## ‚öôÔ∏è Approach (Your Code)

### üîÅ Brute Force Enumeration

* Iterate over every cell `(i, j)` as the **top-left corner**
* Try all possible square sizes `k ‚â• 2`
* If the square fits inside the grid and `k > current max`, check if it‚Äôs magic

### üîç Magic Square Validation

For a candidate `size √ó size` square:

1. Compute the **reference sum** (first column)
2. Check:

   * All **columns**
   * All **rows**
   * **Main diagonal**
   * **Anti-diagonal**
3. If any check fails ‚Üí not magic

---

## ‚úÖ Code (As Provided)

```java []
class Solution {
    public int largestMagicSquare(int[][] grid) {
        int row = grid.length;
        int col = grid[0].length;
        int maxSize = 1;

        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                for(int k = 2; k + i <= row && k + j <= col; k++){
                    if(k > maxSize && isMagic(grid, i, j, k)){
                        maxSize = Math.max(maxSize, k);
                    }
                }
            }
        }
        return maxSize;
    }

    private boolean isMagic(int[][] grid, int r, int c, int size){
        long sum = 0;

        // reference sum (first column)
        for(int i = r; i < r + size; i++){
            sum += grid[i][c];
        }

        long rSum = 0;

        // check columns
        for(int j = c; j < c + size; j++){
            for(int i = r; i < r + size; i++){
                rSum += grid[i][j];
            }
            if(rSum != sum) return false;
            rSum = 0;
        }

        // check rows
        for(int i = r; i < r + size; i++){
            for(int j = c; j < c + size; j++){
                rSum += grid[i][j];
            }
            if(rSum != sum) return false;
            rSum = 0;
        }

        // main diagonal
        int idx = 0;
        for(int i = r; i < r + size; i++){
            rSum += grid[i][c + idx++];
        }
        if(rSum != sum) return false;

        // anti-diagonal
        rSum = 0;
        idx = 0;
        for(int i = r; i < r + size; i++){
            rSum += grid[i][c + size - 1 - idx++];
        }
        if(rSum != sum) return false;

        return true;
    }
}
```

---

## ‚è± Time & Space Complexity (Your Solution)

### ‚è≥ Time Complexity

* Top-left cell choices: `O(m √ó n)`
* Square sizes per cell: `O(min(m, n))`
* Validation per square: `O(k¬≤)`

**Worst case:**

```
O(m √ó n √ó L¬≥)   where L = min(m, n)
```

### üíæ Space Complexity

```
O(1)
```

(No extra data structures)

---

## ‚ö†Ô∏è Limitations of This Approach

* Recomputes **row & column sums repeatedly**
* Diagonal and row checks are **nested loops**
* Acceptable for constraints (`‚â§ 50`) but not optimal

---

## üöÄ Optimized Solution (Prefix Sums)

### üîë Key Optimization Idea

Use **prefix sums** to compute:

* Row sums in **O(1)**
* Column sums in **O(1)**

This reduces validation from `O(k¬≤)` ‚Üí `O(k)`

---

## ‚ö° Optimized Code

```java []
class Solution {
    public int largestMagicSquare(int[][] grid) {
        int m = grid.length, n = grid[0].length;

        int[][] rowSum = new int[m][n + 1];
        int[][] colSum = new int[m + 1][n];

        // build prefix sums
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                rowSum[i][j + 1] = rowSum[i][j] + grid[i][j];
                colSum[i + 1][j] = colSum[i][j] + grid[i][j];
            }
        }

        for (int k = Math.min(m, n); k >= 2; k--) {
            for (int i = 0; i + k <= m; i++) {
                for (int j = 0; j + k <= n; j++) {
                    if (isMagic(grid, rowSum, colSum, i, j, k)) {
                        return k;
                    }
                }
            }
        }
        return 1;
    }

    private boolean isMagic(int[][] grid, int[][] rowSum, int[][] colSum,
                            int r, int c, int k) {

        int target = rowSum[r][c + k] - rowSum[r][c];

        // rows
        for (int i = r; i < r + k; i++) {
            if (rowSum[i][c + k] - rowSum[i][c] != target)
                return false;
        }

        // columns
        for (int j = c; j < c + k; j++) {
            if (colSum[r + k][j] - colSum[r][j] != target)
                return false;
        }

        // main diagonal
        int d1 = 0, d2 = 0;
        for (int i = 0; i < k; i++) {
            d1 += grid[r + i][c + i];
            d2 += grid[r + i][c + k - 1 - i];
        }

        return d1 == target && d2 == target;
    }
}
```

---

## ‚è± Complexity (Optimized)

| Metric    | Complexity      |
| --------- | --------------- |
| **Time**  | `O(m √ó n √ó L¬≤)` |
| **Space** | `O(m √ó n)`      |

---

## üß† Interview One-Liner

> ‚ÄúWe brute-force all possible squares and validate them efficiently using prefix sums to reduce repeated row and column computations.‚Äù

---

## ‚ùå Common Mistakes

* Forgetting **anti-diagonal**
* Using nested loops for every sum (TLE risk)
* Not checking squares in **descending order of size**