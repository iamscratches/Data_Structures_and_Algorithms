# üå≥ Maximum Product of Splitted Binary Tree ‚Äî Two-Pass DFS Strategy

## üìú Problem Statement

**Link:** [https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/description/?envType=daily-question&envId=2026-01-07](https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/description/?envType=daily-question&envId=2026-01-07)

You are given the `root` of a binary tree.
You can **split the tree into two subtrees by removing exactly one edge**.

Return the **maximum product** of the sums of the two resulting subtrees.
Since the result may be large, return it **modulo 10‚Åπ + 7**.

---

## üß† Intuition

When you cut **one edge**, the tree is split into:

* One subtree with sum = `subSum`
* The rest of the tree with sum = `totalSum - subSum`

The product becomes:

```
subSum √ó (totalSum ‚àí subSum)
```

üëâ To maximize this product:

* We must consider **every possible subtree**
* We need to know the **total sum of the tree first**
* Then evaluate the product for **each possible cut**

This naturally leads to a **two-pass DFS solution**.

---

## ‚öôÔ∏è Approach

### **1Ô∏è‚É£ First DFS ‚Äî Compute Total Sum**

Traverse the tree and compute:

```
totalSum = sum of all node values
```

### **2Ô∏è‚É£ Second DFS ‚Äî Compute Subtree Sums**

For every node:

* Compute its subtree sum
* Treat the edge above it as a potential cut
* Update maximum product:

```
subSum √ó (totalSum ‚àí subSum)
```

Track the maximum value encountered.

---

## ‚úÖ Code Implementation (Your Solution)

```java []
class Solution {
    long totalSum = 0;
    long maxProd = 0;
    static final int MOD = 1_000_000_007;

    // First DFS to compute total tree sum
    private void dfsTotal(TreeNode root) {
        if (root == null) return;
        totalSum += root.val;
        dfsTotal(root.left);
        dfsTotal(root.right);
    }

    // Second DFS to compute subtree sums and products
    private long dfs(TreeNode root) {
        if (root == null) return 0;

        long left = dfs(root.left);
        long right = dfs(root.right);

        long subSum = left + right + root.val;
        maxProd = Math.max(maxProd, subSum * (totalSum - subSum));

        return subSum;
    }

    public int maxProduct(TreeNode root) {
        dfsTotal(root);
        dfs(root);
        return (int)(maxProd % MOD);
    }
}
```

---

## üìä Example Walkthrough

### Example

```
Tree:
        1
       / \
      2   3
     / \   \
    4   5   6
```

### Step 1: Total Sum

```
totalSum = 1 + 2 + 3 + 4 + 5 + 6 = 21
```

### Step 2: Try All Cuts

| Subtree | subSum | Product       |
| ------- | ------ | ------------- |
| Node 4  | 4      | 4 √ó 17 = 68   |
| Node 5  | 5      | 5 √ó 16 = 80   |
| Node 2  | 11     | 11 √ó 10 = 110 |
| Node 3  | 9      | 9 √ó 12 = 108  |

**Maximum = 110**

---

## ‚è≥ Complexity Analysis

| Metric          | Complexity           |
| --------------- | -------------------- |
| **Time**        | O(n)                 |
| **Space**       | O(h) recursion stack |
| **Extra Space** | O(1)                 |

Where:

* `n` = number of nodes
* `h` = height of the tree

---

## üß† Why This Works

* Every valid split corresponds to **one subtree**
* DFS guarantees every subtree is evaluated once
* Product is computed in constant time per node
* Two-pass strategy avoids recomputation

---

## üí° Key Observations

* Product is maximized when `subSum` is close to `totalSum / 2`
* We **must** compute `totalSum` first
* Greedy or single-pass without total sum does not work
* Modulo is applied only **at the end** to preserve accuracy

---

## ‚ö† Edge Cases

| Case           | Result                 |
| -------------- | ---------------------- |
| Single node    | 0 (no edge to cut)     |
| All nodes same | Balanced cut gives max |
| Large values   | Handled using `long`   |
| Deep tree      | Safe with recursion    |

---

## üîÑ Optimized Alternative (One DFS + Store Subtree Sums)

You can store all subtree sums and compute product later:

```java []
class Solution {
    List<Long> sums = new ArrayList<>();
    long total = 0;
    static final int MOD = 1_000_000_007;

    private long dfs(TreeNode node) {
        if (node == null) return 0;
        long sum = node.val + dfs(node.left) + dfs(node.right);
        sums.add(sum);
        return sum;
    }

    public int maxProduct(TreeNode root) {
        total = dfs(root);
        long ans = 0;
        for (long s : sums) {
            ans = Math.max(ans, s * (total - s));
        }
        return (int)(ans % MOD);
    }
}
```

**Trade-off:**

* Uses extra space O(n)
* Still O(n) time

---

## üß† Interview One-Liner

> ‚ÄúCompute the total sum of the tree, then for each subtree compute the product of its sum and the remaining tree.‚Äù

---

## üöÄ Key Takeaways

‚úî Two-pass DFS is optimal
‚úî Evaluate all possible splits
‚úî Use `long` to prevent overflow
‚úî Apply modulo at the end

