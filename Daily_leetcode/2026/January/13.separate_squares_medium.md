# â¬œ Separate Squares I

## ğŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/separate-squares-i/description/?envType=daily-question&envId=2026-01-13](https://leetcode.com/problems/separate-squares-i/description/?envType=daily-question&envId=2026-01-13)

You are given several **axis-aligned squares** on a 2D plane.
Each square is represented as:

```
[x, y, sideLength]
```

where `(x, y)` is the **bottom-left corner**.

Your task is to find the **smallest y-coordinate** of a horizontal line such that:

* Total area **below** the line â‰¥ total area **above** the line

Return the y-coordinate with sufficient precision.

---

## ğŸ§  Key Insight

* We are **not** asked for exact geometry intersections
* We only compare **areas above and below a horizontal line**
* Area distribution changes **monotonically** as the line moves up

â¡ï¸ This makes the problem perfect for **binary search on the y-axis**

---

## ğŸ” Strategy Overview

### Why Binary Search?

* At `y = 0` â†’ almost all area is **above**
* At very large `y` â†’ almost all area is **below**
* The difference `(below - above)` changes monotonically

Thus, we can binary search to find the **balance point**.

---

## ğŸ“ Area Calculation Logic

For a square with:

* bottom at `y`
* side length `l`
* total area `l Ã— l`

For a given horizontal line at height `mid`:

### Case 1: Square fully below

```
y + l â‰¤ mid
â†’ entire area goes to below
```

### Case 2: Square fully above

```
y â‰¥ mid
â†’ entire area goes to above
```

### Case 3: Square is split

```
below area = (mid âˆ’ y) Ã— l
above area = total âˆ’ below
```

---

## ğŸ”„ Algorithm

1. Binary search `y` in range `[0, 1e9]`
2. For each `mid`:

   * Compute total area **below (LA)** and **above (UA)**
3. If `LA â‰¥ UA`, move left (smaller y)
4. Else move right
5. Repeat until precision is achieved

---

## âœ… Code Implementation (Your Solution)

```java []
class Solution {
    public double separateSquares(int[][] squares) {
        double L = 0.0, R = 1e9;
        double Ans = 0.0;

        for (int it = 0; it < 80; it++) { // sufficient precision
            double mid = L + (R - L) / 2.0;
            double LA = 0.0, UA = 0.0;

            for (int i = 0; i < squares.length; i++) {
                double y = squares[i][1];
                double l = squares[i][2];
                double TA = l * l;

                if (y + l <= mid) {
                    LA += TA;                     // completely below
                } else if (y >= mid) {
                    UA += TA;                     // completely above
                } else {
                    double below = (mid - y) * l; // partially split
                    LA += below;
                    UA += TA - below;
                }
            }

            if (LA >= UA) {
                Ans = mid;
                R = mid;
            } else {
                L = mid;
            }
        }

        return Ans;
    }
}
```

---

## ğŸ§ª Example Walkthrough

### Input

```
squares = [[0,0,2],[0,2,2]]
```

Total area = `8`

We want:

```
below â‰¥ 4
```

Binary search gradually converges to:

```
y = 2.0
```

---

## â³ Complexity Analysis

| Metric    | Complexity           |
| --------- | -------------------- |
| **Time**  | O(n Ã— log precision) |
| **Space** | O(1)                 |

* `80` iterations guarantee double precision accuracy

---

## ğŸ¯ Why This Works

âœ” Area difference is monotonic
âœ” Binary search guarantees precision
âœ” Handles partial overlaps cleanly
âœ” No geometry intersection complexity

---

## âŒ Naive Approaches (Why Not)

| Approach                          | Issue                             |
| --------------------------------- | --------------------------------- |
| Simulate line movement            | Too slow                          |
| Compute exact intersection shapes | Overkill                          |
| Sorting all square edges          | Still requires precision handling |

---

## ğŸ§  Interview One-Liner

> â€œSince area below minus above changes monotonically with height, we binary-search the y-coordinate.â€

---

## ğŸš€ Key Takeaways

âœ” Binary search on continuous space
âœ” Split geometry without heavy math
âœ” Precision-controlled solution
âœ” Elegant and interview-ready
