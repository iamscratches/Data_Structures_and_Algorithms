# ğŸ“‰ Minimum Pair Removal to Sort Array I â€” Greedy Simulation

## ğŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/minimum-pair-removal-to-sort-array-i/?envType=daily-question&envId=2026-01-22](https://leetcode.com/problems/minimum-pair-removal-to-sort-array-i/?envType=daily-question&envId=2026-01-22)

You are given an integer array `nums`.
You can repeatedly perform this operation:

> Select the **adjacent pair with the minimum sum** (if multiple, choose *leftmost*), replace that pair with their sum â€” effectively merging them into one number.

Return the **minimum number of such operations** needed to make `nums` **non-decreasing**.

---

## ğŸ§  Intuition

The array is sorted if and only if no adjacent pair violates the non-decreasing condition:

```
nums[i] < nums[i - 1]
```

Each merge:

* Reduces array length by 1
* Replaces two numbers with their sum
* Potentially reduces inversions and increases local order

The greedy choice â€” merging the adjacent pair with the **minimum sum** â€” is optimal because:

* Less sum â†’ less impact on upcoming larger numbers
* Helps keep the merged result as small as possible to preserve order

This lets us minimize the number of operations.

---

## âš™ï¸ Approach

### ğŸ” Process Simulation

1. Convert `nums` to a dynamic list so we can remove and replace elements easily
2. Scan for the first violation of the sorted order
3. If found:

   * Find the **adjacent pair with the minimum sum**
   * Merge them
   * Increment operation count
   * Restart scanning from the beginning
4. Repeat until the list is non-decreasing
5. Return operation count

This exactly simulates the described process.

---

## âœ… Code Implementation (Your Solution)

```java []
class Solution {
    public int minimumPairRemoval(int[] nums) {
        int count = 0;
        List<Integer> numsList = new ArrayList<>();
        for(int x : nums){
            numsList.add(x);
        }
        
        for(int i = 1; i < numsList.size(); i++){
            if(numsList.get(i) >= numsList.get(i - 1)){
                continue;
            }
            
            // find the leftmost adjacent pair with the minimum sum
            int minSum = Integer.MAX_VALUE;
            int minPos = -1;
            for(int j = 1; j < numsList.size(); j++){
                int sum = numsList.get(j) + numsList.get(j - 1);
                if(sum < minSum){
                    minSum = sum;
                    minPos = j;
                }
            }
            
            // merge the best pair
            numsList.set(minPos - 1, minSum);
            numsList.remove(minPos);
            
            // reset index to check from start
            i = 0;
            count++;
        }
        return count;
    }
}
```

---

## ğŸ§  Whatâ€™s Going On

* We keep scanning for the *first unsorted position*
* Instead of merging that immediate pair, we merge the **global minimum adjacent pair**, which is the greedy choice
* After merging, we break any potential inversion by restarting the scan

This simulates the exact operation described in the problem.

---

## ğŸ•’ Complexity Analysis

| Metric    | Complexity |
| --------- | ---------- |
| **Time**  | O(nÂ²)      |
| **Space** | O(n)       |

Reason:

* Each merge is O(n) to find the minimal sum pair
* Up to **n â€“ 1** merges â†’ O(nÂ²)

Because `nums.length â‰¤ 50`, this is fast enough.

---

## ğŸ§ª Example

### Input

```
nums = [5,2,3,1]
```

**Iteration 1**

* Not sorted (`2 < 5`, `1 < 3`)
* Adjacent sums:
  `(5+2)=7, (2+3)=5, (3+1)=4` â†’ min = 4 at (3,1)
* Merge â†’ `[5,2,4]`
* count = 1

**Iteration 2**

* Still not sorted (`2 < 5`)
* Adjacent sums:
  `(5+2)=7, (2+4)=6` â†’ min = 6 at (2,4)
* Merge â†’ `[5,6]`
* count = 2

Sorted â†’ Stop

**Answer = 2**

---

## ğŸ’¡ Why This Works (Greedy Justification)

This greedy approach works because:

* Merging the smallest adjacent sum *minimally increases* the merged value
* Smaller merged values help preserve sorted order
* Larger merges early can create bigger inversions later

Thus picking the minimum sum pair is the *least disruptive* choice.

---

## âš  Edge Cases

| Input         | Output                      | Explanation                |
| ------------- | --------------------------- | -------------------------- |
| `[1,2,3]`     | `0`                         | Already sorted             |
| `[2,1]`       | `1`                         | Only inversion â†’ one merge |
| `[5,4,3,2,1]` | `4`                         | Worst-case decreasing      |
| Large numbers | works since sums fit in int |                            |

---

## ğŸ§  Interview One-Liner

> â€œWe simulate the process by repeatedly merging the adjacent pair with the smallest sum and restart checking until the array becomes non-decreasing.â€

---

## ğŸš€ Key Takeaways

âœ” Simulates exactly as described
âœ” Greedy selection of the minimum adjacent sum
âœ” Restarting scan ensures correctness
âœ” O(nÂ²) acceptable for n â‰¤ 50

---