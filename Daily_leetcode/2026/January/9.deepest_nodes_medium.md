# ğŸŒ³ Smallest Subtree with All the Deepest Nodes

## ğŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/description/?envType=daily-question&envId=2026-01-09](https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/description/?envType=daily-question&envId=2026-01-09)

Given the root of a binary tree, return the **smallest subtree** that contains **all the deepest nodes**.

A nodeâ€™s **depth** is the number of edges from the root to that node.

---

## ğŸ§  Key Insight

* All deepest nodes lie at the **maximum depth**
* The required subtree is rooted at the **lowest common ancestor (LCA)** of all deepest nodes
* We can compute **depth + subtree root simultaneously** using DFS

---

## ğŸ’¡ Core Idea (Post-order DFS)

For every node, we want to know:

1. The **maximum depth** in its subtree
2. The **node** that is the root of the smallest subtree containing all deepest nodes below it

So we return a pair:

```
(height, node)
```

---

## ğŸ”„ DFS Logic

For a node:

* Recurse on left and right children
* Compare their heights

### Cases:

| Left Height  | Right Height | Result                               |
| ------------ | ------------ | ------------------------------------ |
| Left > Right |              | Deepest nodes are in left subtree    |
| Right > Left |              | Deepest nodes are in right subtree   |
| Equal        |              | Current node is LCA of deepest nodes |

---

## ğŸ“¦ Result Object

```java []
class Result {
    int height;
    TreeNode node;
}
```

* `height`: deepest level below this node
* `node`: subtree root containing all deepest nodes

---

## âœ… Code Implementation (Your Solution)

```java []
class Solution {
    class Result {
        int height;
        TreeNode node;
        Result(int h, TreeNode n) {
            height = h;
            node = n;
        }
    }

    private Result dfs(TreeNode node) {
        if (node == null) return new Result(0, null);
        
        Result left = dfs(node.left);
        Result right = dfs(node.right);
        
        if (left.height > right.height) {
            return new Result(left.height + 1, left.node);
        } else if (right.height > left.height) {
            return new Result(right.height + 1, right.node);
        } else {
            return new Result(left.height + 1, node);
        }
    }

    public TreeNode subtreeWithAllDeepest(TreeNode root) {
        return dfs(root).node;
    }
}
```

---

## ğŸ§ª Example Walkthrough

### Tree

```
        3
       / \
      5   1
     / \   \
    6   2   8
       / \
      7   4
```

* Deepest nodes: `7` and `4`
* Their LCA is `2`
* Output subtree root = `2`

---

## â³ Complexity Analysis

| Metric         | Complexity           |
| -------------- | -------------------- |
| **Time**       | O(n)                 |
| **Space**      | O(h) recursion stack |
| **Worst-case** | O(n) (skewed tree)   |

---

## ğŸ§  Why This Is Optimal

* Single DFS traversal
* No extra passes to compute depth or LCA
* Depth and answer computed **together**

---

## ğŸ†š Alternative Approach (Less Optimal)

1. Compute maximum depth
2. Track parents of deepest nodes
3. Compute LCA

â›” Requires multiple traversals
âœ… Current solution does it in **one pass**

---

## âš  Edge Cases Covered

| Case                      | Result                              |
| ------------------------- | ----------------------------------- |
| Single node tree          | Root returned                       |
| All nodes same depth      | Root returned                       |
| Deepest nodes on one side | That subtree returned               |
| Null tree                 | Not applicable (root always exists) |

---

## ğŸ§  Interview One-Liner

> â€œUsing post-order DFS, I return both depth and subtree root; equal depths make the current node the LCA of deepest nodes.â€

---

## ğŸš€ Key Takeaways

âœ” Deepest nodes â‡’ LCA problem
âœ” Post-order traversal is essential
âœ” Combine height + answer in one DFS
âœ” Clean and optimal O(n) solution