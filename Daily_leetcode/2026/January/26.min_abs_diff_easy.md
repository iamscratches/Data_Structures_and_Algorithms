# â– Minimum Absolute Difference

## ğŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/minimum-absolute-difference/description/?envType=daily-question&envId=2026-01-26](https://leetcode.com/problems/minimum-absolute-difference/description/?envType=daily-question&envId=2026-01-26)

Given an **array of distinct integers `arr`**, find all pairs of elements with the **minimum absolute difference** between them.
Return the pairs **in ascending order** (by value).

---

## ğŸ§  Intuition

To find the **smallest absolute difference** between any two numbers in the array, it helps to observe:

> When the array is **sorted**, the smallest difference between any two elements must be between **adjacent elements**.

Why?

* Sorting places all numbers in ascending order
* The closest numbers in value will be next to each other

So the plan is:

1. Sort the array
2. Compute the minimum absolute difference between all adjacent pairs
3. Collect all adjacent pairs that match that minimum

---

## âš™ï¸ Approach

### Steps

1. **Sort `arr`**
2. Scan once to compute `minDiff`:

   ```
   minDiff = min(arr[i] âˆ’ arr[iâˆ’1]) for i=1..nâˆ’1
   ```
3. Scan again to collect all pairs with that difference
4. Return a list of these pairs in ascending order

Since the array is sorted, the result is already in the required order.

---

## ğŸ§ª Example

### Input

```
arr = [4, 2, 1, 3]
```

Sorted:

```
[1, 2, 3, 4]
```

Adjacent pairs and differences:

```
(1,2): diff=1
(2,3): diff=1
(3,4): diff=1
```

Minimum absolute difference = `1`

Output:

```
[[1,2], [2,3], [3,4]]
```

---

## âœ… Code Implementation

```java []
class Solution {
    public List<List<Integer>> minimumAbsDifference(int[] arr) {
        Arrays.sort(arr);
        int minDiff = Integer.MAX_VALUE;
        
        // Find minimum absolute difference
        for(int i = 1; i < arr.length; i++){
            minDiff = Math.min(minDiff, arr[i] - arr[i - 1]);
        }
        
        // Collect all adjacent pairs with difference = minDiff
        List<List<Integer>> res = new ArrayList<>();
        for(int i = 1; i < arr.length; i++){
            if(arr[i] - arr[i - 1] == minDiff){
                res.add(List.of(arr[i - 1], arr[i]));
            }
        }
        
        return res;
    }
}
```

---

## â±ï¸ Complexity Analysis

| Metric    | Complexity                  |
| --------- | --------------------------- |
| **Time**  | O(n log n) (due to sorting) |
| **Space** | O(1) extra (besides output) |

* Sorting dominates the runtime
* Two linear scans after sort

---

## ğŸ§  Why This Works

* Sorting brings closest numeric values together
* The minimum adjacent difference in a sorted array is the **global minimum**
* Any pair with that difference must be adjacent after sorting

So this strategy finds all pairs with minimum absolute difference **efficiently and correctly**.

---

## âš  Edge Cases

| Input                        | Output    | Reason                 |
| ---------------------------- | --------- | ---------------------- |
| Single pair (`arr = [1, 5]`) | `[[1,5]]` | Only one possible pair |
| Negative numbers             | Works     | Sorting handles them   |
| Already sorted input         | Works     | Same logic applies     |
| Large array                  | Efficient | O(n log n) overall     |

---

## ğŸ§  Interview One-Liner

> â€œSort the array, then scan adjacent pairs to find the minimum absolute difference and return all pairs that achieve it.â€

---

## ğŸš€ Key Takeaways

âœ” Adjacent difference after sorting = global minimum
âœ” Simple two-pass scanning
âœ” Output already sorted
âœ” Clean, efficient, and easy to implement