# ğŸŒ€ Minimum Cost Path With Teleportations

## ğŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/minimum-cost-path-with-teleportations/description/?envType=daily-question&envId=2026-01-28](https://leetcode.com/problems/minimum-cost-path-with-teleportations/description/?envType=daily-question&envId=2026-01-28)

You are given a grid `grid[n][m]` where:

* You start at `(0, 0)` and want to reach `(n-1, m-1)`
* Moving **right or down** costs the value of the cell you **enter**
* You are allowed to use **at most `k` teleportations**
* A teleport lets you jump from `(i, j)` to **any cell whose value â‰¤ `grid[i][j]`**, at **zero extra cost**

Return the **minimum total cost**.

---

## ğŸ§  Core Insight

This problem mixes:

* **Grid DP**
* **Global jumps (teleportation)**
* **Limited usage (`k`)**

Key observations:

1. Cost is paid when **entering a cell**, not leaving it
2. Teleportation ignores distance â€” only **cell value matters**
3. Teleportation count is limited â†’ needs **layered DP**

So we solve this with **multi-layer DP**, where each layer represents:

> â€œminimum cost using at most `x` teleportationsâ€

---

## ğŸ§© DP Definition

### Primary DP

```
dp[i][j] = minimum cost to reach (n-1, m-1) from (i, j)
```

We compute it **backwards** (bottom-right â†’ top-left).

---

### Helper Arrays (Critical Optimization)

#### `temp[v]`

```
temp[v] = minimum dp value among all cells with grid value == v
```

#### `best[v]`

```
best[v] = minimum dp value among all cells with value â‰¤ v
```

This allows **O(1) teleport cost lookup**.

---

## ğŸš¶ Base Case (No Teleports: k = 0)

Only normal walking is allowed.

Transition:

```
dp[i][j] = min(
    dp[i+1][j] + grid[i+1][j],
    dp[i][j+1] + grid[i][j+1]
)
```

While filling `dp`, we populate `temp[]` with best costs per value.

---

## ğŸŒ€ Adding Teleport Layers (k > 0)

Each teleport layer tries to **relax dp[][] further**.

### Step 1: Prefix Min

Build `best[]` from `temp[]`:

```
best[v] = min(best[v-1], temp[v])
```

This means:

> Best teleport destination with value â‰¤ v

---

### Step 2: Relax DP

For each cell `(i, j)`:

```
walkCost = min(down, right)
teleportCost = best[grid[i][j]]

dp[i][j] = min(walkCost, teleportCost)
```

Update `temp[]` for the next iteration.

Repeat this **k times**.

---

## ğŸ§ª Example (Intuition)

```
grid:
1 3 5
2 1 2
4 3 1
```

If you are at value `3`:

* You may teleport to **any cell with value â‰¤ 3**
* Choose the one with **minimum dp cost**
* That jump might beat all walking paths

Prefix minimum makes this instant.

---

## âœ… Full Code (Your Implementation)

```java []
class Solution {
    public int minCost(int[][] grid, int k) {
        int n = grid.length, m = grid[0].length;
        
        // 1. Find max value in grid
        int maxVal = 0;
        for(int[] row : grid) {
            for(int val : row) maxVal = Math.max(maxVal, val);
        }

        int[][] dp = new int[n][m];
        int[] temp = new int[maxVal + 1];
        int[] best = new int[maxVal + 1];

        Arrays.fill(temp, Integer.MAX_VALUE);

        // Base case
        temp[grid[n - 1][m - 1]] = 0;

        // --- k = 0 (only walking) ---
        for(int i = n - 1; i >= 0; i--) {
            for(int j = m - 1; j >= 0; j--) {
                if(i == n - 1 && j == m - 1) continue;

                int down = (i + 1 < n) ? dp[i + 1][j] + grid[i + 1][j] : Integer.MAX_VALUE;
                int right = (j + 1 < m) ? dp[i][j + 1] + grid[i][j + 1] : Integer.MAX_VALUE;

                dp[i][j] = Math.min(down, right);

                if (dp[i][j] != Integer.MAX_VALUE) {
                    temp[grid[i][j]] = Math.min(temp[grid[i][j]], dp[i][j]);
                }
            }
        }

        // --- teleport layers ---
        for(int x = 0; x < k; x++) {
            best[0] = temp[0];
            for(int v = 1; v <= maxVal; v++) {
                best[v] = Math.min(best[v - 1], temp[v]);
            }

            for(int i = n - 1; i >= 0; i--) {
                for(int j = m - 1; j >= 0; j--) {
                    if(i == n - 1 && j == m - 1) continue;

                    int down = (i + 1 < n) ? dp[i + 1][j] + grid[i + 1][j] : Integer.MAX_VALUE;
                    int right = (j + 1 < m) ? dp[i][j + 1] + grid[i][j + 1] : Integer.MAX_VALUE;
                    int walkCost = Math.min(down, right);

                    int teleportCost = best[grid[i][j]];

                    dp[i][j] = Math.min(walkCost, teleportCost);

                    if (dp[i][j] != Integer.MAX_VALUE) {
                        temp[grid[i][j]] = Math.min(temp[grid[i][j]], dp[i][j]);
                    }
                }
            }
        }

        return dp[0][0];
    }
}
```

---

## â±ï¸ Complexity Analysis

Let:

* `n * m = grid size`
* `V = max value in grid`

| Metric    | Complexity             |
| --------- | ---------------------- |
| **Time**  | `O(k * n * m + k * V)` |
| **Space** | `O(n * m + V)`         |

Efficient enough because:

* Teleport lookup is `O(1)`
* No nested teleport loops

---

## ğŸ§  Why This Works

âœ” Teleport is value-based â†’ compress with `temp[]`
âœ” Prefix min avoids scanning all cells
âœ” Layered DP enforces teleport limit
âœ” Walking + teleport naturally compete

---

## âš  Edge Cases

| Case                     | Handling           |
| ------------------------ | ------------------ |
| `k = 0`                  | Normal grid DP     |
| Single cell              | Cost = 0           |
| Large values             | Value-based arrays |
| No benefit from teleport | Walk path chosen   |

---

## ğŸ§  Interview One-Liner

> â€œWe use layered DP with prefix minima to model limited teleportations efficiently.â€

---

## ğŸš€ Key Takeaways

* Teleport â‰  BFS jump â†’ itâ€™s **value-based**
* Prefix minima is the real trick
* Multi-layer DP is a powerful pattern
* Clean separation of walk vs teleport