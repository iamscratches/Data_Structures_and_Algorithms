# ğŸ§® Construct the Minimum Bitwise Array I

## ğŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/construct-the-minimum-bitwise-array-i/description/?envType=daily-question&envId=2026-01-20](https://leetcode.com/problems/construct-the-minimum-bitwise-array-i/description/?envType=daily-question&envId=2026-01-20)

You are given an array of **prime integers** `nums`.
You must construct an array `ans` of the same length such that for each index `i`:

```
ans[i] OR (ans[i] + 1) == nums[i]
```

Also:

* Among all possible valid values, `ans[i]` should be **minimized**
* If **no such value exists**, set `ans[i] = -1`
  *(All `nums[i]` are prime numbers â‰¥ 2.)* ([Leetcode][1])

---

## ğŸ§  Intuition

The bitwise condition:

```
a OR (a + 1) = x
```

has a special behavior:

* When you OR a number with its successor, the result flips the **rightmost 0** bit of `a` to `1` and sets all bits to the right to 1.
* This operation always produces an **odd** number.
  Therefore, if `x == 2` (the only even prime), it is **impossible** â€” no such `a` exists, so we return `-1`. ([Leetcode][1])

For odd `x`:

* We want the **smallest** `a` such that `a OR (a+1) = x`
* The pattern is that `a` must be obtained by **turning off one bit** in `x`, specifically the **highest 1 in the trailing group of 1s** in `x`â€™s binary form. ([WalkCCC][2])

---

## ğŸ” Key Insight

For odd `x`, consider its binary representation.
Example:

```
x = 0b10111 (i.e., 23)
```

The rightmost zero bit after the trailing ones determines the candidate:

* The last group of 1s is `111`
* The leading 1 in that group is `100`
* So the minimal `a` satisfying the condition is:

```
a = x - 0b100
```

In other terms:

* Find the **first 0 bit** (from LSB upwards) in `x`
* Flip the bit just *below* it from `1` â†’ `0`
* That gives the minimal `a`

---

## âš™ï¸ Approach

1. Initialize the answer array `ans` of same length as `nums`
2. For each prime `x` in `nums`:

   * If `x == 2`, set `ans[i] = -1`
   * Else:

     * Scan bits from LSB (bit 1) upwards
     * Find the first `0` bit
     * Flip bit at position `i-1` in `x` (where the 0 was found at i)
     * That flipped number is the minimal `a`

This ensures the condition is satisfied with the **smallest a**.

---

## âœ… Your Code (Brute Enumerative Approach)

```java []
class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int[] ans  = new int[nums.size()];
        int index = 0;
        for(int n: nums){
            ans[index] = -1;
            for(int i=0; i<n; i++){
                if((i|(i+1))==n){
                    ans[index] = i;
                    break;
                }
            }
            index++;
        }
        return ans;
    }
}
```

---

## ğŸ§  What This Code is Doing

âœ” It tries all values `i` from `0` to `n-1`
âœ” For each candidate `i`, checks:

```
i OR (i+1) == n
```

âœ” If condition matches, sets `ans[index] = i`
âœ” Stops at the **first valid i**, giving the minimum

If none matches, it remains `-1`.

---

## â³ Complexity Analysis

| Metric    | Complexity                                        |
| --------- | ------------------------------------------------- |
| **Time**  | O(n Ã— M)                                          |
| Where     | `n` = number of elements, `M` = max value in nums |
| **Space** | O(n) for answer                                   |

Because you loop up to `n` for each number, this solution is correct but **not optimal** â€” especially when `nums[i]` is large. ([Leetcode][1])

---

## ğŸš€ Optimized Bitwise Approach (Faster & Cleaner)

Instead of checking every `i`, use bit manipulation directly:

```java []
class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int[] ans = new int[nums.size()];
        for (int i = 0; i < nums.size(); ++i) {
            int x = nums.get(i);
            if (x == 2) {
                ans[i] = -1;
            } else {
                for (int b = 1; b < 32; ++b) {
                    // find the first 0 bit
                    if (((x >> b) & 1) == 0) {
                        ans[i] = x ^ (1 << (b - 1));
                        break;
                    }
                }
            }
        }
        return ans;
    }
}
```

âœ” Only checks up to 31 bits
âœ” O(n Ã— log(max(nums))) time
âœ” More efficient than brute looping up to n([Leetcode][1])

---

## ğŸ§  Interview One-Liner

> â€œFor each prime `x`, find the smallest number `a` such that `a OR (a+1) == x` by flipping the right bit in `x` â€” because this OR pattern is driven by bit transitions.â€ ([Leetcode][1])

---

## âš  Edge Cases

| Input        | Output                   | Reason                 |
| ------------ | ------------------------ | ---------------------- |
| `[2]`        | `[-1]`                   | 2 is even, no solution |
| `[3]`        | `[1]`                    | 1 OR 2 = 3             |
| `[11]`       | `[9]`                    | Rightmost 0 bit logic  |
| Large primes | Correct via bit scanning |                        |

---

## ğŸ“Œ Summary

âœ” Brute approach tries all i from 0 to n âˆ’ 1
âœ” Correct but slow for bigger numbers
âœ” Bitwise optimization scans bits directly
âœ” Answer always lowest possible valid number

---