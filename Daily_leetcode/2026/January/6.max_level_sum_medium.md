# üå≥ Maximum Level Sum of a Binary Tree ‚Äî DFS Level Aggregation

## üìú Problem Statement

**Link:** [https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/description/?envType=daily-question&envId=2026-01-06](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/description/?envType=daily-question&envId=2026-01-06)

Given the `root` of a binary tree, return the **level (1-indexed)** that has the **maximum sum of node values**.

If multiple levels have the same maximum sum, return the **smallest level number**.

---

## üß† Intuition

Each level of the binary tree contributes independently to the total sum.

So the idea is:

* Traverse the tree
* Accumulate the sum of node values **per level**
* Find the level with the maximum sum

Key observation:

> This is a **level-wise aggregation problem**, solvable via either **DFS with depth tracking** or **BFS (level-order traversal)**.

Your solution uses **DFS** and stores sums in an array indexed by depth.

---

## ‚öôÔ∏è Approach

### **1Ô∏è‚É£ Depth-First Traversal with Level Tracking**

* Maintain an array `arr[]` where `arr[i]` stores the sum of values at level `i`
* Traverse the tree recursively
* At each node:

  * Add `node.val` to `arr[level]`
  * Track the maximum depth reached

### **2Ô∏è‚É£ Find Maximum Level Sum**

* Iterate over the filled portion of `arr`
* Track:

  * Maximum sum encountered
  * Corresponding level (convert 0-indexed ‚Üí 1-indexed)

---

## ‚úÖ Code Implementation (Your Solution)

```java
class Solution {
    int maxLevel = -1;

    public int maxLevelSum(TreeNode root) {
        int[] arr = new int[10000]; // stores sum per level
        findMax(root, arr, 0);

        int max = Integer.MIN_VALUE;
        int level = -1;

        for (int i = 0; i <= maxLevel; i++) {
            if (arr[i] > max) {
                max = arr[i];
                level = i + 1; // convert to 1-indexed
            }
        }
        return level;
    }

    private void findMax(TreeNode node, int[] arr, int level) {
        arr[level] += node.val;
        maxLevel = Math.max(maxLevel, level);

        if (node.left != null) {
            findMax(node.left, arr, level + 1);
        }
        if (node.right != null) {
            findMax(node.right, arr, level + 1);
        }
    }
}
```

---

## üìä Example Walkthrough

### Example

```
Tree:
      1
     / \
    7   0
   / \
  7  -8
```

### Level Sums

| Level | Nodes | Sum |
| ----- | ----- | --- |
| 1     | 1     | 1   |
| 2     | 7, 0  | 7   |
| 3     | 7, -8 | -1  |

### Maximum Sum

```
Max = 7 at Level 2
```

**Output:** `2`

---

## ‚è≥ Complexity Analysis

| Metric    | Complexity                        |
| --------- | --------------------------------- |
| **Time**  | O(n) ‚Äî each node visited once     |
| **Space** | O(h) recursion stack + O(L) array |
|           | Worst case: O(n)                  |

Where:

* `n` = number of nodes
* `h` = height of tree
* `L` = number of levels

---

## üß† Why This Works

* DFS ensures every node contributes exactly once
* Level indexing groups nodes correctly
* Using `>` comparison ensures **earliest level wins** in case of tie

This satisfies all constraints efficiently.

---

## üí° Key Observations

* Tree depth ‚â§ 10‚Å¥ ‚Üí array size is safe
* Level sums are independent ‚Üí order doesn‚Äôt matter
* DFS or BFS both valid ‚Äî DFS chosen here

---

## ‚ö† Edge Cases

| Case                    | Result                         |
| ----------------------- | ------------------------------ |
| Single node             | Level 1                        |
| All negative values     | Highest (least negative) level |
| Multiple equal max sums | Smallest level returned        |
| Skewed tree             | Works correctly                |

---

## üîÅ Optimized Alternative (BFS Approach)

This avoids the large fixed array and recursion stack.

```java
class Solution {
    public int maxLevelSum(TreeNode root) {
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        int level = 1, ans = 1;
        int maxSum = root.val;

        while (!q.isEmpty()) {
            int size = q.size();
            int sum = 0;

            for (int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                sum += node.val;
                if (node.left != null) q.offer(node.left);
                if (node.right != null) q.offer(node.right);
            }

            if (sum > maxSum) {
                maxSum = sum;
                ans = level;
            }
            level++;
        }
        return ans;
    }
}
```

### Why BFS is Often Preferred

* Cleaner logic
* No large array
* Natural level processing
* Same O(n) time

---

## üß† Interview Tip

This problem tests:
‚úî Tree traversal
‚úî Level aggregation
‚úî Tie-breaking logic

One-line summary you can say in interviews:

> ‚ÄúTraverse the tree, compute level sums, and return the smallest level with the maximum sum.‚Äù

---