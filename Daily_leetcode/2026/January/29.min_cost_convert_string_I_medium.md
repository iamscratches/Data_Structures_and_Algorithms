# ğŸ”¤ Minimum Cost to Convert String I

## ğŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/minimum-cost-to-convert-string-i/?envType=daily-question&envId=2026-01-29](https://leetcode.com/problems/minimum-cost-to-convert-string-i/?envType=daily-question&envId=2026-01-29)

Youâ€™re given:

* Two strings `source` and `target` of equal length
* Arrays `original`, `changed`, and `cost`

  * You can convert `original[i] â†’ changed[i]` at cost `cost[i]`
  * Conversions can be **chained**

Your task:

> Convert `source` into `target` with **minimum total cost**, or return `-1` if impossible.

---

## ğŸ§  Core Insight

Each **character** is a node.
Each **conversion rule** is a **directed weighted edge**.

That gives us:

* **26 nodes** (`'a'` â†’ `'z'`)
* We need the **minimum cost path between all character pairs**

This screams:

> **Floydâ€“Warshall**

Why?

* Small fixed graph (26 nodes)
* Allows unlimited chained conversions
* Gives shortest path between *every* `(u, v)`

---

## ğŸ—ºï¸ Graph Modeling

* Node `i` = character `(char)('a' + i)`
* Edge `u â†’ v` with weight `cost`
* Multiple edges allowed â†’ keep **minimum**

---

## ğŸ§© Algorithm Steps

### 1ï¸âƒ£ Initialize Distance Matrix

```
dist[u][v] = minimum cost to convert u â†’ v
```

* Initialize all to `INF`
* `dist[i][i] = 0` (no cost to stay same)

---

### 2ï¸âƒ£ Add Conversion Rules

For each rule:

```
original[i] â†’ changed[i] at cost[i]
```

We keep:

```
dist[u][v] = min(dist[u][v], cost[i])
```

Because there may be duplicate edges.

---

### 3ï¸âƒ£ Floydâ€“Warshall (All-Pairs Shortest Path)

Core idea:

```
dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
```

This allows:

* Multi-step conversions
* Optimal intermediate characters

Time complexity is tiny:

```
26Â³ â‰ˆ 17,576
```

---

### 4ï¸âƒ£ Build the Answer

For each position `i`:

* If `source[i] == target[i]` â†’ cost `0`
* Else:

  * If `dist[u][v] == INF` â†’ return `-1`
  * Add `dist[u][v]` to total

---

## âœ… Full Code (Your Implementation)

```java []
import java.util.Arrays;

class Solution {
    public long minimumCost(String source, String target, 
                             char[] original, char[] changed, int[] cost) {

        long[][] dist = new long[26][26];
        long INF = Long.MAX_VALUE / 2;

        // 1. Initialize distances
        for (long[] row : dist) {
            Arrays.fill(row, INF);
        }
        for (int i = 0; i < 26; i++) {
            dist[i][i] = 0;
        }

        // 2. Direct conversions
        for (int i = 0; i < original.length; i++) {
            int u = original[i] - 'a';
            int v = changed[i] - 'a';
            dist[u][v] = Math.min(dist[u][v], cost[i]);
        }

        // 3. Floydâ€“Warshall
        for (int k = 0; k < 26; k++) {
            for (int i = 0; i < 26; i++) {
                if (dist[i][k] == INF) continue;
                for (int j = 0; j < 26; j++) {
                    if (dist[k][j] != INF) {
                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
                    }
                }
            }
        }

        // 4. Build result
        long totalCost = 0;
        int n = source.length();

        for (int i = 0; i < n; i++) {
            int u = source.charAt(i) - 'a';
            int v = target.charAt(i) - 'a';

            if (u == v) continue;
            if (dist[u][v] == INF) return -1;

            totalCost += dist[u][v];
        }

        return totalCost;
    }
}
```

---

## â±ï¸ Complexity Analysis

| Metric    | Complexity   |
| --------- | ------------ |
| **Time**  | `O(26Â³ + n)` |
| **Space** | `O(26Â²)`     |

This is **constant-time graph work** + linear string traversal.

---

## ğŸ§  Why This Works

âœ” Characters form a **small graph**
âœ” Conversions are **directed + weighted**
âœ” Chained transformations â†’ APSP needed
âœ” Floydâ€“Warshall is perfect at this scale

---

## âš ï¸ Edge Cases

| Case                         | Result                   |
| ---------------------------- | ------------------------ |
| `source[i] == target[i]`     | Cost = 0                 |
| No conversion path           | Return `-1`              |
| Multiple rules for same pair | Take minimum             |
| Long strings                 | Safe (graph cost reused) |

---

## ğŸ¯ Interview One-Liner

> â€œModel characters as nodes and conversions as weighted edges, then use Floydâ€“Warshall since the graph size is fixed (26).â€

---

## ğŸš€ Key Takeaways

* Small fixed alphabet â†’ matrix DP
* Floydâ€“Warshall is underrated in interviews
* Separate **graph preprocessing** from **string traversal**
* Clean, robust, optimal solution

---