# ğŸ“ˆ Maximum Matrix Sum â€” Greedy Absolute Value Adjustment

## ğŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/maximum-matrix-sum/description/?envType=daily-question&envId=2026-01-05](https://leetcode.com/problems/maximum-matrix-sum/description/?envType=daily-question&envId=2026-01-05)

Given an `n x n` integer matrix, you are allowed to **flip the sign** (multiply by âˆ’1) of any element as many times as you want.

Return the **maximum possible sum of all elements** in the matrix after choosing any number of sign flips.

---

## ğŸ§  Intuition

This is a classic pattern where we are allowed to independently flip the **signs** of elements.
Flipping a negative to positive increases the total sum (unless constrained). But if we flip too many, we might lose optimality.

Key observations:

* We want elements to be *positive* as much as possible.
* The sum of absolute values is the starting maximum if we can make all values positive.
* But if the number of negative numbers is **odd**, then one negative must remain (or one flip is wasted), reducing the maximum sum.

So:

* Take the **sum of absolute values**
* Track the **parity of negative count**
* Track the **smallest absolute value**
* If the number of negatives is odd, we must *sacrifice* the smallest absolute element by flipping it to negative â†’ effectively subtracting `2 Ã— smallest`

---

## âš™ï¸ Approach

1. Initialize:

   * `sum = 0` â†’ total sum of absolute values
   * `count = 0` â†’ number of negative values
   * `min = Infinity` â†’ track minimum absolute value
2. Traverse the matrix:

   * Add `abs(matrix[i][j])` to sum
   * Increment `count` if the element was negative
   * Update `min` with the smallest `abs(matrix[i][j])`
3. If `count` is even â†’ return `sum`
4. If `count` is odd â†’ subtract `2 Ã— min`

This ensures we never lose more than necessary.

---

## âœ… Code Implementation (Your Solution)

```java
class Solution {
    public long maxMatrixSum(int[][] matrix) {
        long sum = 0;
        int count = 0;
        int n = matrix.length;
        int min = Integer.MAX_VALUE;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int abs = Math.abs(matrix[i][j]);
                sum += abs;
                if (matrix[i][j] < 0) {
                    count++;
                }
                min = Math.min(min, abs);
            }
        }

        // If the number of negatives is even, we can make all positive
        if (count % 2 == 0) {
            return sum;
        }
        // Otherwise subtract twice the smallest abs element
        return sum - (2L * min);
    }
}
```

---

## ğŸ“Š Example Walkthrough

### Example 1

```
matrix = [[1,-2],
          [-3,4]]
```

Absolute values:

```
1, 2, 3, 4 â†’ sum = 10
Negative count = 2 â†’ even â†’ sum = 10
```

Return:

```
10
```

---

### Example 2

```
matrix = [[-1,-1],
          [-1,-1]]
```

Absolute sum:

```
1+1+1+1 = 4
count = 4 (even) â†’ all can be made positive â†’ 4
```

---

### Example 3

```
matrix = [[-1,2],
          [3,4]]
```

Absolute sum:

```
1+2+3+4 = 10
count = 1 â†’ odd
min = 1
result = 10 - 2*1 = 8
```

---

## â³ Complexity Analysis

| Metric    | Complexity |                                |
| --------- | ---------- | ------------------------------ |
| **Time**  | O(nÂ²)      | Traverse all elements          |
| **Space** | O(1)       | Only counters and accumulators |

This runs efficiently for grid sizes up to the constraints.

---

## ğŸ§  Why This Works (Correctness)

You can flip any element independently.

* If total negative count is even â†’ you can flip all to positive â†’ max sum = sum of absolutes.
* If total negative count is odd â†’ one sign must remain negative.
  You want to pay the **smallest penalty possible** â†’ flip the smallest absolute value element last â†’ this subtracts `2 Ã— that value` from the total.

This gives the **maximum achievable sum** after optimal flips.

---

## ğŸ’¡ Key Observations

| Case                                         | Result                |
| -------------------------------------------- | --------------------- |
| All negatives but even count                 | All positive sum      |
| All negatives but odd                        | One negative remains  |
| Mixed positives and negatives                | Similar logic applies |
| Smallest absolute matters when parity is odd | true                  |

---

## âš  Edge Cases

| Input                      | Explanation                                |
| -------------------------- | ------------------------------------------ |
| Single-element matrix      | Return absolute value (even logic applies) |
| All zeros                  | Sum = 0                                    |
| All positive               | Sum = sum of elements                      |
| Very large negative values | Works with 64-bit sum                      |

---

## ğŸ§  Interview Tip

This is a good example of:
âœ” Greedy sign selection
âœ” Parity reasoning
âœ” Absolute value manipulation

A neat one-liner summary:

> â€œMaximize sum by taking absolute values, and if thereâ€™s an odd number of negatives, subtract twice the smallest absolute value.â€

---