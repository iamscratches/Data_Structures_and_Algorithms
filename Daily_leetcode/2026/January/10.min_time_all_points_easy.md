# ğŸ“ Minimum Time Visiting All Points

## ğŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/minimum-time-visiting-all-points/description/?envType=daily-question&envId=2026-01-12](https://leetcode.com/problems/minimum-time-visiting-all-points/description/?envType=daily-question&envId=2026-01-12)

You are given an array of points on a 2D plane.
Starting at the first point, you must visit all points in order.

In **one second**, you can:

* Move **vertically**
* Move **horizontally**
* Move **diagonally**

Return the **minimum time** required to visit all points.

---

## ğŸ§  Key Observation

* Diagonal movement allows changing both `x` and `y` by `1` in one second
* To move from point **A â†’ B**, the optimal strategy is:

  * Move diagonally as much as possible
  * Then move straight if needed

---

## ğŸ’¡ Core Insight

For two points:

```
(x1, y1) â†’ (x2, y2)
```

Let:

```
dx = |x2 - x1|
dy = |y2 - y1|
```

### Minimum time required:

```
max(dx, dy)
```

Why?

* Use diagonal moves `min(dx, dy)` times
* Remaining movement is `|dx - dy|`
* Total = `max(dx, dy)`

---

## ğŸ”„ Algorithm

1. Initialize total distance = 0
2. For every consecutive pair of points:

   * Compute `dx`, `dy`
   * Add `max(dx, dy)` to total
3. Return total

---

## âœ… Code Implementation (Your Solution)

```java []
class Solution {
    public int minTimeToVisitAllPoints(int[][] points) {
        int dist = 0, xDist, yDist;
        for(int i=1; i<points.length; i++){
            xDist = Math.abs(points[i-1][0]-points[i][0]);
            yDist = Math.abs(points[i-1][1]-points[i][1]);
            if(xDist>yDist){
                dist+=xDist;
            }
            else{
                dist+=yDist;
            }
        }
        return dist;
    }
}
```

---

## ğŸ§ª Example Walkthrough

### Input

```
points = [[1,1],[3,4],[-1,0]]
```

### Steps

1ï¸âƒ£ (1,1) â†’ (3,4)

```
dx = 2, dy = 3 â†’ time = 3
```

2ï¸âƒ£ (3,4) â†’ (-1,0)

```
dx = 4, dy = 4 â†’ time = 4
```

### Total Time

```
3 + 4 = 7
```

---

## â³ Complexity Analysis

| Metric    | Complexity |
| --------- | ---------- |
| **Time**  | O(n)       |
| **Space** | O(1)       |

---

## ğŸ§  Why This Is Optimal

* No path simulation needed
* Uses direct mathematical observation
* Each segment computed in constant time

---

## ğŸ†š Alternative (Less Efficient) Approach

âŒ Simulate each step movement
âŒ Track direction changes

â¡ï¸ Leads to unnecessary operations
âœ”ï¸ Current solution is minimal and clean

---

## âš  Edge Cases Covered

| Case                       | Output                 |
| -------------------------- | ---------------------- |
| Single point               | 0                      |
| Points aligned diagonally  | Distance = dx = dy     |
| Horizontal / vertical line | Distance = max(dx, dy) |
| Negative coordinates       | Handled via `Math.abs` |

---

## ğŸ§  Interview One-Liner

> â€œMinimum time between two points equals `max(|dx|, |dy|)` due to diagonal moves.â€

---

## ğŸš€ Key Takeaways

âœ” Diagonal moves dominate the solution
âœ” Simple math beats simulation
âœ” Linear time, constant space
âœ” Clean and interview-friendly

---
