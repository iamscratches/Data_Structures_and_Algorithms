# ğŸ” N-Repeated Element in Size 2N Array â€” Detect Early Duplicate

## ğŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/n-repeated-element-in-size-2n-array/?envType=daily-question&envId=2026-01-02](https://leetcode.com/problems/n-repeated-element-in-size-2n-array/?envType=daily-question&envId=2026-01-02)

You are given an integer array `nums` of size `2n` where:

* Exactly one element is repeated **n times**
* All other elements appear exactly once

Return **the element that is repeated n times**.

---

## ğŸ§  Intuition

Because the array has length `2n` and one value appears exactly `n` times, that value must appear **very frequently**.
No fancy frequency distribution is needed â€” as soon as a value appears twice, it **must be the repeated one**.

So, as we traverse the array, we can:

* Track counts of elements
* Return the first one that reaches count `2`

This works because:

* All other elements occur only once
* Only the repeated element can reach a count of `2` (and beyond)

---

## âš™ï¸ Approach

1. Use a frequency tracking structure
2. Traverse the array
3. For each number:

   * Increment its count
   * If its count becomes `2`, return it

Early exit ensures this is **very fast** â€” on average we find it before scanning the entire array.

---

## âœ… Your Code Implementation

```java []
class Solution {
    public int repeatedNTimes(int[] nums) {
        int hashArray[] = new int[10001];
        for(int i = 0; i < nums.length; i++){
            hashArray[nums[i]]++;
            if(hashArray[nums[i]] == 2){
                return nums[i];
            }                
        }
        return 0;
    }
}
```

---

## â³ Complexity Analysis

| Metric    | Complexity | Detail                                   |
| --------- | ---------- | ---------------------------------------- |
| **Time**  | O(n)       | One pass through array                   |
| **Space** | O(K)       | Where K = range of values (â‰¤ 10000 here) |

âœ” Efficient
âœ” Works for constraints

---

## ğŸ“Š Example Walkthrough

### Input

```
nums = [5,1,5,2,5,3,5,4]
```

### Step by Step

* 5 â†’ count = 1
* 1 â†’ count = 1
* 5 â†’ count = 2 â†’ **first element repeated twice â†’ return 5**

ğŸŸ¢ Output:

```
5
```

---

## ğŸ‘ Why This Works

Since:

* One value occurs `n` times
* All other values occur once

The only way any value reaches count `2` while scanning left to right is the repeated value.
Thus, the first duplicate found is guaranteed to be the answer.

---

## ğŸ§  Optimization Insight

Your current solution uses a **fixed-size frequency array (range â‰¤ 10000)** which is extremely fast.

However, if the value range were unknown or large, a `HashSet` would be even simpler and more general:

---

## âš¡ Optimized (HashSet) Version

This avoids a fixed hash range and is elegant:

```java []
class Solution {
    public int repeatedNTimes(int[] nums) {
        Set<Integer> seen = new HashSet<>();
        for (int x : nums) {
            if (seen.contains(x)) return x;
            seen.add(x);
        }
        return -1;
    }
}
```

### Why This Is Better

* No fixed maximum value assumption
* No array of unnecessary size
* Just tracks what has been seen already

---

## ğŸš€ Complexity (HashSet)

| Metric    | Complexity |
| --------- | ---------- |
| **Time**  | O(n)       |
| **Space** | O(n)       |

Still optimal for this problem.

---

## âš  Edge Cases

| Input               | Output            |
| ------------------- | ----------------- |
| `[1,1,2,3]`         | `1`               |
| `[2,5,2,3,2,4,2,6]` | `2`               |
| All same values     | That value        |
| Large n             | Works efficiently |

---

## ğŸ Final Takeaways

* This problem is about detecting a **duplicate early**
* Early break saves time
* A `HashSet` version is simple and robust

