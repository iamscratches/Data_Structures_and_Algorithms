# â¬œ Separate Squares II

## ğŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/separate-squares-ii/description/?envType=daily-question&envId=2026-01-14](https://leetcode.com/problems/separate-squares-ii/description/?envType=daily-question&envId=2026-01-14)

You are given multiple **axis-aligned squares** on a 2D plane.
Each square is represented as:

```
[x, y, sideLength]
```

where `(x, y)` is the **bottom-left corner**.

### Goal

Find the **smallest y-coordinate** of a horizontal line such that:

> **Area below the line = Area above the line**

âš ï¸ Unlike *Separate Squares I*, **overlapping squares must be counted only once**.

---

## ğŸ§  Key Difference from Part I

| Separate Squares I    | Separate Squares II              |
| --------------------- | -------------------------------- |
| Areas are independent | Overlapping areas must be merged |
| Simple binary search  | Requires geometry processing     |
| O(n log precision)    | Sweep line + union intervals     |

â¡ï¸ We must compute the **union area** of all squares.

---

## ğŸ” Core Idea

We solve this in **two passes**:

### **Pass 1 â€” Sweep Line (Y-axis)**

* Break the plane into **horizontal strips**
* For each strip:

  * Compute the **union width** of active x-intervals
  * Store `(bottomY, height, unionWidth)`
* Accumulate **total union area**

### **Pass 2 â€” Area Split**

* Walk strips from bottom to top
* Find the y where **accumulated area reaches half**

---

## ğŸ§¹ Sweep Line Strategy

### Events

Each square generates **two events**:

* Start at `y`
* End at `y + l`

Each event carries:

```
(y, type, xStart, xEnd)
```

### Active Structure

* Maintain a list of active **x-intervals**
* At each y-gap:

  * Merge overlapping x-intervals
  * Compute union width

---

## ğŸ“ Union Width Computation

For active x-intervals:

1. Sort by `start`
2. Merge overlaps
3. Sum merged segment lengths

This ensures **overlapping squares are counted once**.

---

## ğŸ”„ Algorithm Walkthrough

### Pass 1 â€” Build Horizontal Strips

```
for each y-event:
    process vertical gap since last y
    compute union x-width
    record strip (bottom, height, width)
```

### Pass 2 â€” Find Split Line

```
target = totalArea / 2
walk strips until accumulated â‰¥ target
interpolate y inside that strip
```

---

## âœ… Code Implementation (Your Solution)

```java []
class Solution {
    private static class Interval implements Comparable<Interval> {
        int start, end;
        Interval(int start, int end) {
            this.start = start;
            this.end = end;
        }
        public int compareTo(Interval other) {
            if (this.start != other.start) return Integer.compare(this.start, other.start);
            return Integer.compare(this.end, other.end);
        }
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Interval interval = (Interval) o;
            return start == interval.start && end == interval.end;
        }
    }

    private static class Event implements Comparable<Event> {
        int y, type, xStart, xEnd;
        Event(int y, int type, int xStart, int xEnd) {
            this.y = y;
            this.type = type;
            this.xStart = xStart;
            this.xEnd = xEnd;
        }
        public int compareTo(Event other) {
            return Integer.compare(this.y, other.y);
        }
    }

    public double separateSquares(int[][] squares) {
        List<Event> events = new ArrayList<>();
        for (int[] sq : squares) {
            events.add(new Event(sq[1], 1, sq[0], sq[0] + sq[2]));
            events.add(new Event(sq[1] + sq[2], -1, sq[0], sq[0] + sq[2]));
        }
        Collections.sort(events);

        List<Interval> active = new ArrayList<>();
        List<double[]> strips = new ArrayList<>();

        double totalArea = 0;
        int prevY = events.get(0).y;

        for (Event e : events) {
            if (e.y > prevY) {
                double width = getUnionWidth(active);
                double height = e.y - prevY;
                if (width > 0) {
                    strips.add(new double[]{prevY, height, width});
                    totalArea += width * height;
                }
            }
            Interval iv = new Interval(e.xStart, e.xEnd);
            if (e.type == 1) active.add(iv);
            else active.remove(iv);
            prevY = e.y;
        }

        double target = totalArea / 2;
        double acc = 0;

        for (double[] strip : strips) {
            double area = strip[1] * strip[2];
            if (acc + area >= target) {
                return strip[0] + (target - acc) / strip[2];
            }
            acc += area;
        }
        return 0.0;
    }

    private double getUnionWidth(List<Interval> intervals) {
        if (intervals.isEmpty()) return 0;
        List<Interval> sorted = new ArrayList<>(intervals);
        Collections.sort(sorted);

        double width = 0, end = -1e18;
        for (Interval iv : sorted) {
            if (iv.start >= end) {
                width += iv.end - iv.start;
                end = iv.end;
            } else if (iv.end > end) {
                width += iv.end - end;
                end = iv.end;
            }
        }
        return width;
    }
}
```

---

## â³ Complexity Analysis

| Metric    | Complexity             |
| --------- | ---------------------- |
| **Time**  | O(N log N + SÂ·K log K) |
| **Space** | O(N)                   |

Where:

* `N` = number of squares
* `K` = active intervals
* `S` = number of horizontal strips

---

## ğŸ¯ Why This Works

âœ” Correctly handles overlapping squares
âœ” Precise geometry using sweep line
âœ” Avoids double-counting area
âœ” Deterministic and exact (no precision guessing)

---

## âŒ Common Pitfalls

âŒ Using binary search (fails with overlaps)
âŒ Summing square areas independently
âŒ Ignoring x-interval merging

---

## ğŸ§  Interview One-Liner

> â€œWe sweep horizontally, compute union widths per strip, then find the y where cumulative union area reaches half.â€

---

## ğŸš€ Key Takeaways

* Sweep line is essential for **union area problems**
* Geometry + prefix area = clean split
* Part II is a **major step-up** from Part I
* This solution is **production-grade**

---
