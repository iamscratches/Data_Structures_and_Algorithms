# ğŸ” Minimum Cost Path With Edge Reversals

## ğŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/minimum-cost-path-with-edge-reversals/description/?envType=daily-question&envId=2026-01-27](https://leetcode.com/problems/minimum-cost-path-with-edge-reversals/description/?envType=daily-question&envId=2026-01-27)

Youâ€™re given a **directed weighted graph** with `n` nodes and edges `[u, v, w]`.

* You start at node `0`
* You want to reach node `n-1`
* You may **reverse the direction of edges**, but reversing an edge of weight `w` costs `2w`
* Traversing an edge in its original direction costs `w`

Return the **minimum cost** to reach node `n-1`, or `-1` if impossible.

---

## ğŸ§  Key Insight

This is a **shortest-path problem**, but with a twist:

* Each edge can be used in **two ways**

  * Normal direction â†’ cost `w`
  * Reversed direction â†’ cost `2w`
* Reversals are **optional** and can be mixed freely

This makes the problem perfect for **Dijkstra**, but with a **state extension**.

---

## ğŸ§© State Modeling

We model each node with **two possible states**:

```
(node, used)
```

* `node`: current vertex
* `used`: whether we arrived via a reversed edge (tracked for correctness and expansion)

Distance table:

```
dist[node][used]
```

This lets us:

* Traverse normal edges
* Traverse reversed edges (from incoming edges)

---

## âš™ï¸ Graph Construction

We build **two adjacency lists**:

| List     | Meaning                                          |
| -------- | ------------------------------------------------ |
| `out[u]` | original outgoing edges                          |
| `in[u]`  | incoming edges (used to simulate reversed edges) |

This avoids explicitly reversing the graph.

---

## ğŸš€ Algorithm (Dijkstra on Expanded State)

### Steps

1. Build `out` and `in` adjacency lists
2. Initialize `dist[][] = âˆ`
3. Push `(cost=0, node=0, used=0)` into min-heap
4. While heap not empty:

   * Pop lowest cost state
   * Relax:

     * **Normal edges** â†’ cost `+w`
     * **Reversed edges** â†’ cost `+2w`
5. Answer = minimum distance to `(n-1)`

---

## ğŸ§ª Example (Conceptual)

```
0 --(3)--> 1 --(2)--> 2
```

Options:

* Normal path: `3 + 2 = 5`
* Reverse edge `1 â† 0`: cost `6` (worse)
* Algorithm automatically picks optimal traversal

---

## âœ… Code Implementation

```java []

class Solution {
    public int minCost(int n, int[][] edges) {
        List<List<int[]>> out = new ArrayList<>();
        List<List<int[]>> in = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            out.add(new ArrayList<>());
            in.add(new ArrayList<>());
        }

        // Build adjacency lists
        for (int[] e : edges) {
            out.get(e[0]).add(new int[]{e[1], e[2]});
            in.get(e[1]).add(new int[]{e[0], e[2]});
        }

        long INF = (long) 1e18;
        long[][] dist = new long[n][2];
        for (int i = 0; i < n; i++) Arrays.fill(dist[i], INF);

        PriorityQueue<long[]> pq =
            new PriorityQueue<>((a, b) -> Long.compare(a[0], b[0]));

        dist[0][0] = 0;
        pq.add(new long[]{0, 0, 0}); // cost, node, used

        while (!pq.isEmpty()) {
            long[] cur = pq.poll();
            long cost = cur[0];
            int u = (int) cur[1];
            int used = (int) cur[2];

            if (cost > dist[u][used]) continue;

            // Traverse original edges
            for (int[] edge : out.get(u)) {
                int v = edge[0], w = edge[1];
                if (dist[v][0] > cost + w) {
                    dist[v][0] = cost + w;
                    pq.add(new long[]{dist[v][0], v, 0});
                }
            }

            // Traverse reversed edges
            if (used == 0) {
                for (int[] edge : in.get(u)) {
                    int v = edge[0], w = edge[1];
                    if (dist[v][0] > cost + 2L * w) {
                        dist[v][0] = cost + 2L * w;
                        pq.add(new long[]{dist[v][0], v, 0});
                    }
                }
            }
        }

        long ans = Math.min(dist[n - 1][0], dist[n - 1][1]);
        return ans >= INF ? -1 : (int) ans;
    }
}
```

---

## â±ï¸ Complexity Analysis

| Metric    | Complexity         |
| --------- | ------------------ |
| **Time**  | `O((V + E) log V)` |
| **Space** | `O(V + E)`         |

* Standard Dijkstra complexity
* Extra factor due to expanded state

---

## ğŸ§  Why This Works

âœ” Edge reversal is modeled via incoming edges
âœ” Cost difference handled cleanly (`w` vs `2w`)
âœ” Dijkstra guarantees minimum cost
âœ” No need to explicitly modify the graph

---

## âš  Edge Cases

| Case          | Result      |
| ------------- | ----------- |
| No path       | `-1`        |
| Single node   | `0`         |
| Cycles        | Handled     |
| Large weights | Uses `long` |

---

## ğŸ§  Interview One-Liner

> â€œModel edge reversal as incoming edges with doubled cost and run Dijkstra on an expanded state graph.â€

---

## ğŸš€ Key Takeaways

âœ” Clever graph modeling beats brute force
âœ” Incoming edges simulate reversals cleanly
âœ” Dijkstra with state extension is powerful
âœ” Production-grade solution

---
