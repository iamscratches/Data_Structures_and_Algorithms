# ğŸ”¢ Max Dot Product of Two Subsequences â€” DP with â€œMust Pickâ€ Constraint

## ğŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/max-dot-product-of-two-subsequences/description/?envType=daily-question&envId=2026-01-08](https://leetcode.com/problems/max-dot-product-of-two-subsequences/description/?envType=daily-question&envId=2026-01-08)

You are given two integer arrays `nums1` and `nums2`.

Choose **non-empty subsequences** from both arrays such that:

* The subsequences have the **same length**
* The **dot product** of the two subsequences is **maximized**

Return the maximum dot product.

---

## ğŸ§  Key Challenge

Unlike standard subsequence DP:

* **Empty subsequences are NOT allowed**
* Arrays may contain **negative numbers**
* The best result may be **negative**

So we **cannot initialize DP with 0** â€” we must allow negative answers.

---

## ğŸ’¡ Core Idea

Let:

```
dp[i][j] = maximum dot product using
           nums1[0..i-1] and nums2[0..j-1]
           with at least one pair chosen
```

At each position `(i, j)` we have three choices:

---

## ğŸ”„ Transitions

### **1ï¸âƒ£ Take both elements**

Pair:

```
nums1[i-1] Ã— nums2[j-1]
```

We may:

* Start fresh with this pair
* OR extend a previous subsequence

So:

```
take = nums1[i-1] * nums2[j-1] + max(0, dp[i-1][j-1])
```

---

### **2ï¸âƒ£ Skip nums1[i-1]**

```
dp[i-1][j]
```

---

### **3ï¸âƒ£ Skip nums2[j-1]**

```
dp[i][j-1]
```

---

### **Final transition**

```
dp[i][j] = max(take, dp[i-1][j], dp[i][j-1])
```

---

## ğŸ§ª Why `max(0, dp[i-1][j-1])`?

* If extending improves the sum â†’ use it
* If it makes things worse â†’ start fresh
* Ensures **at least one pair is selected**

---

## ğŸš« Why initialize with NEGATIVE infinity?

If all products are negative, we **must still pick one pair**.

Initializing with `0` would incorrectly allow empty subsequences.

---

## âœ… Code Implementation (Your Solution)

```java []
class Solution {
    public int maxDotProduct(int[] a, int[] b) {
        int n = a.length, m = b.length;
        int NEG = (int)-1e9;
        int[][] dp = new int[n+1][m+1];
        
        for(int i=0;i<=n;i++)
            for(int j=0;j<=m;j++)
                dp[i][j] = NEG;

        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                int take = a[i-1]*b[j-1] + Math.max(0, dp[i-1][j-1]);
                dp[i][j] = Math.max(take, Math.max(dp[i-1][j], dp[i][j-1]));
            }
        }
        return dp[n][m];
    }
}
```

---

## ğŸ“Š Example Walkthrough

### Example

```
nums1 = [2, 1, -2, 5]
nums2 = [3, 0, -6]
```

### Possible optimal subsequence:

```
[2, -2] Â· [3, -6] = 6 + 12 = 18
```

DP ensures all valid combinations are explored efficiently.

---

## â³ Complexity Analysis

| Metric          | Complexity |
| --------------- | ---------- |
| **Time**        | O(n Ã— m)   |
| **Space**       | O(n Ã— m)   |
| **Optimizable** | Yes        |

---

## ğŸ”„ Space Optimization (Optional)

We only need the previous row:

```java
int[] prev = new int[m+1];
Arrays.fill(prev, NEG);

for (int i = 1; i <= n; i++) {
    int[] curr = new int[m+1];
    Arrays.fill(curr, NEG);
    for (int j = 1; j <= m; j++) {
        int take = a[i-1]*b[j-1] + Math.max(0, prev[j-1]);
        curr[j] = Math.max(take, Math.max(prev[j], curr[j-1]));
    }
    prev = curr;
}
return prev[m];
```

**Space:** O(m)

---

## âš  Edge Cases Covered

| Scenario              | Handling                   |
| --------------------- | -------------------------- |
| All negative values   | DP still selects best pair |
| Mixed signs           | Handled naturally          |
| Single-element arrays | Works correctly            |
| Large values          | Safe within int limits     |

---

## ğŸ§  Interview One-Liner

> â€œThis is a 2D DP problem where each state represents the maximum dot product up to two prefixes, ensuring at least one pair is chosen.â€

---

## ğŸš€ Key Takeaways

âœ” Cannot initialize DP with zero
âœ” Must force at least one selection
âœ” `max(0, previous)` enables fresh start
âœ” DP over prefixes ensures optimal subsequence pairing


