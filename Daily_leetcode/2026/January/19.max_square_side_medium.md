# ğŸ”² Maximum Side Length of a Square With Sum â‰¤ Threshold

## ğŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/?envType=daily-question&envId=2026-01-19](https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/?envType=daily-question&envId=2026-01-19)

Given an `n Ã— m` matrix `mat` and an integer `threshold`, find the **maximum side length** of a square submatrix such that the **sum of its elements â‰¤ threshold**.

---

## ğŸ§  Intuition

* Brute force checking every square is too slow
* Square sums can be computed efficiently using **2D prefix sums**
* The answer (side length) is **monotonic**:

  * If a square of size `k` is possible, then all smaller sizes are also possible
* This allows **Binary Search on the side length**

---

## âš™ï¸ Approach (Your Code)

### 1ï¸âƒ£ Build 2D Prefix Sum

* Convert `mat` into a prefix sum matrix `pref`
* `pref[i][j]` = sum of all elements in rectangle `(0,0) â†’ (i,j)`

### 2ï¸âƒ£ Binary Search on Side Length

* Search range: `1 â†’ min(n, m)`
* For a given side `k`, check if **any kÃ—k square** has sum â‰¤ threshold

### 3ï¸âƒ£ Square Validation (`isValid`)

* For each possible bottom-right corner `(i, j)`
* Compute square sum in **O(1)** using inclusion-exclusion
* If any square satisfies condition â†’ valid

---

## âœ… Code (As Provided)

```java []
class Solution {

    private boolean isValid(int[][] pref, int k, int limit) {
        int n = pref.length;
        int m = pref[0].length;

        for (int i = k - 1; i < n; i++) {
            for (int j = k - 1; j < m; j++) {
                int x1 = i - k + 1;
                int y1 = j - k + 1;

                int sum = pref[i][j];
                if (x1 > 0) sum -= pref[x1 - 1][j];
                if (y1 > 0) sum -= pref[i][y1 - 1];
                if (x1 > 0 && y1 > 0) sum += pref[x1 - 1][y1 - 1];

                if (sum <= limit)
                    return true;
            }
        }
        return false;
    }

    public int maxSideLength(int[][] mat, int threshold) {
        int n = mat.length;
        int m = mat[0].length;

        int[][] pref = new int[n][m];

        // Copy matrix
        for (int i = 0; i < n; i++)
            System.arraycopy(mat[i], 0, pref[i], 0, m);

        // Row-wise prefix sum
        for (int i = 0; i < n; i++)
            for (int j = 1; j < m; j++)
                pref[i][j] += pref[i][j - 1];

        // Column-wise prefix sum
        for (int j = 0; j < m; j++)
            for (int i = 1; i < n; i++)
                pref[i][j] += pref[i - 1][j];

        int low = 1, high = Math.min(n, m);
        int ans = 0;

        while (low <= high) {
            int mid = (low + high) / 2;
            if (isValid(pref, mid, threshold)) {
                ans = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return ans;
    }
}
```

---

## ğŸ“ Prefix Sum Formula Used

For square with:

* Bottom-right: `(i, j)`
* Top-left: `(x1, y1)`

```
sum = pref[i][j]
    - pref[x1-1][j]
    - pref[i][y1-1]
    + pref[x1-1][y1-1]
```

This gives **O(1)** square sum.

---

## â± Time & Space Complexity

### â³ Time Complexity

* Prefix sum build: `O(n Ã— m)`
* Binary search: `O(log(min(n, m)))`
* Each validity check: `O(n Ã— m)`

```
Total: O(n Ã— m Ã— log(min(n, m)))
```

### ğŸ’¾ Space Complexity

```
O(n Ã— m)
```

---

## ğŸš€ Is This Already Optimal?

âœ… **Yes.**
This is the **best possible approach** under constraints.

### Why?

* You must inspect matrix values â†’ `Î©(n Ã— m)`
* Prefix sums give constant-time square queries
* Binary search minimizes checks

No further asymptotic improvement is possible.

---

## ğŸ§  Interview One-Liner

> â€œWe binary search on square size and use 2D prefix sums to check each candidate in constant time.â€

---

## âŒ Common Mistakes

* Forgetting **inclusion-exclusion correction**
* Using nested loops without prefix sums â†’ **TLE**
* Trying greedy growth without monotonic proof
* Off-by-one errors in square boundaries

---

## ğŸŸ¢ Key Takeaway

This problem combines:

* **2D Prefix Sum**
* **Binary Search on Answer**
* **Monotonic feasibility check**

ğŸ‘‰ A **classic interview pattern** worth memorizing.

---