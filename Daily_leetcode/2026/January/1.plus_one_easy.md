# âž• Plus One â€” Digit Array Arithmetic

## ðŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/plus-one/description/?envType=daily-question&envId=2026-01-01](https://leetcode.com/problems/plus-one/description/?envType=daily-question&envId=2026-01-01)

You are given a **non-empty array of digits** representing a non-negative integer.
Each digit is between `0â€“9`, and the most significant digit is at the front.

Increment the integer by **one** and return the resulting array of digits.

---

## ðŸ§  Intuition

This is exactly how we add `+1` to a number **by hand**:

* Start from the **last digit**
* Add `1`
* Handle carry if the digit becomes `10`
* Propagate carry leftward if needed
* If carry remains after the first digit â†’ create a new leading `1`

---

## âš™ï¸ Approach

1. Initialize `carry = 1` (since we add one)
2. Traverse digits from **right to left**
3. Add carry to current digit
4. Update:

   * `digit = digit % 10`
   * `carry = digit / 10`
5. If carry becomes `0`, stop early
6. If carry remains after the loop:

   * Create a new array with size `n+1`
   * Set first digit to `1`

---

## âœ… Code Implementation (Your Solution)

```java []
class Solution {
    public int[] plusOne(int[] digits) {
        int carry = 1;
        
        for(int i = digits.length - 1; i >= 0; i--){
            digits[i] = digits[i] + carry;
            carry = digits[i] / 10;
            digits[i] %= 10;
            if(carry == 0)
                break;
        }
        if(carry != 1)
            return digits;

        int sum[] = new int[digits.length + 1];
        sum[0] = 1;
        return sum;
    }
}
```

---

## ðŸ§ª Example Walkthrough

### Example 1

```
Input:  [1,2,3]
Process:
3 + 1 â†’ 4 (no carry)
Output: [1,2,4]
```

### Example 2

```
Input:  [9,9,9]
Process:
9 + 1 â†’ 0 (carry)
9 + 1 â†’ 0 (carry)
9 + 1 â†’ 0 (carry remains)

Create new array:
[1,0,0,0]
```

---

## â³ Complexity Analysis

| Metric    | Complexity                           |
| --------- | ------------------------------------ |
| **Time**  | O(n)                                 |
| **Space** | O(1) *(or O(n) if new array needed)* |

---

## ðŸ§  Why This Works (Correctness Proof)

* The algorithm simulates grade-school addition digit by digit
* Carry propagates correctly from right to left
* Early break ensures unnecessary operations are avoided
* When all digits are `9`, a new leading digit is correctly added

Thus, the returned array always represents the correct incremented number.

---

## âš¡ Most Optimized Variant (Cleaner Logic)

This version removes division and is slightly clearer:

```java []
class Solution {
    public int[] plusOne(int[] digits) {
        for (int i = digits.length - 1; i >= 0; i--) {
            if (digits[i] < 9) {
                digits[i]++;
                return digits;
            }
            digits[i] = 0;
        }
        int[] res = new int[digits.length + 1];
        res[0] = 1;
        return res;
    }
}
```

### Why This Is Optimal

* No division or modulo
* Immediate return when no carry
* Minimal operations

---

## âš  Edge Cases

| Input        | Output    |
| ------------ | --------- |
| `[0]`        | `[1]`     |
| `[9]`        | `[1,0]`   |
| `[9,9]`      | `[1,0,0]` |
| Large arrays | Efficient |

---

## ðŸš€ Final Takeaway

This problem tests:

* Array manipulation
* Carry handling
* Boundary conditions

