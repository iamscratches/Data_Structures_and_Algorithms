# üé® Number of Ways to Paint an n √ó 3 Grid

## üìú Problem Statement

**Link:** [https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/description/?envType=daily-question&envId=2026-01-03](https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/description/?envType=daily-question&envId=2026-01-03)

You have a grid with `n` rows and `3` columns.
You want to paint each cell with one of **3 colors** such that:

* No two **adjacent cells** (left/right or up/down) have the **same color**.

Return the **number of valid ways** to paint the grid modulo **10‚Åπ + 7**.

---

## üß† Intuition

Painting one row of 3 cells with no two adjacent equal can produce two types of patterns:

### Type A (ABA)

```
color1, color2, color1
```

* Middle different from edges
* Edges same

### Type B (ABC)

```
color1, color2, color3
```

* All three colors different

These are the only valid patterns for a single row with 3 colors.

Count of these:

* A: 6 (choose 2 colors, 3 choices for which color is center)
* B: 6 (3 √ó 2 √ó 1 permutations)

Now for **multiple rows**:

* A row of type A or B can be followed by either type as long as vertical constraints are respected.

We model this as a **DP on rows with two states per row**:

* `A[i]`: number of ways row i is type A
* `B[i]`: number of ways row i is type B

Transitions derive from how patterns of one row can connect to patterns of the next row:

```
A[i] ‚Üí (2 ways to stay A + 2 ways to go B)
B[i] ‚Üí (2 ways to go A + 3 ways to stay B)
```

These numbers come from enumerating color combinations respecting adjacency constraints.

---

## ‚öôÔ∏è Approach

1. Base (row 1):

   * `A = 6`, `B = 6`
2. For each subsequent row:

   * `newA = 2*A + 2*B`
   * `newB = 2*A + 3*B`
3. Use modulo `1e9 + 7`
4. Return `(A + B) % MOD`

---

## ‚úÖ Code Implementation

```java
class Solution {
    public int numOfWays(int n) {
        final int MOD = 1_000_000_007;
        long A = 6, B = 6;
        
        for (int i = 2; i <= n; i++) {
            long newA = (2 * A + 2 * B) % MOD;
            long newB = (2 * A + 3 * B) % MOD;
            A = newA;
            B = newB;
        }
        
        return (int) ((A + B) % MOD);
    }
}
```

---

## üìä Example Walkthrough

### Example 1

```
Input: n = 1
Output: 12  
Explanation: 6 (ABA) + 6 (ABC)
```

### Example 2

```
Input: n = 2
First row: 6 A + 6 B
Ways to connect:
- A ‚Üí A: 2
- A ‚Üí B: 2
- B ‚Üí A: 2
- B ‚Üí B: 3
Compute:
A2 = 2*6 + 2*6 = 24
B2 = 2*6 + 3*6 = 30
Total = 24 + 30 = 54
```

---

## ‚è≥ Complexity Analysis

| Metric    | Complexity | Explanation        |
| --------- | ---------- | ------------------ |
| **Time**  | O(n)       | Loop over n rows   |
| **Space** | O(1)       | Constant variables |

---

## üîç Why It Works

* Each row pattern has a limited set of valid successors.
* We don‚Äôt enumerate all colorings; we only count pattern types.
* We compress the exponential problem into two states ‚Üí `A` and `B`.

---

## üí° Key Observations

* Row patterns that violate adjacency rules are excluded from the start.
* The valid combinations form a **finite automaton** with transitions derived combinatorially.
* DP with constant states makes the solution fast and memory-efficient.

---

## üß† Optimization Rationale

Instead of a 2D DP array:

* We carry only current counts (`A`, `B`)
* Update them row by row
* This is a classic **matrix exponentiation pattern** (if needed for very large n)

---

## ‚ö† Edge Cases

| Input   | Output                      |
| ------- | --------------------------- |
| n = 1   | 12                          |
| n = 0   | 0* (invalid by constraints) |
| Large n | Handles modulo safely       |

---

## üöÄ Interview Tip

This problem is fundamentally about:
‚úî Pattern types
‚úî Constraints on transitions
‚úî Reducing states to constant size
‚úî Using modulo arithmetic

Phrase your reasoning as:

> ‚ÄúWe classify rows into two pattern types, model transitions, and use constant-space DP.‚Äù