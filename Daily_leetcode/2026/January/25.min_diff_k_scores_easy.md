# ğŸ“Š Minimum Difference Between Highest and Lowest of K Scores

## ğŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/description/?envType=daily-question&envId=2026-01-25](https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/description/?envType=daily-question&envId=2026-01-25)

Given:

* An integer array `nums`
* An integer `k`

You must choose **k scores** from `nums` such that the **difference between the highest and lowest** scores in the chosen group is **minimized**.

Return that **minimum possible difference**.

---

## ğŸ§  Intuition

To minimize the difference between the highest and lowest numbers in a selection of size `k`, we want the `k` numbers to be as **close together** as possible in value.

A well-known greedy strategy for this kind of range problem is:

âœ” **Sort the array first**
âœ” Then consider every `k`-length contiguous window in the sorted array
âœ” The minimum difference is the answer

Why this works:

* Sorting ensures that the closest values are adjacent
* Any optimal subset of size `k` must be a consecutive block in sorted order

---

## âš™ï¸ Approach

1. Sort `nums`
2. Initialize `minDiff = âˆ`
3. For each window ending at index `i` from `k-1` to `n-1`:

   * Compute difference:

     ```
     diff = nums[i] âˆ’ nums[i-k+1]
     ```
   * Update:

     ```
     minDiff = min(minDiff, diff)
     ```
4. Return `minDiff`

---

## ğŸ§ª Example Walkthrough

### Input

```
nums = [9,4,1,7]
k = 2
```

Sorted:

```
[1, 4, 7, 9]
```

Windows of size 2:

* `[1,4]`: diff = 3
* `[4,7]`: diff = 3
* `[7,9]`: diff = 2 â† minimum

```
Output = 2
```

---

## âœ… Code Implementation

```java []
class Solution {
    public int minimumDifference(int[] nums, int k) {
        int minDiff = Integer.MAX_VALUE;
        Arrays.sort(nums);
        for(int i = k - 1; i < nums.length; i++){
            minDiff = Math.min(minDiff, nums[i] - nums[i - k + 1]);
        }
        return minDiff;
    }
}
```

---

## â±ï¸ Complexity Analysis

| Metric    | Complexity                             |
| --------- | -------------------------------------- |
| **Time**  | O(n log n) â€” sorting                   |
| **Space** | O(1) extra space (ignoring sort space) |

---

## ğŸ§  Why This Works

* In a sorted array, the closest numbers are together
* Any group of `k` elements selected optimally will form a **contiguous segment** in the sorted list
* Checking only adjacent windows is sufficient

This transforms the problem into a classic sliding window over a sorted array.

---

## ğŸ’¡ Interview One-Liner

> â€œSort the scores and slide a window of size `k`; the smallest difference between endpoints of the window is the answer.â€

---

## âš ï¸ Edge Cases

| Case               | Output                  | Reason                |
| ------------------ | ----------------------- | --------------------- |
| `k == 1`           | `0`                     | Only one score chosen |
| All values equal   | `0`                     | All differences are 0 |
| `k == nums.length` | `max(nums) âˆ’ min(nums)` |                       |
| Negative numbers   | Works the same          |                       |

---

## ğŸš€ Key Takeaways

âœ” Sort to cluster similar values
âœ” Window size = k
âœ” Check only differences between window endpoints
âœ” O(n log n), simple and optimal
