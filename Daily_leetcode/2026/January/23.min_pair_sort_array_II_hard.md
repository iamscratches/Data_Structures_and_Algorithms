# âš¡ Minimum Pair Removal to Sort Array II â€” Optimized Greedy + Data Structures

## ğŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/minimum-pair-removal-to-sort-array-ii/description/?envType=daily-question&envId=2026-01-23](https://leetcode.com/problems/minimum-pair-removal-to-sort-array-ii/description/?envType=daily-question&envId=2026-01-23)

Youâ€™re given an integer array `nums`.

You may repeatedly:

* Choose the **adjacent pair with the minimum sum** (tie â†’ leftmost),
* Replace the pair with their sum.

Return the **minimum number of operations** required to make the array **non-decreasing**.

ğŸ‘‰ This is the **optimized version** of *Minimum Pair Removal to Sort Array I* â€” where brute force is no longer fast enough.

---

## ğŸš¨ Why Version I Fails Here

In **Array I**, constraints were small â†’ O(nÂ²) simulation worked.

In **Array II**, constraints are large:

* `n` up to **2 Ã— 10âµ**
* O(nÂ²) would TLE badly

So we need:

* Fast access to the **minimum adjacent sum**
* Fast updates when merges happen
* Efficient tracking of **inversions** (unsorted adjacent pairs)

---

## ğŸ§  High-Level Strategy

We simulate the same greedy logic **efficiently** using:

### ğŸ”‘ Core Ideas

1. **Greedy stays the same**
   Always merge the adjacent pair with **minimum sum**

2. **Track array as a linked list**

   * `left[i]`, `right[i]` â†’ simulate removals in O(1)

3. **TreeSet for minimum pair**

   * Stores `(pairSum, index)`
   * Automatically gives smallest adjacent sum

4. **Track number of inversions**

   * `flipped` = count of `a[i] > a[i+1]`
   * Once `flipped == 0`, array is sorted â†’ stop

---

## ğŸ§© Data Structures Used

| Structure           | Purpose                          |
| ------------------- | -------------------------------- |
| `TreeSet<long[]>`   | Get min adjacent sum in O(log n) |
| `left[]`, `right[]` | Doubly linked list simulation    |
| `flipped` counter   | Detect when array becomes sorted |
| `long[] array`      | Handle large sums safely         |

---

## âœ… Code Implementation (Optimized Solution)

```java []
class Solution {
    private long flipped;
    private int[] left;
    private int[] right;
    private TreeSet<long[]> pairSum;

    public int minimumPairRemoval(int[] nums) {
        int N = nums.length;
        if (N < 2) return 0;

        long[] array = new long[N];
        for (int i = 0; i < N; i++)
            array[i] = nums[i];

        flipped = 0;
        left = new int[N];
        right = new int[N];

        pairSum = new TreeSet<>((a, b) -> {
            if (a[0] != b[0])
                return Long.compare(a[0], b[0]);
            return Long.compare(a[1], b[1]);
        });

        // Initialize linked list
        for (int i = 0; i < N; i++) {
            left[i] = i - 1;
            right[i] = i + 1;
        }

        // Initialize pair sums + inversion count
        for (int i = 0; i < N - 1; i++) {
            if (array[i] > array[i + 1]) flipped++;
            pairSum.add(new long[]{array[i] + array[i + 1], i});
        }

        int operations = 0;

        while (flipped > 0) {
            long[] minPair = pairSum.pollFirst();
            int i = (int) minPair[1];
            int j = right[i];
            int h = left[i];
            int k = right[j];

            // Remove affected pairs
            remove(h, N, array);
            if (array[i] > array[j]) flipped--;
            remove(j, N, array);

            // Merge
            array[i] += array[j];
            operations++;

            // Update links
            right[i] = k;
            if (k < N) left[k] = i;

            // Add new pairs
            add(h, N, array);
            add(i, N, array);
        }

        return operations;
    }

    private void add(int i, int N, long[] array) {
        if (i >= 0 && i < N) {
            int j = right[i];
            if (j < N) {
                pairSum.add(new long[]{array[i] + array[j], i});
                if (array[i] > array[j]) flipped++;
            }
        }
    }

    private void remove(int i, int N, long[] array) {
        if (i >= 0 && i < N) {
            int j = right[i];
            if (j < N) {
                long[] target = new long[]{array[i] + array[j], i};
                if (pairSum.remove(target)) {
                    if (array[i] > array[j]) flipped--;
                }
            }
        }
    }
}
```

---

## ğŸ” Step-by-Step Whatâ€™s Happening

1. **TreeSet** always gives the smallest adjacent sum
2. **Linked list arrays** let us:

   * Remove neighbors
   * Merge in O(1)
3. **`flipped` counter** tells us when array becomes sorted
4. Only **local updates** happen after each merge

So we never rescan the entire array â€” huge win.

---

## ğŸ•’ Complexity Analysis

| Metric    | Complexity   |
| --------- | ------------ |
| **Time**  | `O(n log n)` |
| **Space** | `O(n)`       |

Why?

* Each merge â†’ O(log n) TreeSet operations
* At most `n âˆ’ 1` merges

Perfectly scalable for large inputs.

---

## ğŸ§ª Why Greedy Still Works Here

Same logic as Array I:

* Merging smallest adjacent sum causes **least disruption**
* Larger merges earlier can introduce new inversions
* This greedy strategy is provably optimal

Weâ€™ve just **optimized the execution**, not changed the logic.

---

## ğŸ§  Interview-Ready Summary

> â€œWe maintain all adjacent sums in a TreeSet and simulate merges using a linked-list structure. A counter tracks unsorted adjacent pairs, allowing us to stop early when the array becomes non-decreasing.â€

---

## ğŸ†š Comparison with Version I

| Version  | Approach              | Complexity |
| -------- | --------------------- | ---------- |
| Array I  | Brute simulation      | O(nÂ²)      |
| Array II | TreeSet + Linked List | O(n log n) |

---

## âœ… Key Takeaways

âœ” Same greedy idea, optimized
âœ” TreeSet ensures correct pair choice
âœ” Linked list avoids shifting costs
âœ” Inversion counter avoids rescans
âœ” Passes large constraints comfortably
