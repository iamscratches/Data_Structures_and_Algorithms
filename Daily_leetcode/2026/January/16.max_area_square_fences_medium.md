# üü¶ Maximum Square Area by Removing Fences From a Field

## üìú Problem Statement

**Link:** [https://leetcode.com/problems/maximum-square-area-by-removing-fences-from-a-field/description/?envType=daily-question&envId=2026-01-16](https://leetcode.com/problems/maximum-square-area-by-removing-fences-from-a-field/description/?envType=daily-question&envId=2026-01-16)

You are given a rectangular field of size `m √ó n`.

* Some **horizontal fences** and **vertical fences** can be removed.
* Fence positions are given as arrays `hFences` and `vFences`.

### Goal

Return the **maximum possible area of a square** that can be formed by removing fences.

* If no square is possible, return `-1`
* Return result modulo **10‚Åπ + 7**

---

## üß† Key Insight

A **square** can be formed **only if**:

```
horizontal gap == vertical gap
```

So the problem reduces to:

1. Compute **all possible vertical distances**
2. Compute **all possible horizontal distances**
3. Find the **largest common distance**
4. Square it

---

## üîç Strategy Overview

### Step-by-Step:

1. **Add boundary fences** (`1` and `m` / `n`)
2. **Sort** horizontal and vertical fences
3. Compute **all possible horizontal gaps**
4. Check vertical gaps against horizontal gaps
5. Track the **maximum common gap**

---

## ‚ú® Why Boundary Fences Matter

Without adding:

* `1` (top/left)
* `m`, `n` (bottom/right)

You would **miss gaps spanning the full field**.

---

## üìä Example

```
m = 5, n = 8
hFences = [2,4]
vFences = [3,6]

Horizontal gaps: {1,2,3}
Vertical gaps: {3,5}

Largest common gap = 3
Area = 3 √ó 3 = 9
```

---

## ‚úÖ Code Walkthrough

### 1Ô∏è‚É£ Add Boundary Fences

```java
h[hFences.length] = 1;
h[hFences.length + 1] = m;
```

### 2Ô∏è‚É£ Sort Fence Positions

```java
Arrays.sort(h);
Arrays.sort(v);
```

### 3Ô∏è‚É£ Store All Horizontal Gaps

```java
for (int i = 0; i < h.length; i++) {
    for (int j = i + 1; j < h.length; j++) {
        hGaps.add(h[j] - h[i]);
    }
}
```

### 4Ô∏è‚É£ Match Vertical Gaps

```java
if (hGaps.contains(v[j] - v[i])) {
    maxSide = Math.max(maxSide, v[j] - v[i]);
}
```

---

## üß© Full Code (As Given)

```java []
class Solution {
    public int maximizeSquareArea(int m, int n, int[] hFences, int[] vFences) {
        int[] h = Arrays.copyOf(hFences, hFences.length + 2);
        h[hFences.length] = 1;
        h[hFences.length + 1] = m;
        
        int[] v = Arrays.copyOf(vFences, vFences.length + 2);
        v[vFences.length] = 1;
        v[vFences.length + 1] = n;

        Arrays.sort(h);
        Arrays.sort(v);

        Set<Integer> hGaps = new HashSet<>();
        for (int i = 0; i < h.length; i++) {
            for (int j = i + 1; j < h.length; j++) {
                hGaps.add(h[j] - h[i]);
            }
        }

        long maxSide = -1;
        for (int i = 0; i < v.length; i++) {
            for (int j = i + 1; j < v.length; j++) {
                int gap = v[j] - v[i];
                if (hGaps.contains(gap)) {
                    maxSide = Math.max(maxSide, gap);
                }
            }
        }

        if (maxSide == -1) return -1;

        long MOD = 1_000_000_007;
        return (int)((maxSide * maxSide) % MOD);
    }
}
```

---

## ‚è±Ô∏è Complexity Analysis

| Metric    | Complexity |
| --------- | ---------- |
| **Time**  | O(H¬≤ + V¬≤) |
| **Space** | O(H¬≤)      |

Where:

* `H` = number of horizontal fences
* `V` = number of vertical fences

---

## ‚ö° Optimized Insight (Interview Bonus)

This solution is **already optimal** given constraints
(because every possible gap must be checked).

But you can **prune** slightly by:

* Iterating vertical gaps from largest ‚Üí smallest
* Breaking early once max found

---

## ‚ùå Common Pitfalls

* Forgetting boundary fences
* Checking only adjacent gaps
* Using grid simulation (too slow)
* Forgetting modulo for large squares

---

## üß† Interview One-Liner

> ‚ÄúA square exists if and only if a horizontal gap equals a vertical gap; we maximize that common gap.‚Äù

---

## ‚≠ê Key Takeaways

‚úî Gap-based thinking beats simulation
‚úî Boundary fences are critical
‚úî HashSet gives fast intersection
‚úî Clean geometric interpretation
