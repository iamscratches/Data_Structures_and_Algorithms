# ğŸ”¤ Find Smallest Letter Greater Than Target

## ğŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/find-smallest-letter-greater-than-target/?envType=daily-question&envId=2026-01-31](https://leetcode.com/problems/find-smallest-letter-greater-than-target/?envType=daily-question&envId=2026-01-31)

You are given:

* A **sorted** array of lowercase letters `letters`
* A character `target`

Return the **smallest character in the array that is strictly greater than `target`**.

If no such character exists, return the **first character** in the array (wrap-around).

---

## ğŸ§  Intuition

Because the array is **sorted in non-decreasing order**, the smallest character greater than `target` can be found by scanning from left to right.

* The first character `ch` such that `ch > target` is the answer.
* If none exists, wrap around â†’ return `letters[0]`

This is a classic use of:

* Linear scan
* Or binary search for better performance

---

## âš™ï¸ Approach

### **1ï¸âƒ£ Linear Scan (Simple & Clean)**

Iterate through the array:

```
for each ch in letters:
    if ch > target:
        return ch
```

If you finish the loop â†’ no greater character exists â†’ return `letters[0]`.

### **2ï¸âƒ£ (Optional) Binary Search**

Because the array is sorted, you could also do binary search:

* Find **upper bound** of `target`
* If index is out of bounds â†’ wrap to `0`

That would be `O(log n)` instead of `O(n)`.

---

## ğŸ§ª Example

```
Input: letters = ['c', 'f', 'j'], target = 'a'
Output: 'c'
Explanation: 'c' is the first letter greater than 'a'
```

```
Input: letters = ['x', 'x', 'y', 'y'], target = 'z'
Output: 'x'
Explanation: Wrap-around when none is greater
```

---

## âœ… Code Implementation (Given)

```java []
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        for (char ch : letters) {
            if (target < ch) {
                return ch;
            }
        }
        return letters[0];
    }
}
```

---

## â± Complexity Analysis

| Metric    | Complexity         |
| --------- | ------------------ |
| **Time**  | O(n) â€” linear scan |
| **Space** | O(1)               |

---

## ğŸ§  Why This Works

* Letters are sorted â†’ as soon as we see a letter > `target`, it is the **smallest such letter**
* If none found, wrap-around to first element

No need for additional data structures.

---

## âš  Edge Cases

| Input                   | Output               | Reason                    |
| ----------------------- | -------------------- | ------------------------- |
| `['a','b'], target='a'` | `'b'`                | Next greater exists early |
| `['x','y'], target='y'` | `'x'`                | Wrap around               |
| Repeated letters        | Works correctly      |                           |
| All letters same        | Always wrap to first |                           |

---

## ğŸ§  Interview One-Liner

> â€œSince the array is sorted, the first character greater than `target` is simply found by scanning; otherwise wrap to the first element.â€

---

## ğŸš€ Optional Optimization â€” Binary Search Version

If you want the fastest possible:

```java
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        int low = 0, high = letters.length - 1;
        while (low <= high) {
            int mid = low + (high - low)/2;
            if (letters[mid] <= target) low = mid + 1;
            else high = mid - 1;
        }
        return letters[low % letters.length]; 
    }
}
```

* Uses `low % n` to **wrap around**
* Time: **O(log n)**

---

## âœ… Summary

âœ” Sorted input means early exit
âœ” Wrap-around if nothing greater
âœ” Clean logic, fast in practice
âœ” Binary search is optimized alternative
