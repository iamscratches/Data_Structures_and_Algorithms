# ğŸ“Œ Divide an Array Into Subarrays With Minimum Cost I

## ğŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-i/?envType=daily-question&envId=2026-02-01](https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-i/?envType=daily-question&envId=2026-02-01)

You are given an integer array `nums` of length `n`.

* The **cost** of a subarray is the value of its **first element**.
* You must divide `nums` into **exactly 3 disjoint contiguous subarrays**.

Return the **minimum possible total cost** of these 3 subarrays.

ğŸ“Œ Example:

```
Input: nums = [1,2,3,12]
Output: 6
Explanation: Best partition â†’ [1], [2], [3,12]; cost = 1 + 2 + 3 = 6
```

Ways that are more expensive include `[1],[2,3],[12]` â†’ cost = 15, etc. ([Leetcode][1])

---

## ğŸ§  Intuition

Because the cost of a subarray only depends on its **first element**, once you decide **where the 3 subarrays start**, the total cost is just the sum of those three first elements.

Let:

* First subarray start = index `0` â†’ cost = `nums[0]`
* Second subarray start = index `i` â†’ cost = `nums[i]`
* Third subarray start = index `j` â†’ cost = `nums[j]`

You must choose indices `i` and `j` such that:

* `1 â‰¤ i < j < n`

You want to **minimize**:

```
nums[0] + nums[i] + nums[j]
```

---

## âš™ï¸ Approach

### ğŸ§  Key Insight

To minimize:

```
nums[0] + nums[i] + nums[j]
```

We fix `nums[0]`, then want to pick the **two smallest values** among the rest of the array as the starts for subarray 2 and 3.

Thus:

* Compute the smallest value among `nums[1..n-1]` â†’ call it `min1`
* Compute the second smallest value among `nums[1..n-1]` â†’ call it `min2`
* Answer = `nums[0] + min1 + min2`

This works because picking any other two that are larger would only increase the sum. ([walkccc.me][2])

---

## ğŸ’» Code Implementation

```java []
class Solution {
    public int minimumCost(int[] nums) {
        // The first segment always starts at index 0
        int base = nums[0];
        
        int min1 = Integer.MAX_VALUE;
        int min2 = Integer.MAX_VALUE;
        
        // Find the smallest and second smallest among nums[1..end]
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] < min1) {
                min2 = min1;
                min1 = nums[i];
            } else if (nums[i] < min2) {
                min2 = nums[i];
            }
        }
        
        return base + min1 + min2;
    }
}
```

---

## â±ï¸ Complexity

| Metric    | Complexity                              |
| --------- | --------------------------------------- |
| **Time**  | O(n) â€” single pass to find two minimums |
| **Space** | O(1) â€” constant extra space             |

---

## ğŸ§  Why This Works

The total cost depends only on **three subarray starting elements**.
Since the first is fixed (`nums[0]`), you just need the two smallest values in the remainder to minimize cost.

Instead of scanning all possible splits (which would be O(nÂ²)), this picks the best split in one scan.

This is correct because:

* You are looking for the **minimum sum of 3 values**,
* The constraint that subarrays must be contiguous is automatically satisfied by picking any two starting positions after 0, as long as positions are distinct and increasing.

---

## ğŸ§ª Example Walkthrough

```
nums = [10,3,1,1]
```

Sorted candidates after index 0: `[3,1,1]`
Smallest = `1`, second smallest = `1`
Answer = `10 + 1 + 1 = 12` (matches examples). ([Leetcode][1])

---

## âš  Edge Cases

| Input              | Output              | Explanation                             |
| ------------------ | ------------------- | --------------------------------------- |
| `[5,4,3]`          | `12`                | Only possible partition â†’ `[5],[4],[3]` |
| All elements equal | `3Ã—nums[0]`         | Each pick gives the same cost           |
| n = 3              | Sum of all elements | Only one way to partition               |

---

## ğŸ§  Interview One-Liner

> â€œSince the cost only depends on the first element of each subarray, fix the first, then choose the two smallest remaining values as starts to minimize total cost.â€

---

## ğŸš€ Key Takeaway

âœ” No need to try all splits
âœ” Just pick the two smallest values after `nums[0]`

---