# ðŸ“Œ Number of Steps to Reduce a Number in Binary Representation to One

## ðŸ“œ Problem Statement

**Link:**  
[https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/description/?envType=daily-question&envId=2026-02-26](https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/description/?envType=daily-question&envId=2026-02-26)

Given a binary string `s` representing a positive integer, return the number of steps to reduce it to "1" using these operations:

- If the number is even, divide it by 2.  
- If the number is odd, add 1 to it.

Repeat the process until the number becomes "1".

**Example:**  
Input: `s = "1101"`  
Process:
- "1101" (13, odd) â†’ "1110" (14)
- "1110" (14, even) â†’ "111" (7)
- "111" (7, odd) â†’ "1000" (8)
- ... and so on  
Output: `6`

---

# ðŸ§  Understanding the Problem

- Only two operations allowed, based on parity.
- The binary string can be very large (hundreds of characters), so direct conversion to int may not work.
- Each operation can be described in terms of single bits at the end of the number:
  - If ends with 0: divide (just remove last bit)
  - If ends with 1 (not single digit "1"): add 1 (may propagate carries leftward)

---

# ðŸ’» Your Solution

### Approach:

- Simulate the process step by step:
  - Convert string to int array for easier mutation.
  - If current number ends with 0: just move left (division).
  - If ends with 1: add 1 (simulate carrying over).
- Repeat until only the leftmost 1 is present.

### Code (Cleaned):

```java []
class Solution {
    public int numSteps(String s) {
        char[] sch = s.toCharArray();
        int[] ch = new int[sch.length+1];
        ch[0] = 0;
        for(int i = 0; i < sch.length; i++){
            ch[i+1] = sch[i]-'0';
        }
        int pointer = ch.length-1;
        int steps = 0;
        while(shouldContinue(ch, pointer)){
            if(ch[pointer] == 0){
                pointer--;
            }
            else{
                int i=ch.length-1, j=pointer;
                while(j >= 0) ch[i--] = ch[j--];
                while(i >= 0) ch[i--] = 0;
                i = ch.length-1;
                pointer = i;
                while(ch[i] == 1) ch[i--] = 0;
                ch[i] = 1;
            }
            steps++;
        }
        return steps;
    }
    private boolean shouldContinue(int[] ch, int pointer){
        for(int i = 0; i < ch.length; i++){
            if(i == pointer) continue;
            if(ch[i] == 1) return true;
        }
        return false;
    }
}
```

---

# â±ï¸ Complexity Analysis

- Each step = O(N) (since propagating carries or moving pointers at most length of input)
- For length N, worst-case O(NÂ²) if simulation is used.

---

# ðŸ”Ž Can We Do Better?

Yesâ€”there's an O(N) greedy solution:

- Work backward from rightmost bit to the left.
- Idea:
  - If bit is `0`, a division step.
  - If bit is `1`, an addition step (which may propagate and create more 0's, making further divisions possible).
  - Use a carry flag to remember when "add 1" was done and subsequent bits need to be handled accordingly.

### Optimized Greedy Code:

```java []
class Solution {
    public int numSteps(String s) {
        int steps = 0, carry = 0;
        for (int i = s.length() - 1; i > 0; i--) {
            int bit = s.charAt(i) - '0';
            if (bit + carry == 1) {
                steps += 2; // add 1, then divide
                carry = 1; // next higher bit needs to be incremented
            } else {
                steps += 1; // divide by 2
                // carry stays the same
            }
        }
        // Final check at the highest bit: if carry, one more step may be needed, but loop structure already accounts for it
        return steps + carry;
    }
}
```

---

# ðŸ’¡ Key Insight

- Each '1' after the leftmost contributes extra step due to needing an add before division.
- Simulate with a carry to track if a higher bit needs increment from previous "add 1".

---

# ðŸ”¥ Comparison

| Approach           | Time      | Notes                             |
|--------------------|-----------|-----------------------------------|
| Simulation         | O(NÂ²)     | Simulates string as array         |
| Greedy (carry)     | O(N)      | Linear, one pass from right to left|

---

# ðŸ§  Takeaway

- For large binary strings, simulate operations directly on the string or by bits with O(N).
- The greedy/carry approach is optimal and recommended.
