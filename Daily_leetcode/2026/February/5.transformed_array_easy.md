# ğŸ“Œ Transformed Array

## ğŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/transformed-array/?envType=daily-question&envId=2026-02-05](https://leetcode.com/problems/transformed-array/?envType=daily-question&envId=2026-02-05)

You are given an integer array `nums` of length `n`.

You must construct a new array `res` of the same length such that for each index `i`:

* If `nums[i] == 0` â†’ `res[i] = 0`
* If `nums[i] > 0` â†’ rotate **right** by `nums[i]`
* If `nums[i] < 0` â†’ rotate **left** by `|nums[i]|`

Rotation is **circular**, meaning indices wrap around using modulo arithmetic.

---

## ğŸ§  Key Observation

This problem is **index transformation**, not array rotation.

For every index `i`:

* We compute a **target index**
* Assign `res[i] = nums[targetIndex]`

No actual shifting of arrays is needed.

---

## ğŸ” Index Rules

Let `n = nums.length`

### Case 1: `nums[i] == 0`

```java
res[i] = 0;
```

---

### Case 2: `nums[i] > 0` (Right Rotation)

```java
target = (i + nums[i]) % n
res[i] = nums[target]
```

âœ”ï¸ Modulo keeps the index inside bounds.

---

### Case 3: `nums[i] < 0` (Left Rotation)

Naively:

```java
target = i + nums[i]
```

But `target` might be **negative**, so we wrap it:

```java
target = ((i + nums[i]) % n + n) % n
```

The given code achieves this in a slightly longer but correct way.

---

## ğŸ§© Code Walkthrough

```java []
class Solution {
    public int[] constructTransformedArray(int[] nums) {
        int len = nums.length;
        int[] res = new int[len];

        for(int i = 0; i < len; i++){
            int rotate = nums[i];

            // Case 1: No rotation
            if(rotate == 0){
                res[i] = 0;
            }
            // Case 2: Rotate right
            else if(rotate > 0){
                rotate = (i + rotate) % len;
                res[i] = nums[rotate];
            }
            // Case 3: Rotate left
            else{
                rotate = i + rotate;
                if(rotate >= 0){
                    res[i] = nums[rotate];
                }
                else{
                    rotate = Math.abs(rotate % len);
                    res[i] = rotate > 0 ? nums[len - rotate] : nums[rotate];
                }
            }
        }
        return res;
    }
}
```

---

## ğŸ§  Intuition Behind Negative Index Handling

When `i + rotate < 0`, Javaâ€™s `%` gives a **negative remainder**, so the code:

```java
rotate = Math.abs(rotate % len);
res[i] = nums[len - rotate];
```

âœ”ï¸ This simulates circular wrapping from the end.

---

## â±ï¸ Complexity Analysis

| Metric | Complexity |
| ------ | ---------- |
| Time   | **O(n)**   |
| Space  | **O(n)**   |

Only one pass through the array.

---

## âœ… Correctness

âœ” Handles:

* Positive rotations
* Negative rotations
* Large rotation values
* Circular indexing

âœ” No extra data structures
âœ” No unnecessary array rotations

---

## ğŸ§ª Example

```text
nums = [1, -1, 0, 2]
```

| i | nums[i] | target index | res[i] |
| - | ------- | ------------ | ------ |
| 0 | 1       | 1            | -1     |
| 1 | -1      | 0            | 1      |
| 2 | 0       | â€”            | 0      |
| 3 | 2       | 1            | -1     |

---

## ğŸš€ Cleaner (Optional) Version

Same logic, simpler math:

```java
int target = ((i + nums[i]) % len + len) % len;
res[i] = nums[i] == 0 ? 0 : nums[target];
```

---

## ğŸ¯ Final Takeaway

> This problem is all about **modular arithmetic on indices**.

Once you stop thinking in terms of â€œrotating arraysâ€ and instead think:
ğŸ‘‰ *â€œWhere should this index read from?â€*
the solution becomes straightforward.