# ðŸ“Œ Sum of Root To Leaf Binary Numbers

## ðŸ“œ Problem Statement

**Link:**  
[https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/description/?envType=daily-question&envId=2026-02-24](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/description/?envType=daily-question&envId=2026-02-24)

You are given the root of a binary tree where each node has a value of `0` or `1`.  
Each root-to-leaf path represents a binary number formed by concatenating the node values along the path.

* Return the sum of these numbers for all root-to-leaf paths.
* The answer is guaranteed to fit within a 32-bits integer.

**Example:**  
```
      1
     / \
    0   1
   / \ / \
  0  1 0  1

Paths:
- 100 (4)
- 101 (5)
- 110 (6)
- 111 (7)

Sum = 4 + 5 + 6 + 7 = 22
```

---

# ðŸ§  Understanding the Problem

- Each path from root to leaf forms a binary number by reading node values along the path.
- You must evaluate all such paths and add the resulting decimal values.

**Root to leaf:** means from the tree root down to a node with no children.

---

# ðŸ’» Your Solution

### Approach:

1. Traverse the tree recursively (DFS).
2. As you go, build up the current path's binary value (using integer shifting).
3. When at a leaf, add this value to the answer.

### Code (Cleaned):

```java []
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int sum = 0;
    public int sumRootToLeaf(TreeNode root) {
        traverseLeaf(root, 0);
        return sum;
    }
    private void traverseLeaf(TreeNode node, int val){
        val = (val << 1) | node.val;
        if(node.left == null && node.right == null){
            sum += val;
            return;
        }
        if(node.left != null){
            traverseLeaf(node.left, val);
        }
        if(node.right != null){
            traverseLeaf(node.right, val);
        }
    }
}
```

---

# â±ï¸ Complexity Analysis

- Visit every node once:  
  - **Time:** O(n) where n = number of nodes.
  - **Space:** O(h) where h = height of the tree (recursion stack).

---

# ðŸ”Ž Can We Do Better?

The above solution is optimal for both time and space:
- You must visit every node (O(n)).
- There is no way to avoid traversing each root-to-leaf path.

For an iterative version, use an explicit Stack.

---

# ðŸš€ Iterative Approach (Optional)

You can solve this problem with an explicit stack (avoiding recursion):

```java []
class Solution {
    public int sumRootToLeaf(TreeNode root) {
        int sum = 0;
        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<>();
        stack.push(new Pair<>(root, 0));

        while (!stack.isEmpty()) {
            Pair<TreeNode, Integer> p = stack.pop();
            TreeNode node = p.getKey();
            int val = (p.getValue() << 1) | node.val;

            if (node.left == null && node.right == null) {
                sum += val;
            }
            if (node.right != null) stack.push(new Pair<>(node.right, val));
            if (node.left != null) stack.push(new Pair<>(node.left, val));
        }
        return sum;
    }
}
```
*(You may need a custom Pair class or use AbstractMap.SimpleEntry for Java.)*

---

# ðŸ’¡ Key Insight

- Use bit operations to efficiently construct the binary number as you traverse.
- At each node, just do `val = (val << 1) | node.val`.
- Add to total only at leaves.

---

# ðŸ”¥ Comparison

| Approach     | Time   | Space     | Notes                     |
|--------------|--------|-----------|---------------------------|
| Recursive    | O(n)   | O(h)      | Simple, clear, optimal    |
| Iterative    | O(n)   | O(h)      | Avoids recursion stack    |

---

# ðŸ§  Takeaway

- This is a standard root-to-leaf path accumulation (classic DFS on tree).
- Use bit manipulation to accumulate binary values efficiently.
