# ðŸ“Œ Check if a String Contains All Binary Codes of Size K

## ðŸ“œ Problem Statement

**Link:**  
[https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/description/?envType=daily-question&envId=2026-02-23](https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/description/?envType=daily-question&envId=2026-02-23)

Given a binary string `s` and an integer `k`:

- Return `true` if every possible binary code of length `k` is a substring of `s`.  
- Otherwise, return `false`.

**Example:**  
If `s = "00110110"`, `k = 2`  
All possible 2-length binary codes: `"00"`, `"01"`, `"10"`, `"11"`  
All present as substrings, so return `true`.

---

# ðŸ§  Understanding the Problem

- "Binary codes" of length `k`: All strings of length `k` containing only '0' and '1'.
- There are `2^k` such codes (for `k=3` â†’ `000`, `001`, ..., `111`).
- Task: Check that every such sequence appears as a substring somewhere in `s`.

---

# ðŸ’» Your Solution

### Approach:

1. Use a `Set` to collect all unique substrings of length `k` in `s`.
2. Iterate over every window of length `k`.
3. If the count of unique substrings equals `2^k`, return `true`.

### Code (Cleaned):

```java []
class Solution {
    public boolean hasAllCodes(String s, int k) {
        Set<String> binarySet = new HashSet<>();
        for(int i = 0; i <= s.length() - k; i++) {
            binarySet.add(s.substring(i, i + k));
        }
        // Optionally print for debugging:
        // System.out.println(binarySet.size() + " " + binarySet);
        return binarySet.size() == (1 << k);
    }
}
```

---

# â±ï¸ Complexity Analysis

- Loop: O(nÂ·k) (where `n = s.length()`)
  - Each window: extract substring (O(k)), add to set.
- Space: Up to O(2^k) for the set (since each k-length binary code can appear once).

### Final Complexity

```
Time  â†’ O(nÂ·k)
Space â†’ O(2^k)
```

---

# ðŸ”Ž Can We Do Better?

**Can substring extraction be faster?**  
Yes; with bit manipulation, treat the string as a running integer window (sliding window, O(n)), which slightly speeds up substring checking for large k.  
However: For most constraints, the simple set-based approach is clean and efficient enough and accepted by LeetCode.

**Key constraint:** `k` can be up to 20, so 2^k = 1,048,576, which is manageable.

---

# ðŸš€ Optimized Solution: Bitmask Sliding Window

Instead of extracting substrings, keep a rolling integer of the last `k` bits:

- Represent each k-length substring by its integer value (hash).
- Use a boolean array of size `2^k` to track which codes have been seen.
- Slide the window through the string, updating with O(1) bitwise operations.

### Complete Java Solution

```java []
class Solution {
    public boolean hasAllCodes(String s, int k) {
        int total = 1 << k; // Total possible binary codes of length k
        boolean[] seen = new boolean[total];
        int hash = 0;
        int allOnes = (1 << k) - 1;
        int count = 0;

        for (int i = 0; i < s.length(); i++) {
            // Update hash: shift left and add current bit, keep last k bits only
            hash = ((hash << 1) & allOnes) | (s.charAt(i) - '0');
            // Start recording after window has reached size k
            if (i >= k - 1) {
                if (!seen[hash]) {
                    seen[hash] = true;
                    count++;
                    if (count == total) return true;
                }
            }
        }
        return count == total;
    }
}
```

**Why is this better?**

- No substring extraction: Each window is updated in O(1).
- Much faster when `k` is large or the string is long.

**Time Complexity:** O(n),  
**Space Complexity:** O(2^k)

---

# ðŸ’¡ Key Insight

- There are exactly `2^k` possible binary codes of size `k`.
- Any missing code means the answer is false.
- Sufficient to aggregate all unique k-length substrings.

---

# ðŸ”¥ Comparison

| Approach           | Time                 | Space     | Notes                      |
|--------------------|----------------------|-----------|----------------------------|
| HashSet + Substr   | O(nÂ·k)               | O(2^k)    | Simple, easy, accepted     |
| Bitmask Window     | O(n)                 | O(2^k)    | Slightly faster, more code |

---

# ðŸ§  Takeaway

- Use a set to aggregate substrings, compare to the total number of possible binary codes.
- For larger k or substring extraction bottlenecks, use bit manipulation for O(n) performance.
