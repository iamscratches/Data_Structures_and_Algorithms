# ðŸ“Œ Minimum Removals to Balance Array

## ðŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/minimum-removals-to-balance-array/?envType=daily-question&envId=2026-02-06](https://leetcode.com/problems/minimum-removals-to-balance-array/?envType=daily-question&envId=2026-02-06)

You are given an integer array `nums` and an integer `k`.

An array is called **balanced** if for every pair `(i, j)` in the array:

```
nums[j] â‰¤ nums[i] * k
```

Your task is to **remove the minimum number of elements** so that the remaining array is balanced.

---

## ðŸ§  Key Insight

Instead of thinking about *what to remove*, think about:

> **What is the largest subset we can keep that is already balanced?**

Then:

```
answer = total elements âˆ’ largest valid subset
```

---

## ðŸ”‘ Observations

1. Sorting the array helps:

   * If the array is sorted, we only need to check:

     ```
     max â‰¤ min * k
     ```
2. After sorting, any valid balanced subset must be a **contiguous subarray**.
3. This becomes a classic **two-pointer / sliding window** problem.

---

## ðŸ§© Strategy (Two Pointers)

1. Sort the array.
2. Maintain a window `[start, end)`:

   * `nums[end] â‰¤ nums[start] * k`
3. Expand `end` while the condition holds.
4. Track the maximum window size.
5. Skip duplicate `start` values to avoid redundant checks.

---

## ðŸ§ª Why Skip Duplicates?

If:

```
nums[start] == nums[start - 1]
```

Then the same window constraints apply, so checking again is useless.

This optimization keeps the solution efficient.

---

## ðŸ’» Code Walkthrough

```java []
class Solution {
    public int minRemoval(int[] nums, int k) {
        Arrays.sort(nums);

        int start = 0, end = 0;
        int max = 0;

        while (start < nums.length) {

            // Expand window while condition holds
            while (end < nums.length &&
                   (long) nums[end] <= (long) nums[start] * k) {
                end++;
            }

            // Update maximum valid window
            max = Math.max(max, end - start);

            // Move start forward
            start++;

            // Skip duplicates
            while (start < nums.length && nums[start] == nums[start - 1]) {
                start++;
            }
        }

        // Minimum removals = total - largest valid subset
        return nums.length - max;
    }
}
```

---

## ðŸ§  Example Walkthrough

### Input

```text
nums = [4, 1, 2, 8], k = 2
```

### After Sorting

```text
nums = [1, 2, 4, 8]
```

### Windows Checked

* `[1, 2]` â†’ valid
* `[2, 4]` â†’ valid
* `[1, 2, 4]` â†’ valid
* `[1, 2, 4, 8]` â†’ âŒ (8 > 1Ã—2)

âœ” Largest valid window size = `3`

### Result

```
4 âˆ’ 3 = 1
```

---

## â±ï¸ Complexity Analysis

| Metric       | Complexity     |
| ------------ | -------------- |
| Sorting      | **O(n log n)** |
| Two pointers | **O(n)**       |
| Space        | **O(1)**       |

---

## âœ… Why This Works

* Sorting guarantees monotonic behavior
* Sliding window ensures optimal range
* Duplicate skipping avoids redundant work
* Uses `long` to avoid overflow in `nums[start] * k`

---

## ðŸŽ¯ Final Takeaway

> This problem is a **maximum valid subarray** problem disguised as a removal problem.

Once you flip the perspective:

> *â€œWhatâ€™s the biggest balanced set I can keep?â€*
> the solution becomes clean and efficient.
