# ğŸ“Œ Longest Balanced Subarray II

## ğŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/longest-balanced-subarray-ii/description/?envType=daily-question&envId=2026-02-11](https://leetcode.com/problems/longest-balanced-subarray-ii/description/?envType=daily-question&envId=2026-02-11)

Youâ€™re given an integer array `nums`.

A subarray is **balanced** if:

1. All elements are **distinct**
2. The number of **even elements equals odd elements**

Return the **maximum length** of such a subarray.

---

# ğŸ§  Why Problem II Is Harder

In **Problem I**, we used brute force (O(nÂ²)).
In **Problem II**, constraints are large â†’ brute force will TLE.

We need something closer to:

```
O(n log n)
```

This solution achieves that using:

* âœ… Segment Tree
* âœ… Prefix Sum technique
* âœ… HashMap for distinct constraint
* âœ… Reverse iteration

---

# ğŸ’¡ Core Idea

We convert the problem into a **prefix sum problem**:

### Transform array into:

```
even  â†’ +1
odd   â†’ -1
```

Now:

A subarray is balanced â‡”

```
sum(subarray) = 0
```

AND we must ensure:

* Each number appears only once in the subarray

---

# ğŸ” High-Level Strategy

We iterate from **right to left**.

For each starting index `l`:

1. Maintain only the **first occurrence** of every value
2. Maintain a segment tree over the transformed balance array
3. Find the **rightmost index `r`** such that:

```
prefixSum(r) == 0
```

If found:

```
length = r - l + 1
```

Take maximum.

---

# ğŸ—ï¸ Segment Tree Design

Each node stores:

| Field | Meaning                       |
| ----- | ----------------------------- |
| `sum` | Total sum of segment          |
| `mn`  | Minimum prefix sum in segment |
| `mx`  | Maximum prefix sum in segment |

This allows us to:

* Efficiently check if a prefix with given target sum exists
* Binary search inside segment tree

---

# âš™ï¸ How Distinctness Is Maintained

We use:

```java
HashMap<Integer, Integer> first
```

It stores:

```
value â†’ first occurrence index (from current l)
```

If the number appears again:

* Remove old occurrence from segment tree
* Insert new one at current position

So at any time:

* Each value appears at most once
* Distinct constraint satisfied

---

# ğŸ” Finding Rightmost Prefix = 0

We need:

```
sum(w[l..r]) = 0
```

Since segment tree maintains prefix sums,
we search for:

```
prefixSum(r) == 0
```

Using:

```java
find_rightmost_prefix(0)
```

Segment tree efficiently navigates to the correct index.

---

# ğŸ’» Clean Version of Your Code

```java []
class Solution {
    public int longestBalanced(int[] nums) {
        int n = nums.length;

        SegmentTree stree = new SegmentTree(n);
        HashMap<Integer, Integer> first = new HashMap<>();

        int result = 0;

        for (int l = n - 1; l >= 0; --l) {
            int num = nums[l];

            // Remove old occurrence
            Integer old = first.get(num);
            if (old != null)
                stree.update(old, 0);

            // Insert current
            first.put(num, l);
            stree.update(l, (num % 2 == 0) ? 1 : -1);

            // Find rightmost prefix = 0
            int r = stree.find_rightmost_prefix(0);

            if (r >= l)
                result = Math.max(result, r - l + 1);
        }

        return result;
    }
}
```

---

# â±ï¸ Complexity Analysis

| Component        | Complexity |
| ---------------- | ---------- |
| Each update      | O(log n)   |
| Each query       | O(log n)   |
| Total iterations | n          |

### âœ… Final Complexity:

```
Time  â†’ O(n log n)
Space â†’ O(n)
```

Much better than O(nÂ²).

---

# ğŸ§ª Example

### Input:

```
[1, 2, 3, 4]
```

Transformed:

```
[-1, +1, -1, +1]
```

Prefix sums:

```
[-1, 0, -1, 0]
```

Rightmost prefix 0 gives full length = 4.

---

# ğŸ”¥ Why This Is Elegant

This solution cleverly combines:

* Prefix sum balancing
* Distinct element tracking
* Segment tree range tracking
* Rightmost prefix search

It transforms a complicated subarray condition into:

```
Find longest prefix sum = 0 under uniqueness constraint
```

Very strong interview-level solution.

---

# ğŸ§  Key Takeaways

* Converting parity to +1/-1 simplifies balance problems
* Segment trees can track prefix ranges
* Right-to-left iteration simplifies distinct constraint
* Problem II upgrades brute force â†’ advanced data structure

---
