# ðŸ“Œ Trionic Array I

## ðŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/trionic-array-i/description/?envType=daily-question&envId=2026-02-03](https://leetcode.com/problems/trionic-array-i/description/?envType=daily-question&envId=2026-02-03)

An array `nums` is called **trionic** if it can be divided into **exactly three contiguous non-empty parts** such that:

1. The **first part is strictly increasing**
2. The **second part is strictly decreasing**
3. The **third part is strictly increasing**

ðŸ‘‰ All comparisons must be **strict** (`<` or `>`), **no equal adjacent elements allowed**.

---

## ðŸ§  Key Insight

A trionic array has **exactly two â€œdirection changesâ€**:

```
Increasing â†’ Decreasing â†’ Increasing
```

So if we track the **trend flips**, we should see:

* Start with increasing
* Flip once to decreasing
* Flip again to increasing
* No more flips after that

Thatâ€™s it. Any extra flip â†’ âŒ not trionic.

---

## ðŸªœ Strategy Used in the Code

The solution uses:

* A variable `flip` to track the current phase:

  | flip | Expected Trend |
  | ---- | -------------- |
  | 1    | Increasing     |
  | 2    | Decreasing     |
  | 3    | Increasing     |

* Iterate through the array:

  * If the current trend continues â†’ OK
  * If it changes â†’ increment `flip`
  * If `flip > 3` â†’ invalid

* Also reject:

  * Equal adjacent elements
  * Invalid start/end conditions

---

## ðŸ’» Code (Given)

```java []
class Solution {
    public boolean isTrionic(int[] nums) {
        int flip = 1;

        // Edge sanity check
        if(nums[1] < nums[0] || nums[nums.length - 1] < nums[nums.length - 1]){
            return false;
        }

        for(int i = 1; i < nums.length; i++){
            // No equal adjacent elements allowed
            if(nums[i] == nums[i - 1]){
                return false;
            }

            if(flip <= 3){
                // Check if current trend continues
                if((flip % 2 == 0 && nums[i] < nums[i - 1]) || 
                   (flip % 2 != 0 && nums[i] > nums[i - 1])){
                    continue;
                } else {
                    // Trend changed
                    flip++;
                }
            } else {
                return false;
            }
        }

        return flip == 3;
    }
}
```

---

## ðŸ” How It Works (Step-by-Step)

### Example âœ”ï¸

```
nums = [1, 3, 5, 4, 2, 6, 8]
```

| i | nums[i-1] â†’ nums[i] | Trend | flip |
| - | ------------------- | ----- | ---- |
| 1 | 1 â†’ 3               | â†‘     | 1    |
| 2 | 3 â†’ 5               | â†‘     | 1    |
| 3 | 5 â†’ 4               | â†“     | 2    |
| 4 | 4 â†’ 2               | â†“     | 2    |
| 5 | 2 â†’ 6               | â†‘     | 3    |
| 6 | 6 â†’ 8               | â†‘     | 3    |

âœ”ï¸ Ends with `flip == 3` â†’ **Trionic**

---

### Example âŒ

```
nums = [1, 3, 2, 4, 3]
```

Trends:

```
â†‘ â†“ â†‘ â†“
```

Thatâ€™s **4 segments**, not allowed â†’ âŒ

---

## â±ï¸ Complexity Analysis

| Metric | Complexity |
| ------ | ---------- |
| Time   | **O(n)**   |
| Space  | **O(1)**   |

Single pass, constant memory.

---

## ðŸ§  Why This Works

* Trionic arrays have **exactly two direction changes**
* Using parity (`flip % 2`) cleanly encodes:

  * odd â†’ increasing
  * even â†’ decreasing
* Strict checks ensure correctness

---

## ðŸŽ¯ Final Takeaway

> A trionic array is just a **strict up â†’ down â†’ up** sequence â€” no more, no less.

This solution nails it with:

* One pass
* No extra space
* Clean state tracking
