# ğŸ§  Binary Gap

### ğŸ“Œ Problem Summary

Given a positive integer `n`, find the **longest distance between two consecutive `1`s** in its binary representation.

* Distance = number of positions between the two `1`s.
* If fewer than two `1`s exist â†’ return `0`.

---

## ğŸ§ª Example

| n  | Binary | Output | Explanation                |
| -- | ------ | ------ | -------------------------- |
| 22 | 10110  | 2      | gap between first two `1`s |
| 8  | 1000   | 0      | only one `1`               |
| 5  | 101    | 2      | distance between two `1`s  |

---

# ğŸ” Your Approach (Given Code)

### âœ… Idea

* Traverse bits from LSB to MSB.
* Track distance between consecutive `1`s.
* Update maximum distance.

### â± Complexity

* **Time:** O(log n)
* **Space:** O(1)

---

## âœ… Cleaned Version of Your Code

```java []
class Solution {
    public int binaryGap(int n) {
        int dist = 0;
        int max = 0;
        int count = 0;

        while (n > 0) {
            if ((n & 1) == 1) {
                if (count > 0) {
                    max = Math.max(max, dist);
                }
                dist = 1;
                count++;
            } else {
                dist++;
            }
            n >>= 1;
        }
        return count < 2 ? 0 : max;
    }
}
```

---

# ğŸš€ Most Optimized Solution

### ğŸ’¡ Key Insight

Track the **index of the last seen `1`** instead of counting distances manually.

This avoids extra counters and simplifies logic.

---

## â­ Optimized Code

```java
class Solution {
    public int binaryGap(int n) {
        int last = -1;
        int maxGap = 0;
        int index = 0;

        while (n > 0) {
            if ((n & 1) == 1) {
                if (last != -1) {
                    maxGap = Math.max(maxGap, index - last);
                }
                last = index;
            }
            index++;
            n >>= 1;
        }
        return maxGap;
    }
}
```

---

# ğŸ†š Why This is More Optimized

| Aspect        | Your Code         | Optimized        |
| ------------- | ----------------- | ---------------- |
| Variables     | 3 counters        | 2 counters       |
| Logic         | Distance tracking | Index difference |
| Readability   | Moderate          | Very clear       |
| Edge handling | Manual            | Natural          |

Both are **O(log n)**, but the optimized version is cleaner and less error-prone.

---

# ğŸ§© Alternative (String Approach)

### â— Less optimal but intuitive

```java
class Solution {
    public int binaryGap(int n) {
        String binary = Integer.toBinaryString(n);
        int last = -1, maxGap = 0;

        for (int i = 0; i < binary.length(); i++) {
            if (binary.charAt(i) == '1') {
                if (last != -1) {
                    maxGap = Math.max(maxGap, i - last);
                }
                last = i;
            }
        }
        return maxGap;
    }
}
```

* Time: O(log n)
* Space: O(log n) (string)

---

# ğŸ Final Recommendation

âœ” Use the **index tracking solution** for interviews.
âœ” Your approach is correct and efficient â€” just slightly more complex than necessary.