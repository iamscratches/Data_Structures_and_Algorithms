# ðŸ“Œ Trionic Array II

## ðŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/trionic-array-ii/description/?envType=daily-question&envId=2026-02-04](https://leetcode.com/problems/trionic-array-ii/description/?envType=daily-question&envId=2026-02-04)

You are given an integer array `nums`.

A **trionic subarray** is a contiguous subarray that can be split into **three non-empty parts** such that:

1. First part is **strictly increasing**
2. Second part is **strictly decreasing**
3. Third part is **strictly increasing**

ðŸ‘‰ Your task is to **find the maximum possible sum** of any trionic subarray.

If no such subarray exists, return the minimum possible value (effectively handled by the logic).

---

## ðŸ§  High-Level Idea

Instead of checking all subarrays (which would be too slow), the solution:

1. **Precomputes best increasing sums**

   * Ending at every index
   * Starting at every index
2. **Splits the array into strictly decreasing segments**
3. For each decreasing segment:

   * Tries to extend it on the **left** with a valid increasing subarray
   * Tries to extend it on the **right** with a valid increasing subarray
4. Maximizes the total sum

This turns a brute-force nightmare into a **linear-time solution**.

---

## ðŸ§© Key Components in the Code

### ðŸ”¹ 1. `Triple` Class

Represents a **strictly decreasing subarray**.

```java
static class Triple {
    int p, q;      // start and end indices
    long sum;      // sum of elements in [p, q]
}
```

---

### ðŸ”¹ 2. `decompose(nums)`

Splits the array into **maximal strictly decreasing segments**.

```java []
public List<Triple> decompose(int[] nums){
    int n = nums.length;
    List<Triple> subarrays = new ArrayList<>();

    int l = 0;
    long sum = nums[0];

    for(int i = 1; i < n; i++){
        if(nums[i - 1] <= nums[i]){
            subarrays.add(new Triple(l, i - 1, sum));
            l = i;
            sum = 0;
        }
        sum += nums[i];
    }
    subarrays.add(new Triple(l, n - 1, sum));
    return subarrays;
}
```

ðŸ“Œ Result: each `Triple(p, q, sum)` is a **strictly decreasing middle segment**.

---

### ðŸ”¹ 3. `maxEndingAt[]`

Maximum sum of a **strictly increasing subarray ending at `i`**.

```java
for(int i = 0; i < n; i++){
    maxEndingAt[i] = nums[i];
    if(i > 0 && nums[i - 1] < nums[i]){
        if(maxEndingAt[i - 1] > 0){
            maxEndingAt[i] += maxEndingAt[i - 1];
        }
    }
}
```

âž¡ï¸ Think **Kadaneâ€™s Algorithm**, but only when the array is increasing.

---

### ðŸ”¹ 4. `maxStartingAt[]`

Maximum sum of a **strictly increasing subarray starting at `i`**.

```java
for(int i = n - 1; i >= 0; i--){
    maxStartingAt[i] = nums[i];
    if(i < n - 1 && nums[i] < nums[i + 1]){
        if(maxStartingAt[i + 1] > 0){
            maxStartingAt[i] += maxStartingAt[i + 1];
        }
    }
}
```

---

## ðŸ§® Final Assembly Logic

```java
for(Triple t : PQS){
    int p = t.p;
    int q = t.q;
    long sum = t.sum;

    if(p > 0 && nums[p - 1] < nums[p] &&
       q < n - 1 && nums[q] < nums[q + 1] &&
       p < q){

        long cand = maxEndingAt[p - 1] + sum + maxStartingAt[q + 1];
        ans = Math.max(ans, cand);
    }
}
```

### Conditions ensure:

* Left side is **strictly increasing**
* Middle is **strictly decreasing**
* Right side is **strictly increasing**
* All three parts are **non-empty**

---

## ðŸ’» Full Code (Given)

```java []
class Solution {
    static class Triple {
        int p, q;
        long sum;
        Triple(int p, int q, long sum){
            this.p = p;
            this.q = q;
            this.sum = sum;
        }
    }

    public List<Triple> decompose(int[] nums){
        int n = nums.length;
        List<Triple> subarrays = new ArrayList<>();

        int l = 0;
        long sum = nums[0];

        for(int i = 1; i < n; i++){
            if(nums[i - 1] <= nums[i]){
                subarrays.add(new Triple(l, i - 1, sum));
                l = i;
                sum = 0;
            }
            sum += nums[i];
        }
        subarrays.add(new Triple(l, n - 1, sum));
        return subarrays;
    }

    public long maxSumTrionic(int[] nums){
        int n = nums.length;

        long[] maxEndingAt = new long[n];
        for(int i = 0; i < n; i++){
            maxEndingAt[i] = nums[i];
            if(i > 0 && nums[i - 1] < nums[i] && maxEndingAt[i - 1] > 0){
                maxEndingAt[i] += maxEndingAt[i - 1];
            }
        }

        long[] maxStartingAt = new long[n];
        for(int i = n - 1; i >= 0; i--){
            maxStartingAt[i] = nums[i];
            if(i < n - 1 && nums[i] < nums[i + 1] && maxStartingAt[i + 1] > 0){
                maxStartingAt[i] += maxStartingAt[i + 1];
            }
        }

        List<Triple> PQS = decompose(nums);
        long ans = Long.MIN_VALUE;

        for(Triple t : PQS){
            int p = t.p, q = t.q;

            if(p > 0 && q < n - 1 &&
               nums[p - 1] < nums[p] &&
               nums[q] < nums[q + 1] &&
               p < q){

                long cand = maxEndingAt[p - 1] + t.sum + maxStartingAt[q + 1];
                ans = Math.max(ans, cand);
            }
        }
        return ans;
    }
}
```

---

## â±ï¸ Complexity Analysis

| Metric | Complexity |
| ------ | ---------- |
| Time   | **O(n)**   |
| Space  | **O(n)**   |

âœ”ï¸ Efficient enough for large inputs.

---

## ðŸŽ¯ Final Takeaway

> **Trionic Array II = Kadane + Monotonic Decomposition**

* Decreasing segments act as **anchors**
* Increasing sums on both sides **maximize contribution**
* Elegant linear-time solution to a tricky-looking problem
