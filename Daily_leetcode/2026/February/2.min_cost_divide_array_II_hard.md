# ğŸ“Œ Divide an Array Into Subarrays With Minimum Cost II

## ğŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/description/?envType=daily-question&envId=2026-02-02](https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/description/?envType=daily-question&envId=2026-02-02)

You are given:

* An integer array `nums`
* An integer `k` â†’ number of subarrays
* An integer `dist`

### Rules

* The array must be divided into **exactly `k` disjoint contiguous subarrays**
* The **cost of a subarray** = its **first element**
* The **distance constraint**:
  If the first subarray starts at index `0`, then the starting index of the *last* subarray must be **â‰¤ dist + 1**

### Goal

ğŸ‘‰ Minimize the **sum of costs** of the `k` subarrays.

---

## ğŸ§  Key Insight

* The **first subarray must start at index `0`**
* So `nums[0]` is **always included**
* You now need to choose **`k-1` additional starting indices**
* Those indices must lie within a **sliding window**:

  ```
  [1 â€¦ dist + 1]
  ```

As the window slides, you must **always keep the smallest possible sum of `k-1` elements inside it**.

---

## ğŸ§© Problem Reduction

The problem becomes:

> From a sliding window of size `(dist + 1)`, **continuously pick the smallest `k-1` values**, and track the minimum sum.

This is a classic **â€œsliding window + dynamic k-smallest elementsâ€** problem.

---

## âš™ï¸ Data Structure Strategy

We maintain **two ordered sets (TreeSets)**:

### 1ï¸âƒ£ `using`

* Holds the **current smallest `k-1` elements**
* These contribute to the cost
* We track their sum â†’ `windowSum`

### 2ï¸âƒ£ `waiting`

* Holds the remaining elements in the window

Both are ordered by:

```
value first, index second
```

(to safely handle duplicates)

---

## ğŸªœ Step-by-Step Approach

### ğŸ”¹ Initialization

* Window = `[1 â€¦ dist+1]`
* Add all indices into `using`
* Move the **largest** elements into `waiting` until:

  ```
  using.size() == k - 1
  ```

### ğŸ”¹ Sliding the Window

For each shift:

1. Add new index entering window â†’ `waiting`
2. Remove index leaving window
3. Rebalance `using` and `waiting`
4. Maintain the **smallest possible sum**
5. Update result

Finally:

```
answer = nums[0] + minimum windowSum
```

---

## ğŸ’» Code (Your Given Solution, Explained)

```java []
class Solution {

    public long minimumCost(int[] nums, int k, int dist) {

        int n = nums.length;
        long result = Long.MAX_VALUE;
        long windowSum = 0L;

        // Holds k-1 smallest elements
        TreeSet<Integer> using = new TreeSet<>(
            (a, b) -> nums[a] == nums[b] ? a - b : nums[a] - nums[b]
        );

        // Holds remaining elements in window
        TreeSet<Integer> waiting = new TreeSet<>(
            (a, b) -> nums[a] == nums[b] ? a - b : nums[a] - nums[b]
        );

        // Initial window: [1 ... dist+1]
        for (int i = 1; i <= dist + 1; i++) {
            using.add(i);
            windowSum += nums[i];
        }

        // Keep only k-1 smallest
        while (using.size() > k - 1) {
            int idx = using.pollLast(); // remove largest
            windowSum -= nums[idx];
            waiting.add(idx);
        }

        result = Math.min(result, windowSum);

        // Slide window
        for (int i = 1; i + dist + 1 < n; i++) {

            // Add new index
            waiting.add(i + dist + 1);

            // If removed index was contributing
            if (using.contains(i)) {
                using.remove(i);
                windowSum -= nums[i];

                int idx = waiting.pollFirst();
                using.add(idx);
                windowSum += nums[idx];
            } else {
                waiting.remove(i);

                int wMin = waiting.first();
                int uMax = using.last();

                // Rebalance if beneficial
                if (nums[wMin] < nums[uMax]) {
                    using.remove(uMax);
                    waiting.add(uMax);
                    windowSum -= nums[uMax];

                    waiting.remove(wMin);
                    using.add(wMin);
                    windowSum += nums[wMin];
                }
            }

            result = Math.min(result, windowSum);
        }

        return result + nums[0];
    }
}
```

---

## â±ï¸ Complexity Analysis

| Metric | Complexity        |
| ------ | ----------------- |
| Time   | **O(n log dist)** |
| Space  | **O(dist)**       |

TreeSet operations dominate (`log dist`).

---

## ğŸ§  Why This Is Optimal

* Brute force: âŒ exponential
* Sorting every window: âŒ too slow
* This method keeps the **k-1 smallest dynamically**, which is exactly what we need

This is a **textbook sliding window + balanced BST** solution.

---

## ğŸ§ª Example Walkthrough

```
nums = [1,3,2,6,4,2]
k = 3
dist = 3
```

Initial window â†’ indices `[1,2,3,4]`
Pick smallest 2 â†’ `{2,3}`
Cost = `1 + 2 + 3 = 6`

Window slides â†’ rebalances â†’ finds better combo if possible

---

## ğŸ§  Interview One-Liner

> â€œFix the first subarray at index 0, then use a sliding window with two balanced sets to always keep the smallest kâˆ’1 elements under the distance constraint.â€

---

## ğŸš€ Key Takeaways

âœ” Fix `nums[0]`
âœ” Reduce problem to k-smallest sliding window
âœ” TreeSet gives ordered dynamic control
âœ” Elegant, optimal, interview-grade solution

---