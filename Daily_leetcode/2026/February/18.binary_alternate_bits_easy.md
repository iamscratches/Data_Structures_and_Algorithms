## üîπ Binary Number with Alternating Bits

---

# üß© Problem Summary

Given a positive integer `n`, determine whether its binary representation has **alternating bits** ‚Äî meaning no two adjacent bits are the same.

### ‚úÖ Valid examples

* `5  ‚Üí 101` ‚Üí ‚úÖ alternating
* `10 ‚Üí 1010` ‚Üí ‚úÖ alternating

### ‚ùå Invalid examples

* `7 ‚Üí 111` ‚Üí ‚ùå not alternating
* `11 ‚Üí 1011` ‚Üí ‚ùå last two bits same

---

# üí° Approach in Your Code

### üîç Idea

* Track expected bit (`sign`).
* Compare each bit with expected pattern.
* Flip expectation each step.

### üß† How it works

```java []
int sign = n & 1;   // last bit
while(n > 0) {
    if(((n ^ sign) & 1) != 0) return false;
    sign ^= 1;      // toggle expected bit
    n >>= 1;
}
```

### ‚è± Complexity

* **Time:** `O(log n)` (number of bits)
* **Space:** `O(1)`

---

# ‚ö†Ô∏è Issues in Your Code

Your logic is clever but slightly overcomplicated.

### ‚ùó Problem

Using XOR with `sign` works, but the intent is harder to read and maintain.

---

# ‚úÖ Cleaner Version (Same Logic)

```java []
class Solution {
    public boolean hasAlternatingBits(int n) {
        int prev = n & 1;
        n >>= 1;

        while (n > 0) {
            int curr = n & 1;
            if (curr == prev) return false;
            prev = curr;
            n >>= 1;
        }
        return true;
    }
}
```

‚úî Easier to understand
‚úî Same performance

---

# üöÄ Most Optimized Solution (Bit Trick)

### üî• Key Insight

If bits alternate:

```
n = 101010...
n >> 1 = 010101...
XOR ‚Üí 111111...
```

A sequence of all 1s has property: `x & (x + 1) == 0`.

### ‚úÖ Optimal Code

```java []
class Solution {
    public boolean hasAlternatingBits(int n) {
        int x = n ^ (n >> 1);
        return (x & (x + 1)) == 0;
    }
}
```

---

# üß† Why This Works

Example: `n = 10 (1010)`

```
n        = 1010
n >> 1   = 0101
XOR      = 1111  (all ones)
```

All ones ‚Üí valid alternating bits.

---

# ‚è± Complexity (Optimal)

* **Time:** `O(1)`
* **Space:** `O(1)`
* Uses constant bit operations.

---

# üèÅ Final Comparison

| Approach   | Time     | Space | Readability | Interview Value |
| ---------- | -------- | ----- | ----------- | --------------- |
| Your logic | O(log n) | O(1)  | Medium      | Good            |
| Clean loop | O(log n) | O(1)  | ‚≠ê‚≠ê‚≠ê‚≠ê        | Very good       |
| Bit trick  | **O(1)** | O(1)  | ‚≠ê‚≠ê‚≠ê         | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê           |

