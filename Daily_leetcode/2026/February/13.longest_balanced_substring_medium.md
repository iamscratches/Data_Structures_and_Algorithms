# ğŸ“Œ Longest Balanced Substring II

## ğŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/longest-balanced-substring-ii/description/?envType=daily-question&envId=2026-02-13](https://leetcode.com/problems/longest-balanced-substring-ii/description/?envType=daily-question&envId=2026-02-13)

Given a string `s` consisting only of characters:

```
'a', 'b', 'c'
```

A substring is **balanced** if:

> All characters that appear in the substring appear the **same number of times**.

Return the **maximum length** of a balanced substring.

---

# ğŸ§  Key Differences from Part I

| Feature               | Substring I | Substring II             |
| --------------------- | ----------- | ------------------------ |
| Alphabet size         | 26 letters  | Only 3 letters (`a,b,c`) |
| Optimization possible | Limited     | âœ… Strong optimizations   |
| Target complexity     | O(nÂ²)       | âœ… O(n) possible          |

Because the alphabet is tiny (3), we can use prefix differences.

---

# ğŸ’¡ Balanced Conditions (Important)

For substring to be balanced:

### Case 1 â€” Only one char

```
"aaa" â†’ valid
```

### Case 2 â€” Two chars equal frequency

```
"aabb" â†’ valid
"abab" â†’ valid
```

### Case 3 â€” Three chars equal frequency

```
"abcabc" â†’ valid
"aabbcc" â†’ valid
```

---

# ğŸ’» Your Provided Solution â€” Overview

Your code cleverly splits into **3 scenarios**:

```
1ï¸âƒ£ calc1 â†’ single character substrings
2ï¸âƒ£ calc2 â†’ two-character balance
3ï¸âƒ£ calc3 â†’ three-character balance
```

Final answer = max of all.

This is an **optimal O(n)** solution.

---

# ğŸ” Code Breakdown

## ğŸ”¹ Main Function

```java []
public int longestBalanced(String s) {
    char[] cs = s.toCharArray();
    int x = calc1(cs);
    int y = Math.max(calc2(cs, 'a', 'b'),
            Math.max(calc2(cs, 'b', 'c'), calc2(cs, 'a', 'c')));
    int z = calc3(cs);
    return Math.max(x, Math.max(y, z));
}
```

We compute:

| Variable | Meaning                                 |
| -------- | --------------------------------------- |
| `x`      | longest single-character substring      |
| `y`      | best two-character balanced substring   |
| `z`      | best three-character balanced substring |

---

# ğŸ§© Case 1: Single Character (calc1)

### Idea:

Find longest block of identical characters.

```java []
private int calc1(char[] s) {
    int res = 0;
    int i = 0, n = s.length;
    while (i < n) {
        int j = i + 1;
        while (j < n && s[j] == s[i]) j++;
        res = Math.max(res, j - i);
        i = j;
    }
    return res;
}
```

### Example:

```
aaabb â†’ longest = 3
```

### Complexity:

```
O(n)
```

---

# ğŸ§© Case 2: Two Characters Balanced (calc2)

### Idea:

Convert problem into:

```
count(a) == count(b)
```

We track difference:

```
d = count(a) - count(b)
```

If same `d` seen before â†’ balanced substring.

### Code:

```java []
private int calc2(char[] s, char a, char b) {
    int res = 0;
    int i = 0, n = s.length;

    while (i < n) {
        while (i < n && s[i] != a && s[i] != b) i++;

        Map<Integer, Integer> pos = new HashMap<>();
        pos.put(0, i - 1);
        int d = 0;

        while (i < n && (s[i] == a || s[i] == b)) {
            d += (s[i] == a) ? 1 : -1;

            if (pos.containsKey(d)) {
                res = Math.max(res, i - pos.get(d));
            } else {
                pos.put(d, i);
            }
            i++;
        }
    }
    return res;
}
```

### Why it works:

If prefix difference repeats â†’ equal counts.

### Example:

```
a b a b
1 0 1 0 â†’ diff repeats â†’ balanced
```

### Complexity:

```
O(n) per pair
Total pairs: 3
â†’ O(n)
```

---

# ğŸ§© Case 3: Three Characters Balanced (calc3)

### Balanced condition:

```
count(a) = count(b) = count(c)
```

We track two differences:

```
x = count(a) - count(b)
y = count(b) - count(c)
```

If both repeat â†’ balanced substring.

---

### Code:

```java []
private int calc3(char[] s) {
    Map<Long, Integer> pos = new HashMap<>();
    pos.put(f(0, 0), -1);

    int[] cnt = new int[3];
    int res = 0;

    for (int i = 0; i < s.length; i++) {
        char c = s[i];
        ++cnt[c - 'a'];

        int x = cnt[0] - cnt[1];
        int y = cnt[1] - cnt[2];

        long key = f(x, y);

        if (pos.containsKey(key)) {
            res = Math.max(res, i - pos.get(key));
        } else {
            pos.put(key, i);
        }
    }
    return res;
}
```

---

### Why two differences?

If:

```
a-b = 0
b-c = 0
```

Then:

```
a=b=c
```

---

### Hash key encoding

```java
private long f(int x, int y) {
    return (x + 100000) << 20 | (y + 100000);
}
```

Ensures unique mapping of pair `(x,y)`.

---

# â±ï¸ Complexity Analysis

| Part      | Time   |
| --------- | ------ |
| calc1     | O(n)   |
| calc2     | O(n)   |
| calc3     | O(n)   |
| **Total** | â­ O(n) |

Space:

```
O(n) for hash maps
```

---

# ğŸ† Why This Is Optimal

Because:

* Alphabet size = 3
* We can track differences
* Prefix technique reduces to O(n)

For larger alphabets â†’ not possible.

---

# ğŸ”¥ Example Walkthrough

### Input:

```
s = "abccbaabc"
```

Balanced substrings include:

```
abc
cba
abcabc
```

Output:

```
6
```

---

# ğŸ§  Interview Insight

### Key idea:

Balanced substring â†’ prefix difference equality.

Use:

```
Two chars â†’ 1 difference
Three chars â†’ 2 differences
```

General rule:

```
k chars â†’ track (k-1) differences
```

---

# âš–ï¸ Comparison: I vs II

| Feature              | Substring I  | Substring II        |
| -------------------- | ------------ | ------------------- |
| Alphabet             | 26           | 3                   |
| Best Time            | O(nÂ²)        | â­ O(n)              |
| Technique            | brute + math | prefix diff hashing |
| Interview difficulty | Medium       | Hard                |

---
