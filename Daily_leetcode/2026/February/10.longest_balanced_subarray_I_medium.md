# ðŸ“Œ Longest Balanced Subarray I

## ðŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/longest-balanced-subarray-i/?envType=daily-question&envId=2026-02-10](https://leetcode.com/problems/longest-balanced-subarray-i/?envType=daily-question&envId=2026-02-10)

Youâ€™re given an integer array `nums`.

A subarray is called **balanced** if:

* It contains **distinct elements only**
* The **number of even elements equals the number of odd elements**

Your task is to return the **maximum length** of such a subarray.

---

## ðŸ§  Core Idea

This solution uses a **brute-force + pruning** approach:

* Fix a starting index `i`
* Extend the subarray to the right (`j`)
* Track:

  * Distinct elements (via a `Set`)
  * Count of even numbers
  * Count of odd numbers
* Update the maximum length whenever:

  ```
  evenCount == oddCount
  ```

---

## ðŸ”‘ Important Constraints Handled

### 1ï¸âƒ£ Distinct Elements

A `HashSet` ensures we donâ€™t reuse numbers inside the same subarray.

If a duplicate appears:

* We **donâ€™t extend the set**
* But we still check if the current subarray is balanced

---

### 2ï¸âƒ£ Balance Condition

For each new element:

* If even â†’ `evenSum++`
* If odd â†’ `oddSum++`

Balanced when:

```
evenSum == oddSum
```

---

### 3ï¸âƒ£ Early Exit Optimization

If:

```
maxLen >= nums.length - i
```

then no longer subarray is possible starting from `i`, so we break early.

This avoids unnecessary work.

---

## ðŸ’» Code Walkthrough

```java []
class Solution {
    public int longestBalanced(int[] nums) {
        int maxLen = 0;
        Set<Integer> set = new HashSet<>();
        int evenSum = 0, oddSum = 0;

        for (int i = 0; i < nums.length; i++) {

            for (int j = i; j < nums.length; j++) {

                // If duplicate encountered
                if (set.contains(nums[j])) {
                    if (evenSum == oddSum) {
                        maxLen = Math.max(maxLen, j - i + 1);
                    }
                    continue;
                }

                // Add new element
                set.add(nums[j]);

                if (nums[j] % 2 == 0) evenSum++;
                else oddSum++;

                if (evenSum == oddSum) {
                    maxLen = Math.max(maxLen, j - i + 1);
                }
            }

            // Reset for next starting index
            set.clear();
            evenSum = 0;
            oddSum = 0;

            // Pruning
            if (maxLen >= nums.length - i) break;
        }

        return maxLen;
    }
}
```

---

## ðŸ§ª Example Walkthrough

### Input

```text
nums = [1, 2, 3, 4]
```

### Valid Balanced Subarrays

* `[1, 2]` â†’ 1 odd, 1 even âœ…
* `[3, 4]` â†’ 1 odd, 1 even âœ…
* `[1, 2, 3, 4]` â†’ 2 odd, 2 even âœ…

âœ” **Answer = 4**

---

## â±ï¸ Complexity Analysis

| Aspect | Complexity |
| ------ | ---------- |
| Time   | **O(nÂ²)**  |
| Space  | **O(n)**   |

* Nested loops â†’ O(nÂ²)
* HashSet stores at most `n` elements

---

## âš ï¸ Limitations of This Approach

* Works fine for **small constraints**
* Will **TLE** for large `n`
* This is expected for **Problem I** (intro version)

---

## ðŸ§  Key Takeaways

* Brute force is acceptable when constraints are small
* Tracking balance with counters is simple and effective
* Pruning (`maxLen >= remaining length`) is a nice optimization
* This sets the stage for **Problem II**, where optimizations are mandatory
