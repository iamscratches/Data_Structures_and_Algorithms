## ğŸ”¹ Count Binary Substrings

---

# ğŸ§© Problem Summary

Given a binary string `s`, count the number of substrings that:

1. Contain equal number of `0`s and `1`s
2. All `0`s and all `1`s are grouped consecutively

### âœ… Valid substrings

For `"00110011"`:

* `"0011"`
* `"01"`
* `"1100"`
* `"10"`
* `"0011"`
* `"01"`

Output â†’ **6**

---

# ğŸ’¡ Approach in Your Code

### ğŸ” Core Idea

Track lengths of consecutive groups of same characters.

Example:

```
s = 00110011
groups = [2,2,2,2]
```

Valid substrings between adjacent groups:

```
min(2,2) + min(2,2) + min(2,2) = 6
```

---

# ğŸ§  How Your Code Works

```java
int res = 0, prev = 0, strk = 1;
```

* `strk` â†’ current streak length
* `prev` â†’ previous streak length
* `res` â†’ answer

### Loop logic

```java
if (s.charAt(i) == s.charAt(i - 1))
    strk++;
else {
    prev = strk;
    strk = 1;
}

if (strk <= prev) res++;
```

### ğŸ”‘ Insight

Each time current group length â‰¤ previous group length â†’ a valid substring exists.

---

# â± Complexity

* **Time:** `O(n)`
* **Space:** `O(1)`
* Single pass, constant memory.

---

# âš ï¸ Issues in Your Code

Your solution is already **optimal and clean**.
No logical errors.

Only improvement â†’ naming for readability.

---

# âœ… Cleaner Version (Same Logic)

```java []
class Solution {
    public int countBinarySubstrings(String s) {
        int result = 0;
        int prevGroup = 0;
        int currGroup = 1;

        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == s.charAt(i - 1)) {
                currGroup++;
            } else {
                prevGroup = currGroup;
                currGroup = 1;
            }

            if (currGroup <= prevGroup) result++;
        }
        return result;
    }
}
```

âœ” More readable
âœ” Same efficiency

---

# ğŸš€ Alternative Optimal Approach (Explicit Group Counting)

### Idea

Store group sizes and sum min of adjacent groups.

```java []
class Solution {
    public int countBinarySubstrings(String s) {
        List<Integer> groups = new ArrayList<>();
        int count = 1;

        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == s.charAt(i - 1)) count++;
            else {
                groups.add(count);
                count = 1;
            }
        }
        groups.add(count);

        int result = 0;
        for (int i = 1; i < groups.size(); i++) {
            result += Math.min(groups.get(i), groups.get(i - 1));
        }

        return result;
    }
}
```

### Trade-off

* Uses extra space `O(n)`
* Easier to visualize.

---

# ğŸ§  Why the Optimal Approach Works

Valid substrings exist **only at boundaries between groups**.

Example:

```
000111
groups: [3,3]
valid substrings: min(3,3) = 3
â†’ 01, 0011, 000111
```

---

# ğŸ Final Comparison

| Approach       | Time | Space | Readability | Interview Value |
| -------------- | ---- | ----- | ----------- | --------------- |
| Your solution  | O(n) | O(1)  | â­â­â­â­        | â­â­â­â­â­           |
| Cleaner naming | O(n) | O(1)  | â­â­â­â­â­       | â­â­â­â­â­           |
| Group array    | O(n) | O(n)  | â­â­â­â­        | â­â­â­             |

---

# ğŸ¯ Interview Tips

If asked follow-ups:

* Works for any two-character grouping pattern.
* Can extend to count grouped substrings in other contexts.

---