# ğŸ“Œ Longest Balanced Substring I

## ğŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/longest-balanced-substring-i/description/?envType=daily-question&envId=2026-02-12](https://leetcode.com/problems/longest-balanced-substring-i/description/?envType=daily-question&envId=2026-02-12)

Given a string `s` consisting of lowercase English letters.

A substring is **balanced** if:

> All characters that appear in the substring appear the **same number of times**.

Return the **maximum length** of a balanced substring.

---

# ğŸ§  Understanding the Definition

A substring is balanced if:

```
"abab"     â†’ a=2, b=2  â†’ âœ… balanced
"aaabbb"   â†’ a=3, b=3  â†’ âœ… balanced
"aabbcc"   â†’ a=2, b=2, c=2 â†’ âœ… balanced
"aabbb"    â†’ a=2, b=3  â†’ âŒ not balanced
```

Important:

* Characters that do **not appear** donâ€™t matter.
* All appearing characters must have equal frequency.

---

# ğŸ’» Your Current Solution

### Approach:

* Try all substrings (i â†’ j)
* Maintain frequency array of size 26
* Check if substring is balanced

### Code (Cleaned)

```java []
class Solution {
    public int longestBalanced(String s) {
        int[] freq = new int[26];
        int maxLen = 0;

        for (int i = 0; i < s.length(); i++) {
            for (int j = i; j < s.length(); j++) {
                char ch = s.charAt(j);
                freq[ch - 'a']++;

                if (isBalanced(freq)) {
                    maxLen = Math.max(maxLen, j - i + 1);
                }
            }

            Arrays.fill(freq, 0);
        }
        return maxLen;
    }

    private boolean isBalanced(int[] freq) {
        int val = 0;
        for (int i = 0; i < 26; i++) {
            if (val == 0 && freq[i] != 0) {
                val = freq[i];
            } else if (freq[i] != 0 && val != freq[i]) {
                return false;
            }
        }
        return true;
    }
}
```

---

# â±ï¸ Complexity Analysis

Outer loop â†’ O(n)
Inner loop â†’ O(n)
Check balance â†’ O(26)

### Final Complexity:

```
Time  â†’ O(nÂ²)
Space â†’ O(1)
```

This works for small constraints.

---

# ğŸ” Can We Do Better?

Yes â€” we can optimize the **balance check**.

Currently:

* For every substring, you scan all 26 characters.

Instead, we can track:

* Number of distinct characters
* Minimum frequency
* Maximum frequency

Balanced condition becomes:

```
maxFreq == minFreq
```

For non-zero frequencies.

---

# ğŸš€ Optimized O(nÂ²) Solution (Faster in Practice)

We maintain:

* `distinct` count
* `minFreq`
* `maxFreq`

Instead of scanning 26 each time.

```java []
class Solution {
    public int longestBalanced(String s) {
        int n = s.length();
        int maxLen = 0;

        for (int i = 0; i < n; i++) {
            int[] freq = new int[26];
            int distinct = 0;
            int maxFreq = 0;

            for (int j = i; j < n; j++) {
                int idx = s.charAt(j) - 'a';

                if (freq[idx] == 0)
                    distinct++;

                freq[idx]++;
                maxFreq = Math.max(maxFreq, freq[idx]);

                int len = j - i + 1;

                // Balanced condition:
                // total length must be divisible by distinct
                if (len % distinct == 0) {
                    int expected = len / distinct;
                    if (maxFreq == expected) {
                        maxLen = Math.max(maxLen, len);
                    }
                }
            }
        }
        return maxLen;
    }
}
```

---

# ğŸ’¡ Why This Works

For a substring to be balanced:

```
Total length = distinct Ã— frequency
```

So:

```
len % distinct == 0
```

And

```
maxFreq == len / distinct
```

If one character reached expected frequency,
others must also match (because total length matches).

So we avoid scanning all 26 characters every time.

---

# â±ï¸ Optimized Complexity

Still:

```
Time â†’ O(nÂ²)
Space â†’ O(1)
```

But constant factor is much better.

---

# ğŸ† Can We Do Better Than O(nÂ²)?

For this specific problem (Substring I):

âŒ No known O(n log n) or O(n) solution
because:

* Every starting index can produce different frequency distributions
* No monotonic sliding window property exists

So O(nÂ²) is acceptable and expected.

---

# ğŸ§  Key Insight

Balanced substring means:

```
All appearing characters have equal frequency
```

Equivalent mathematical condition:

```
length = distinct Ã— frequency
```

That observation removes the need for full 26 scan.

---

# ğŸ”¥ Comparison

| Approach           | Time                   | Practical Speed |
| ------------------ | ---------------------- | --------------- |
| Your original      | O(nÂ² Ã— 26)             | Good            |
| Optimized version  | O(nÂ²)                  | Better          |
| Better than O(nÂ²)? | âŒ Not possible (for I) |                 |

---

