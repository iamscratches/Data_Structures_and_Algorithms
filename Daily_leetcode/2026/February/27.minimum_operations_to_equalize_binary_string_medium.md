# ðŸ“Œ Minimum Operations to Equalize Binary String

## ðŸ“œ Problem Statement

**Link:**  
[https://leetcode.com/problems/minimum-operations-to-equalize-binary-string/description/?envType=daily-question&envId=2026-02-27](https://leetcode.com/problems/minimum-operations-to-equalize-binary-string/description/?envType=daily-question&envId=2026-02-27)

You are given a binary string `s` and an integer `k`.

In one operation, you can pick any substring of length `k` and flip **all the bits** in it (change `'0'` to `'1'` and vice versa). Find the **minimum number of operations** required to make all the characters in `s` equal.  
If it is impossible, return `-1`.

**Example:**  
Input: `s = "1001", k = 2`  
Output: `2`

---

# ðŸ§  Understanding the Problem

- You can flip any substring of length `k` per operation.
- Want to make the string all '0's or all '1's with as few operations as possible.
- Operations may overlap.
- Carefully consider batch flipping and the parity of k and s' zeros/ones.

---

# ðŸ’» Your Solution

### Approach:

- Count the number of zeros in the string.
- If already equal (either all '0's or all '1's) â†’ 0 operations needed.
- If you flip the entire string at once (`len == k`):
  - If all are zeros or all are ones, only one operation might be needed.
- Otherwise, calculate the minimum number of operations using the divisibility and parity of the zeros and remaining string.
- Uses several bit tricks for compactness.

### Code (Cleaned):

```java []
class Solution {
    public int minOperations(String s, int k) {
        int zero = 0;
        int len = s.length();

        for (int i = 0; i < len; i++)
            zero += ~s.charAt(i) & 1;

        if (zero == 0)
            return 0;

        if (len == k)
            return ((zero == len ? 1 : 0) << 1) - 1;

        int base = len - k;

        int odd = Math.max(
            (zero + k - 1) / k,
            (len - zero + base - 1) / base
        );

        odd += ~odd & 1;

        int even = Math.max(
            (zero + k - 1) / k,
            (zero + base - 1) / base
        );

        even += even & 1;

        int res = Integer.MAX_VALUE;

        if ((k & 1) == (zero & 1))
            res = Math.min(res, odd);

        if ((~zero & 1) == 1)
            res = Math.min(res, even);

        return res == Integer.MAX_VALUE ? -1 : res;
    }
}
```

---

# â±ï¸ Complexity Analysis

- Counting zeros: O(n)
- All arithmetic/branching: O(1)
- **Overall:** O(n)

---

# ðŸ”Ž Can We Do Better?

This code is already optimal O(n) and cleverly reduces the number of operations by analyzing divisibility and parity.  
The real trick is the mathematical observation about overlap and the interplay of bits and substring flipping.

A more readable greedy implementation also exists for the case where k and n are coprime or k=1/n; see problem's editorial.

---

# ðŸ’¡ Key Insight

- When flipping substrings of k, overlapping and parity define whether it's possible and how many minimum moves.
- Calculate the minimum for flipping zeros-to-ones and ones-to-zeros, and account for parity constraints.

---

# ðŸ”¥ Comparison

| Approach            | Time    | Notes                               |
|---------------------|---------|-------------------------------------|
| Bit tricks/math     | O(n)    | Compact, optimal, sometimes opaque  |
| Greedy/sliding      | O(n)    | More transparent for small k        |

---

# ðŸ§  Takeaway

- For batch substring flips, focus on parity and the mathematical constraints in the string's structure.
- Sometimes, a mathematical approach is dramatically shorter and much faster than brute force simulation.
