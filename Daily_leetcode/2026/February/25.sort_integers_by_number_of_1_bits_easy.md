# ðŸ“Œ Sort Integers by The Number of 1 Bits

## ðŸ“œ Problem Statement

**Link:**  
[https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/?envType=daily-question&envId=2026-02-25](https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/?envType=daily-question&envId=2026-02-25)

Given an integer array `arr`, sort the integers in the array in ascending order by the number of `1`'s in their binary representation.  
If two or more integers have the same number of `1`'s, sort them by their value.

**Example:**  
Input: `arr = [0,1,2,3,4,5,6,7,8]`  
Binary:  
```
0  â†’ 0    (0)
1  â†’ 1    (1)
2  â†’ 10   (1)
3  â†’ 11   (2)
4  â†’ 100  (1)
5  â†’ 101  (2)
6  â†’ 110  (2)
7  â†’ 111  (3)
8  â†’ 1000 (1)
```
Sorted: `[0,1,2,4,8,3,5,6,7]`  
(First by 1's count, then by value)

---

# ðŸ§  Understanding the Problem

- Need to sort by:
  1. The number of 1's in binary representation
  2. The integer value (as a tiebreaker)
- Can use a custom sort with a comparator.

---

# ðŸ’» Your Solution

### Approach:

1. For each number, count the number of set bits (1's).
2. Primary sort: by set bit count.  
   Secondary sort: by numerical value.
3. Implemented a custom grouping and merge sort by bit count, applying sort within groups.

### Code (Cleaned):

```java []
class Solution {
    public int[] sortByBits(int[] arr) {
        int[] noOfBits = new int[arr.length];
        int[] noOfBitsCopy = new int[arr.length];
        int[] res = new int[arr.length];
        int index = 0;
        // Count the number of set bits for each number
        for (int num : arr) {
            int count = 0, tmp = num;
            while (tmp > 0) {
                if ((tmp & 1) == 1) count++;
                tmp = tmp >> 1;
            }
            noOfBits[index++] = count;
        }
        // Group numbers by bit count (order by bits, then by original value)
        index = 0;
        for (int i = 0; i < 32; i++) {
            for (int j = 0; j < arr.length; j++) {
                if (noOfBits[j] == i) {
                    noOfBitsCopy[index] = i;
                    res[index++] = arr[j];
                }
            }
        }
        // For each group with equal bit counts, sort numerically using merge sort
        int start = 0, end = 0;
        while (start < arr.length && end <= arr.length) {
            while (end < arr.length && noOfBitsCopy[end] == noOfBitsCopy[start]) {
                end++;
            }
            if (start == end - 1) {
                start = end;
                continue;
            }
            mergeSort(res, start, end);
            start = end;
        }
        return res;
    }

    private void mergeSort(int[] res, int start, int end) {
        if (start + 1 >= end) return;
        int mid = start + (end - start) / 2;
        mergeSort(res, start, mid);
        mergeSort(res, mid, end);
        int[] merge = new int[res.length];
        int i = start, j = mid, idx = start;
        while (i < mid && j < end) {
            if (res[i] <= res[j]) merge[idx++] = res[i++];
            else merge[idx++] = res[j++];
        }
        while (i < mid) merge[idx++] = res[i++];
        while (j < end) merge[idx++] = res[j++];
        for (int k = start; k < end; k++) res[k] = merge[k];
    }
}
```

---

# â±ï¸ Complexity Analysis

- Counting set bits: O(nÂ·logM) (M = max value, at most 32 bits for int)
- Grouping: O(nÂ·32) = O(n)
- Sorting within groups via merge sort: O(nÂ·log n) worst case if all bits are the same
- **Overall:** O(nÂ·log n)

---

# ðŸ”Ž Can We Do Better?

Java provides built-in methods for set bit count and sort:
- `Integer.bitCount(num)`
- Arrays sort using a custom comparator.

A much simpler and more idiomatic approach in Java 8+:

```java []
class Solution {
    public int[] sortByBits(int[] arr) {
        return Arrays.stream(arr)
                .boxed()
                .sorted((a, b) -> {
                    int cmp = Integer.bitCount(a) - Integer.bitCount(b);
                    return cmp != 0 ? cmp : a - b;
                })
                .mapToInt(i -> i)
                .toArray();
    }
}
```

- This leverages library sort, bit counting, and comparator chaining.
- Preferred in interviews and real code for clarity.

---

# ðŸ’¡ Key Insight

- Counting set bits can be done with `Integer.bitCount`.
- Sorting by tuple `(bit_count, value)` is a classic stable sort pattern.

---

# ðŸ”¥ Comparison

| Approach                       | Time      | Notes                            |
|--------------------------------|-----------|----------------------------------|
| Manual grouping + merge sort   | O(n logn) | More code, explicit control      |
| Built-in sort + bitCount       | O(n logn) | Concise, readable, preferred     |

---

# ðŸ§  Takeaway

- Whenever sorting by a custom rule: build a comparator!
- For bit manipulation, favor built-in helpers when available.
