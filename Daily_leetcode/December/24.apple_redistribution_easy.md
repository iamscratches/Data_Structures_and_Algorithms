# üçé Apple Redistribution into Boxes ‚Äì Greedy Capacity Allocation

## üìú Problem Statement

**Link:** [LeetCode ‚Äì Apple Redistribution into Boxes](https://leetcode.com/problems/apple-redistribution-into-boxes/description/?envType=daily-question&envId=2025-12-24)

You are given:

* An array `apple[]` where `apple[i]` is the number of apples in the `i`-th pile
* An array `capacity[]` where `capacity[j]` is the maximum apples the `j`-th box can hold

Each pile of apples can be split across multiple boxes.

üëâ Return the **minimum number of boxes** needed to store **all apples**.

---

## üß† Intuition

This is a **greedy packing problem**:

* To minimize the number of boxes used:

  * **Always use the largest capacity boxes first**
* Apples can be split ‚Üí no restriction on how apples are distributed
* Order of apple piles does not matter; only the **total apples** matter

üí° So the goal reduces to:

> Keep filling the largest available box until all apples are placed.

---

## ‚öôÔ∏è Approach (Your Solution Explained)

### **1Ô∏è‚É£ Sort Inputs**

```java
Arrays.sort(apple);
Arrays.sort(capacity);
```

* Sorting apples isn‚Äôt strictly required, but doesn‚Äôt hurt
* Sorting capacity allows us to prioritize **bigger boxes**

---

### **2Ô∏è‚É£ Reverse Capacity Array**

```java
for (int i = 0; i < len / 2; i++) {
    int temp = capacity[i];
    capacity[i] = capacity[len - i - 1];
    capacity[len - i - 1] = temp;
}
```

Now:

```
capacity[0] ‚Üí largest box
capacity[1] ‚Üí second largest
...
```

---

### **3Ô∏è‚É£ Greedily Fill Boxes**

```java
while (appleIndex < apple.length) {
    if (capacity[requiredBoxes] >= apple[appleIndex]) {
        capacity[requiredBoxes] -= apple[appleIndex];
        appleIndex++;
    } else {
        apple[appleIndex] -= capacity[requiredBoxes];
        capacity[requiredBoxes] = 0;
        requiredBoxes++;
    }
}
```

**What‚Äôs happening:**

* Fill current box as much as possible
* If box runs out ‚Üí move to next box
* Continue until all apples are placed

---

## ‚úÖ Your Code Implementation

```java []
class Solution {
    public int minimumBoxes(int[] apple, int[] capacity) {
        Arrays.sort(apple);
        Arrays.sort(capacity);

        int requiredBoxes = 0;
        int appleIndex = 0;
        int len = capacity.length;

        // Reverse capacity array to use largest boxes first
        for (int i = 0; i < len / 2; i++) {
            int temp = capacity[i];
            capacity[i] = capacity[len - i - 1];
            capacity[len - i - 1] = temp;
        }

        while (appleIndex < apple.length) {
            if (capacity[requiredBoxes] >= apple[appleIndex]) {
                capacity[requiredBoxes] -= apple[appleIndex];
                appleIndex++;
            } else {
                apple[appleIndex] -= capacity[requiredBoxes];
                capacity[requiredBoxes] = 0;
                requiredBoxes++;
            }
        }
        return requiredBoxes + 1;
    }
}
```

‚úî Correct
‚úî Greedy
‚úî Efficient enough for constraints

---

## ‚è≥ Complexity Analysis

| Metric    | Complexity           |
| --------- | -------------------- |
| **Time**  | O(n log n + m log m) |
| **Space** | O(1)                 |

* Sorting dominates
* In-place operations ‚Üí constant extra space

---

## üìä Example Walkthrough

### Input

```text
apple = [1,3,2]
capacity = [4,3,1,5]
```

### After Sorting & Reversing Capacity

```text
apple    = [1,2,3]
capacity = [5,4,3,1]
```

### Packing

* Box 1 (5): takes 1 + 2 ‚Üí remaining 2
* Box 1: takes 2 from pile 3 ‚Üí box full
* Box 2 (4): takes remaining 1

‚úÖ **Boxes used = 2**

---

## üöÄ MOST OPTIMIZED SOLUTION (Simplified Greedy)

### üî• Key Observation

We **do not need to track individual apple piles**.

Only total apples matter.

---

### ‚öôÔ∏è Optimized Code

```java []
class Solution {
    public int minimumBoxes(int[] apple, int[] capacity) {
        int totalApples = 0;
        for (int a : apple) totalApples += a;

        Arrays.sort(capacity);

        int boxes = 0;
        for (int i = capacity.length - 1; i >= 0 && totalApples > 0; i--) {
            totalApples -= capacity[i];
            boxes++;
        }
        return boxes;
    }
}
```

---

## ‚è≥ Optimized Complexity

| Metric    | Complexity |
| --------- | ---------- |
| **Time**  | O(m log m) |
| **Space** | O(1)       |

‚úî Cleaner
‚úî Faster
‚úî Preferred in interviews

---

## üîÅ Comparison Summary

| Approach         | Time                 | Space | Notes      |
| ---------------- | -------------------- | ----- | ---------- |
| Your simulation  | O(n log n + m log m) | O(1)  | Correct    |
| Optimized greedy | O(m log m)           | O(1)  | ‚≠ê Best     |
| Brute force      | O(n¬∑m)               | O(1)  | ‚ùå Too slow |

---

## ‚ö†Ô∏è Edge Cases

* **Single box fits all apples**
* **Many small boxes**
* **Capacity sum equals apples**
* **Apple array size = 1**

---

## üèÅ Final Takeaway

üìå **Interview Insight**

> ‚ÄúSince apples can be split freely, only the total apple count matters. Sort capacities descending and keep subtracting until all apples are placed.‚Äù

This problem is a **classic greedy resource allocation** pattern.