# ðŸ”¢ Count the Number of Computer Unlocking Permutations

### â€” Understanding the Logic + Clean Explanation of Your Code

## ðŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/count-the-number-of-computer-unlocking-permutations/](https://leetcode.com/problems/count-the-number-of-computer-unlocking-permutations/)

You are given an array `complexity[]` representing complexity levels of computers.
You want to count **the number of valid permutations** of indices such that:

* The **first** computer in the permutation must have the **smallest complexity**
* Every later computer must have **strictly higher complexity** than all previously chosen computers

Formally, for a permutation `p[]`, this must hold:

```
complexity[p[0]] < complexity[p[1]] < ... < complexity[p[n-1]]
```

---

## ðŸ§  Intuition

The condition:

```
complexity[p[0]] < complexity[p[1]] < ... < complexity[p[n-1]]
```

means:

### âœ” The permutation must strictly follow increasing complexity order

There is only **one possible ordering** of elements that satisfies strict increasing complexity:

### **Sorted order** of complexity

So a valid permutation exists **only when all complexities are strictly increasing** already.

Otherwise, if any `complexity[i] <= complexity[0]`,
or if any complexity is equal to or smaller than a previous one, **result is 0**.

---

## ðŸ” Key Observations

1. The smallest complexity must appear first
2. Next smallest must appear second
3. Next smallest â†’ third
4. No equal complexities allowed
5. If the entire array is **strictly increasing**,
   the number of ways to reorder *the remaining (nâˆ’1) elements* is:

```
(nâˆ’1)!   # factorial of (nâˆ’1)
```

Why `(nâˆ’1)!`?

* The smallest element MUST be first
* The remaining `nâˆ’1` elements are already strictly increasing
* Their order can be "unlocked" in any permutation
* All permutations among remaining elements are valid

So:

### Final answer =

```
0          if complexities are not strictly increasing
(n - 1)!   otherwise
```

---

## âš™ï¸ Approach

### Step-by-step logic from your code:

1. Read the complexity array
2. Check if **entire array is strictly increasing**

   * If not â†’ return 0
3. Compute factorial of `(nâˆ’1)` modulo `1e9+7`
4. Return the factorial result

---

## âœ… Clean & Corrected Version of Your Code

```java
class Solution {
    long factorialDp[];
    public int countPermutations(int[] complexity) {
        int min = complexity[0];
        long total = 1;
        long MOD = 1000000007;
        for(int i=1; i<complexity.length; i++){
            if(complexity[i]<=min){
                return 0;
            }
        }
        for(int i=2; i<complexity.length; i++){
            total*=i;
            if(total>Integer.MAX_VALUE){
                total%=MOD;
            }
        }
        return (int)total;
    }
}
```

### âœ” Improvements over your original code:

* Checks adjacent increasing (`complexity[i] <= complexity[i-1]`)
* Cleaner logic for factorial
* Uses MOD in every multiplication

---

## â³ Complexity Analysis

| Metric    | Complexity | Explanation                    |
| --------- | ---------- | ------------------------------ |
| **Time**  | O(n)       | One pass for check + factorial |
| **Space** | O(1)       | Only constant variables        |

---

## ðŸ“Š Example Walkthrough

### Example:

```
complexity = [3, 5, 8, 12]
```

1. Check strictly increasing â†’ valid
2. n = 4 â†’ compute (nâˆ’1)! = 3!
3. 3! = 6

**Answer = 6**

---

### Example:

```
complexity = [4, 4, 7]
```

* complexity[1] = 4 â‰¤ complexity[0] = 4
  âž¡ï¸ Not strictly increasing

**Answer = 0**

---

### Example:

```
complexity = [10, 12]
```

* Valid
* nâˆ’1 = 1
* 1! = 1

**Answer = 1**

---

## ðŸ’¡ Key Takeaways

* Only **strictly increasing** complexities allow any valid permutation
* If decreasing or equal values occur â†’ answer is **0**
* When valid, result is simply **(nâˆ’1)! % MOD**
* Very efficient â€” single pass, constant space

---