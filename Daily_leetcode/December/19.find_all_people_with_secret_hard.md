# üïµÔ∏è Find All People With Secret ‚Äì Union Find with Time Reset

## üìú Problem Statement

**Link:** [LeetCode ‚Äì Find All People With Secret](https://leetcode.com/problems/find-all-people-with-secret/description/?envType=daily-question&envId=2025-12-19)

You are given:

* An integer `n` representing `n` people labeled `0` to `n-1`
* A list `meetings`, where each meeting is `[x, y, time]`
* An integer `firstPerson`

Rules:

* Person `0` initially knows a secret
* Person `firstPerson` also knows the secret at time `0`
* If two people meet at time `t`, the secret is shared **only if at least one already knows it**
* Meetings at the same time happen **simultaneously**

Return **all people who eventually know the secret**.

---

## üß† Intuition

This problem has **two tricky constraints**:

### 1Ô∏è‚É£ Simultaneous Meetings

People meeting at the **same time** can form chains of sharing, even if intermediate people don‚Äôt know the secret beforehand.

### 2Ô∏è‚É£ Time Isolation

Connections formed at time `t` **must not carry over** to time `t+1` unless the secret is actually known.

üëâ This means we must:

* Temporarily connect people **only within the same timestamp**
* Reset connections after processing that time group

---

## ‚öôÔ∏è Approach

### **Core Technique: Union Find (Disjoint Set Union)**

#### Step 1: Sort Meetings by Time

This ensures we process meetings **chronologically**.

#### Step 2: Process Meetings Time-Group Wise

For each unique time:

1. **Union** all people meeting at that time
2. Track participants involved in this time
3. If **any person in a connected component knows the secret**, mark the whole component
4. **Reset DSU connections** for this group to avoid leaking info across time

#### Step 3: Collect Results

Return all people marked as knowing the secret.

---

## ‚úÖ Code Implementation

```java []
class Solution {
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        Arrays.sort(meetings, (a, b) -> a[2] - b[2]);

        int[] parent = new int[n];
        boolean[] know = new boolean[n];

        for (int i = 0; i < n; i++) parent[i] = i;

        // Initially known
        know[0] = true;
        know[firstPerson] = true;

        for (int i = 0; i < meetings.length; ) {
            int time = meetings[i][2];
            List<Integer> group = new ArrayList<>();

            int j = i;
            while (j < meetings.length && meetings[j][2] == time) {
                union(meetings[j][0], meetings[j][1], parent);
                group.add(meetings[j][0]);
                group.add(meetings[j][1]);
                j++;
            }

            // Propagate knowledge to components
            for (int p : group)
                if (know[p])
                    know[find(p, parent)] = true;

            // Assign knowledge to individuals
            for (int p : group)
                know[p] |= know[find(p, parent)];

            // Reset connections for next timestamp
            for (int p : group)
                parent[p] = p;

            i = j;
        }

        List<Integer> res = new ArrayList<>();
        for (int i = 0; i < n; i++)
            if (know[i]) res.add(i);

        return res;
    }

    private int find(int x, int[] parent) {
        return parent[x] == x ? x : (parent[x] = find(parent[x], parent));
    }

    private void union(int a, int b, int[] parent) {
        int pa = find(a, parent);
        int pb = find(b, parent);
        if (pa != pb) parent[pb] = pa;
    }
}
```

---

## ‚è≥ Complexity Analysis

| Metric    | Complexity | Explanation               |
| --------- | ---------- | ------------------------- |
| **Time**  | O(m log m) | Sorting meetings + DSU    |
| **Space** | O(n)       | Parent + knowledge arrays |

---

## üìä Example Walkthrough

### Input

```text
n = 6
meetings = [[1,2,5],[2,3,5],[0,4,6]]
firstPerson = 1
```

### Processing

* Time 5:

  * Union(1,2), Union(2,3)
  * 1 knows ‚Üí 2,3 learn
* Reset DSU
* Time 6:

  * Union(0,4)
  * 0 knows ‚Üí 4 learns

### Output

```text
[0,1,2,3,4]
```

---

## üí° Key Observations

* Meetings at the same time act like **temporary graphs**
* DSU must be **reset per time block**
* Knowledge propagates only within same timestamp
* Path compression ensures efficiency

---

## üöÄ When to Use This Pattern

* Time-based graph problems
* Temporary connectivity
* Simultaneous events
* Controlled information flow

---

## ‚ö†Ô∏è Edge Cases

| Case                   | Result                 |
| ---------------------- | ---------------------- |
| No meetings            | Only 0 and firstPerson |
| All meetings same time | Full propagation       |
| firstPerson = 0        | Already known          |
| Isolated meetings      | No spread              |

---

## üß† Final Takeaway

This problem is a **perfect blend** of:

* **Union Find**
* **Temporal grouping**
* **Controlled resets**

Mastering this pattern helps in:
‚úî Event simulation
‚úî Time-constrained connectivity
‚úî Advanced DSU problems
