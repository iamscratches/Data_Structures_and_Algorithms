# ğŸ“ Count Number of Trapezoids I - Combinatorial Approach for Horizontal Parallel Sides

## ğŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/count-number-of-trapezoids-i/description/)

Given an array `points` where `points[i] = [x_i, y_i]` represents a point on the XY plane, return the number of trapezoids that can be formed using these points as vertices.

**Constraints:**
- `4 <= points.length <= 1000`
- `0 <= x_i, y_i <= 100`
- All points are distinct

**Example 1:**
```text
Input: points = [[0,0],[1,1],[2,2],[0,2],[2,0]]
Output: 1
Explanation: Points (0,0), (1,1), (2,2), (0,2) form a trapezoid
```

**Example 2:**
```text
Input: points = [[1,1],[2,2],[3,3],[1,2],[2,1]]
Output: 2
```

---

## ğŸ§  Intuition
This is a **simplified version** where **only horizontal parallel sides are considered** (trapezoids with top and bottom sides parallel to x-axis).

Key Observations:
1. **Horizontal Lines**: Two segments are horizontal if they have the same y-coordinate
2. **Trapezoid Structure**: A trapezoid with horizontal parallel sides consists of:
   - Two horizontal segments (top and bottom)
   - Two non-horizontal sides connecting corresponding endpoints
3. **Combinatorial Counting**: We can count trapezoids by:
   - Counting how many ways to choose two horizontal segments
   - Ensuring they don't share endpoints

---

## âš™ï¸ Mathematical Approach

### **1ï¸âƒ£ Group Points by Y-coordinate**
- Count points at each y-level
- For y-level with `c` points:
  - Number of horizontal segments at this level = `C(c, 2) = c*(c-1)/2`

### **2ï¸âƒ£ Counting Valid Pairs of Horizontal Segments**
Let:
- `seg_i` = number of horizontal segments at y-level `i`
- `n` = total number of y-levels

We want to count:
```
Total trapezoids = Î£_{iâ‰ j} seg_i * seg_j
```
Because:
- Choose one horizontal segment from level `i`
- Choose another from different level `j`
- These form the parallel sides of a trapezoid

### **3ï¸âƒ£ Efficient Calculation**
From combinatorial identity:
```
Î£_{iâ‰ j} seg_i * seg_j = (Î£ seg_i)Â² - Î£ (seg_i)Â²
```
Then divide by 2 (each trapezoid counted once, but each pair of segments counted twice when we consider order).

---

## âœ… Code Implementation

```java
class Solution {
    private static final int MOD = (int) 1e9 + 7;
    private static final int INV2 = 500_000_004;  // Modular inverse of 2 mod 1e9+7

    public int countTrapezoids(int[][] points) {
        // Step 1: Count points at each y-coordinate
        Map<Integer, Integer> yCount = new HashMap<>();
        for (int[] p : points) {
            yCount.put(p[1], yCount.getOrDefault(p[1], 0) + 1);
        }

        // Step 2: Calculate segments per level and their squares
        long totalSeg = 0;  // Î£ seg_i
        long totalSq = 0;   // Î£ (seg_i)Â²
        
        for (int cnt : yCount.values()) {
            if (cnt < 2) continue;  // Need at least 2 points for a segment
            
            // Number of horizontal segments at this y-level
            long seg = (long) cnt * (cnt - 1) / 2;
            
            totalSeg = (totalSeg + seg) % MOD;
            totalSq = (totalSq + seg % MOD * (seg % MOD)) % MOD;
        }

        // Step 3: Apply formula: answer = ( (Î£ seg_i)Â² - Î£ (seg_i)Â² ) / 2
        long totalSegMod = totalSeg % MOD;
        long ans = (totalSegMod * totalSegMod % MOD - totalSq + MOD) % MOD;
        ans = ans * INV2 % MOD;  // Multiply by modular inverse of 2

        return (int) ans;
    }
}
```

---

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through points |
| **Space**       | O(k)       | k = number of distinct y-values (â‰¤ 101) |

---

## ğŸ“Š Example Walkthrough

**Input:** `points = [[0,0],[1,1],[2,2],[0,2],[2,0]]`

**Step 1: Count points by y-coordinate**
- y=0: points: (0,0) â†’ count = 1 (no segments)
- y=1: points: (1,1) â†’ count = 1 (no segments)
- y=2: points: (2,2), (0,2), (2,0) â†’ count = 3
  - Wait! Check carefully: (2,0) has y=0, not y=2
  - Let's recount:
    - y=0: (0,0), (2,0) â†’ count = 2
    - y=1: (1,1) â†’ count = 1
    - y=2: (2,2), (0,2) â†’ count = 2

**Step 2: Calculate segments**
- y=0: cnt=2 â†’ segments = 2*1/2 = 1
- y=1: cnt=1 â†’ segments = 0
- y=2: cnt=2 â†’ segments = 2*1/2 = 1

**Step 3: Apply formula**
```
totalSeg = 1 + 1 = 2
totalSq = 1Â² + 1Â² = 2
answer = (2Â² - 2) / 2 = (4 - 2) / 2 = 1
```

**Result:** 1 trapezoid

---

## ğŸ”‘ Key Features
1. **Efficiency**: O(n) time complexity
2. **Modular Arithmetic**: Handles large counts modulo 1e9+7
3. **Combinatorial Formula**: Elegant mathematical solution
4. **Memory Efficient**: Only stores y-coordinate counts

---

## ğŸ§® Mathematical Derivation

### **Why does the formula work?**
Let `seg_i` = number of horizontal segments at y-level `i`

We want to count **pairs of segments from different y-levels**:
```
Total = Î£_{i<j} seg_i * seg_j
```

But we can compute this efficiently:
```
(Î£ seg_i)Â² = Î£ (seg_i)Â² + 2 * Î£_{i<j} seg_i * seg_j

Therefore:
Î£_{i<j} seg_i * seg_j = [(Î£ seg_i)Â² - Î£ (seg_i)Â²] / 2
```

### **Modular Inverse of 2**
Since we're working modulo `M = 1e9+7`, we need to divide by 2 modulo M.
The modular inverse of 2 modulo M is:
```
2 * INV2 â‰¡ 1 (mod M)
INV2 = 500,000,004
```

---

## âš ï¸ Edge Cases
1. **Few points at a level**: Levels with < 2 points don't contribute
2. **All points on one line**: No trapezoids possible
3. **Maximum constraints**: Handles n=1000 with modular arithmetic
4. **Small y-range**: y â‰¤ 100, so hashmap is efficient

---

## ğŸ”„ Comparison with Version II
| Aspect | Version I (this) | Version II (previous) |
|--------|-----------------|----------------------|
| **Parallel sides** | Only horizontal | Any direction |
| **Time Complexity** | O(n) | O(nÂ²) |
| **Space Complexity** | O(k) where k â‰¤ 101 | O(nÂ²) |
| **Constraints** | y â‰¤ 100 | y up to 10â¹ |
| **Approach** | Combinatorial | Geometric grouping |

---

## ğŸ’¡ Practical Insights
1. **Real-world analogy**: Counting tables with horizontal top/bottom edges
2. **Application**: CAD software for detecting horizontal structures
3. **Extension**: Can be adapted for vertical parallel sides similarly
4. **Optimization**: The O(n) approach is optimal for this simplified problem

---

## ğŸš€ When to Use This Approach
- **When parallel sides are axis-aligned**
- **For problems with small coordinate ranges**
- **When O(n) complexity is required**
- **As a building block for more complex geometric problems**

---

## ğŸ›  Extensions
1. **Count trapezoids with vertical parallel sides**:
```java
// Similar approach using x-coordinate grouping
```

2. **Count general trapezoids**:
```java
// Would need the more complex O(nÂ²) approach
```

3. **Count with area constraints**:
```java
// Additional filtering based on area calculation
```

This solution showcases how a clever combinatorial approach can dramatically simplify a geometric counting problem when specific constraints are given.