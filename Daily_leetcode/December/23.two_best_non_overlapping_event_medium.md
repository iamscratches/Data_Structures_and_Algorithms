# üéüÔ∏è Two Best Non-Overlapping Events ‚Äì Binary Search + Suffix Maximum

## üìú Problem Statement

**Link:** [LeetCode ‚Äì Two Best Non-Overlapping Events](https://leetcode.com/problems/two-best-non-overlapping-events/description/?envType=daily-question&envId=2025-12-23)

You are given an array `events`, where
`events[i] = [startTime, endTime, value]`.

You can attend **at most two non-overlapping events**.
Two events do **not overlap** if the second starts **strictly after** the first ends.

üëâ Return the **maximum total value** you can obtain.

---

## üß† Key Insight

This is a **scheduling + optimization** problem:

* We want **two events**
* They must **not overlap**
* Maximize **sum of values**

üí° Brute force checking all pairs is **O(n¬≤)** ‚Üí too slow.

---

# üîç Core Idea

1. **Sort events by start time**
2. For each event `i`, treat it as the **first event**
3. Find the **best possible second event** that:

   ```
   startTime > events[i].endTime
   ```
4. Add:

   ```
   events[i].value + bestFutureValue
   ```

To do this efficiently:

* Use **binary search**
* Use a **suffix maximum array** to get best value quickly

---

# ‚öôÔ∏è Approach Breakdown

### **Step 1Ô∏è‚É£: Sort by Start Time**

This allows binary searching the next valid event.

```java
Arrays.sort(events, (a,b) -> Integer.compare(a[0], b[0]));
```

---

### **Step 2Ô∏è‚É£: Build Suffix Maximum Array**

`sufMax[i]` = maximum `value` from index `i` to end.

```java
sufMax[n-1] = events[n-1][2];
for (int i = n-2; i >= 0; i--) {
    sufMax[i] = Math.max(sufMax[i+1], events[i][2]);
}
```

This lets us answer:

> ‚ÄúWhat‚Äôs the maximum event value starting from index `i` onward?‚Äù

in **O(1)**.

---

### **Step 3Ô∏è‚É£: Binary Search for Next Valid Event**

For each event `i`, binary search the **first event whose start > events[i].end**.

Once found, directly use `sufMax[index]`.

---

# ‚úÖ Your Code Implementation (Correct & Efficient)

```java []
class Solution {
    public int nextMaxEvent(int l, int r, int end, int[] sufMax, int[][] events) {
        int max = 0;
        while (l <= r) {
            int m = l + (r - l) / 2;
            if (events[m][0] > end) {
                max = sufMax[m];
                r = m - 1;
            } else {
                l = m + 1;
            }
        }
        return max;
    }

    public int maxTwoEvents(int[][] events) {
        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));
        int n = events.length;

        int[] sufMax = new int[n];
        sufMax[n - 1] = events[n - 1][2];
        for (int i = n - 2; i >= 0; i--) {
            sufMax[i] = Math.max(sufMax[i + 1], events[i][2]);
        }

        int ans = 0;
        for (int i = 0; i < n; i++) {
            int sum = events[i][2];
            sum += nextMaxEvent(i + 1, n - 1, events[i][1], sufMax, events);
            ans = Math.max(ans, sum);
        }
        return ans;
    }
}
```

---

## ‚è≥ Complexity Analysis

| Metric    | Complexity |
| --------- | ---------- |
| **Time**  | O(n log n) |
| **Space** | O(n)       |

* Sorting ‚Üí `O(n log n)`
* For each event ‚Üí binary search `O(log n)`
* Efficient for large constraints

---

# üìä Example Walkthrough

### Input

```text
events = [[1,3,2],[4,5,2],[2,4,3]]
```

### After Sorting

```
[1,3,2]
[2,4,3]
[4,5,2]
```

### Suffix Max

```
[3,3,2]
```

### Evaluation

* Pick `[1,3,2]` ‚Üí next valid is `[4,5,2]` ‚Üí sum = 4
* Pick `[2,4,3]` ‚Üí no valid next ‚Üí sum = 3
* Pick `[4,5,2]` ‚Üí alone ‚Üí sum = 2

‚úÖ **Answer = 4**

---

# üöÄ MOST OPTIMIZED ALTERNATIVE (Greedy + Heap)

### üß† Idea

Process events by **start time**, maintain a max heap of events that **already ended**.

---

### ‚öôÔ∏è Optimized Code (Single Pass)

```java []
class Solution {
    public int maxTwoEvents(int[][] events) {
        Arrays.sort(events, (a, b) -> a[0] - b[0]);

        PriorityQueue<int[]> pq =
            new PriorityQueue<>((a, b) -> a[1] - b[1]);

        int best = 0, ans = 0;

        for (int[] e : events) {
            while (!pq.isEmpty() && pq.peek()[1] < e[0]) {
                best = Math.max(best, pq.poll()[2]);
            }
            ans = Math.max(ans, best + e[2]);
            pq.offer(e);
        }
        return ans;
    }
}
```

---

## ‚è≥ Optimized Complexity

| Metric    | Complexity |
| --------- | ---------- |
| **Time**  | O(n log n) |
| **Space** | O(n)       |

‚úî Same asymptotics
‚úî Cleaner logic
‚úî Preferred in interviews

---

# üîÅ Comparison Summary

| Approach               | Time       | Space | Notes           |
| ---------------------- | ---------- | ----- | --------------- |
| Brute Force            | O(n¬≤)      | O(1)  | ‚ùå TLE           |
| Binary Search + Suffix | O(n log n) | O(n)  | ‚úÖ Your solution |
| Heap Greedy            | O(n log n) | O(n)  | ‚≠ê Most elegant  |

---

# üèÅ Final Takeaways

* This is a **weighted interval scheduling** variant
* Sorting + future best lookup is key
* Suffix max or heap ‚Üí both valid
* Avoid pairwise comparisons

üìå **Interview One-Liner**

> ‚ÄúSort events, and for each event find the best non-overlapping future event using suffix maximum or a heap.‚Äù