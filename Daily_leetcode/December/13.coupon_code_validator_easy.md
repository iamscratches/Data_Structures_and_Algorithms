# ğŸŸï¸ Coupon Code Validator â€“ Filtering, Validation & Custom Sorting

## ğŸ“œ Problem Statement

**Link:** [LeetCode â€“ Coupon Code Validator](https://leetcode.com/problems/coupon-code-validator/description/?envType=daily-question&envId=2025-12-13)

You are given:

* `code[i]`: coupon code string
* `line[i]`: business line associated with the coupon
* `active[i]`: whether the coupon is active

A coupon is **valid** if:

1. `active[i] == true`
2. `line[i]` belongs to a predefined allowed list
3. `code[i]` is non-empty
4. Every character in `code[i]` is:

   * a letter
   * a digit
   * underscore `_`

Return all **valid coupon codes**, **sorted** by:

1. Business line priority
2. Lexicographical order of coupon code

---

## ğŸ§  Intuition

This problem is a **data validation + custom sorting** task.

Key observations:

* Validation rules are independent â†’ easy to short-circuit invalid entries
* Sorting requires:

  * custom priority per business line
  * lexicographical comparison of strings
* Index-based sorting avoids unnecessary object creation

---

## âš™ï¸ Approach

### **1ï¸âƒ£ Business Line Priority Mapping**

Assign fixed priority values:

```text
electronics â†’ 1
grocery     â†’ 2
pharmacy    â†’ 3
restaurant  â†’ 4
```

### **2ï¸âƒ£ Validation Phase**

For each coupon:

* Reject if:

  * business line not in map
  * code is null or empty
  * inactive
  * invalid characters present
* Store index of valid coupons

### **3ï¸âƒ£ Sorting Phase**

Sort valid indices by:

1. Business line priority
2. Coupon code (lexicographical)

### **4ï¸âƒ£ Build Result**

Convert sorted indices into coupon code list

---

## âœ… Code Implementation

```java
class Solution {
    public List<String> validateCoupons(String[] code, String[] line, boolean[] active) {
        int n = code.length;

        // Business line priority
        Map<String, Integer> lineId = new HashMap<>();
        lineId.put("electronics", 1);
        lineId.put("grocery", 2);
        lineId.put("pharmacy", 3);
        lineId.put("restaurant", 4);

        List<Integer> valid = new ArrayList<>();

        // Validation phase
        for (int i = 0; i < n; i++) {
            if (!lineId.containsKey(line[i]) || code[i] == null || code[i].isEmpty()) {
                active[i] = false;
            }

            if (active[i]) {
                for (char c : code[i].toCharArray()) {
                    if (!isGoodChar(c)) {
                        active[i] = false;
                        break;
                    }
                }
            }

            if (active[i]) {
                valid.add(i);
            }
        }

        // Sorting phase
        valid.sort((i, j) -> {
            int li = lineId.get(line[i]);
            int lj = lineId.get(line[j]);
            if (li != lj) return Integer.compare(li, lj);
            return code[i].compareTo(code[j]);
        });

        // Build answer
        List<String> ans = new ArrayList<>();
        for (int idx : valid) {
            ans.add(code[idx]);
        }
        return ans;
    }

    private boolean isGoodChar(char c) {
        return Character.isLetterOrDigit(c) || c == '_';
    }
}
```

---

## â³ Complexity Analysis

| Metric    | Complexity       | Explanation          |
| --------- | ---------------- | -------------------- |
| **Time**  | O(nÂ·L + n log n) | Validation + sorting |
| **Space** | O(n)             | Index storage        |

*L = average length of coupon code*

---

## ğŸ“Š Example Walkthrough

### Input

```text
code   = ["SAVE_10", "abc$", "FREE50"]
line   = ["electronics", "grocery", "electronics"]
active = [true, true, false]
```

### Validation

| Coupon  | Valid? | Reason                |
| ------- | ------ | --------------------- |
| SAVE_10 | âœ…      | valid chars, active   |
| abc$    | âŒ      | invalid character `$` |
| FREE50  | âŒ      | inactive              |

### Output

```text
["SAVE_10"]
```

---

## ğŸ’¡ Key Features

* âœ… Short-circuit validation (fast rejection)
* âœ… Index-based sorting (memory efficient)
* âœ… Clean comparator logic
* âœ… Clear separation of validation & sorting

---

## ğŸš€ When to Use This Pattern

* Coupon / promotion validation
* Role-based filtering
* Custom sorting with priorities
* String validation problems

---

## ğŸ”„ Possible Optimizations / Variations

### 1ï¸âƒ£ Pre-filter Using Regex

```java
code[i].matches("[A-Za-z0-9_]+")
```

### 2ï¸âƒ£ Use Enum for Business Lines

Safer and more extensible

### 3ï¸âƒ£ Stream-based Solution

Readable but slower for large inputs

---

## âš ï¸ Edge Cases

* All coupons invalid â†’ return empty list
* Same line + same code â†’ stable order
* Null / empty code
* Invalid business line

---

## ğŸ§  Final Takeaway

This problem tests:

* Input validation discipline
* Custom comparator usage
* Clean data filtering
* Stable sorting logic