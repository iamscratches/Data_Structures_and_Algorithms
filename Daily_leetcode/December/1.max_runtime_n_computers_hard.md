# ðŸ”‹ Maximum Running Time of N Computers - Greedy Energy Distribution

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/maximum-running-time-of-n-computers/description/)

You have `n` computers and an array `batteries` where the `i-th` battery can run a computer for `batteries[i]` minutes. All computers run simultaneously, and each battery can power at most one computer at any given time. However, you can replace a battery with another battery at any time.

Return the **maximum number of minutes** you can run all `n` computers simultaneously.

**Constraints:**
- `1 <= n <= batteries.length <= 10âµ`
- `1 <= batteries[i] <= 10â¹`

**Example 1:**
```text
Input: n = 2, batteries = [3,3,3]
Output: 4
Explanation: 
Initially, use batteries 0 and 1 for 2 minutes.
After 2 minutes, replace battery 1 with battery 2 for another 2 minutes.
Total: 2 + 2 = 4 minutes
```

**Example 2:**
```text
Input: n = 2, batteries = [1,1,1,1]
Output: 2
Explanation: 
Use any two batteries for 1 minute each.
Then replace with the other two batteries for another 1 minute.
Total: 1 + 1 = 2 minutes
```

---

## ðŸ§  Intuition
The key insight is to think about **total energy distribution**:

1. **Energy Pool Concept**: We can pool all battery energies together
2. **Constraint**: At any moment, only `n` batteries can be used
3. **Bottleneck**: The largest batteries can dominate if they're too powerful
4. **Optimal Strategy**: Distribute energy evenly across computers

Key Observation:
- If a battery has more energy than the average per computer, it can "waste" energy
- We should exclude such overpowered batteries from the average calculation
- The remaining energy can be distributed evenly

---

## âš™ï¸ Greedy Approach

### **1ï¸âƒ£ Mathematical Foundation**
Let:
- `totalEnergy` = sum of all battery energies
- `target` = maximum running time we want to achieve

For all computers to run for `target` minutes:
- Each computer needs `target` energy
- Total needed = `n * target`
- Each battery can contribute at most `min(battery, target)` energy
  (because a battery can't power for longer than its capacity)

Thus, the condition is:
```
Î£ min(battery_i, target) >= n * target
```

### **2ï¸âƒ£ Greedy Strategy**
1. **Sort batteries** in ascending order
2. **Identify overpowered batteries**:
   - A battery is overpowered if `battery > totalEnergy / n`
   - Such batteries would waste energy if included in average
3. **Remove overpowered batteries**:
   - Subtract their energy from total
   - Reduce `n` (they'll be used exclusively for one computer)
4. **Calculate result**:
   - Remaining energy can be perfectly distributed
   - Answer = `remainingEnergy / remainingComputers`

---

## âœ… Code Implementation

```java
class Solution {
    public long maxRunTime(int n, int[] batteries) {
        // Step 1: Calculate total energy
        long totalEnergy = 0;
        for (int battery : batteries) {
            totalEnergy += battery;
        }

        // Step 2: Sort batteries to easily identify large ones
        Arrays.sort(batteries);

        // Step 3: Remove overpowered batteries
        for (int i = batteries.length - 1; i >= 0; i--) {
            // Check if current battery has more than fair share
            if (batteries[i] > totalEnergy / n) {
                // This battery is overpowered - remove it
                totalEnergy -= batteries[i];
                n--;  // This battery will power one computer exclusively
            } else {
                // All remaining batteries can be fairly distributed
                break;
            }
        }

        // Step 4: Distribute remaining energy evenly
        return totalEnergy / n;
    }
}
```

---

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(m log m) | Sorting m batteries dominates |
| **Space**       | O(1)       | Constant extra space (sorting in-place) |

Where `m = batteries.length`

---

## ðŸ“Š Example Walkthrough

**Example 1:** `n = 2, batteries = [3, 3, 3]`

**Step 1: Calculate total energy**
```
totalEnergy = 3 + 3 + 3 = 9
```

**Step 2: Check for overpowered batteries**
```
Average = 9 / 2 = 4.5
Batteries: [3, 3, 3] (already sorted)
None > 4.5, so no batteries removed
```

**Step 3: Calculate result**
```
result = 9 / 2 = 4 (integer division)
```

**Verification:** Can we run for 4 minutes?
- Total energy needed: 2 computers Ã— 4 minutes = 8 energy
- Available: 3 + 3 + 3 = 9 energy âœ“
- Strategy: Use batteries (0,1) for 3 min, then (0,2) for 1 min

---

**Example 2:** `n = 3, batteries = [10, 10, 3, 3]`

**Step 1: Calculate total energy**
```
totalEnergy = 10 + 10 + 3 + 3 = 26
```

**Step 2: Check for overpowered batteries**
```
Initial average = 26 / 3 â‰ˆ 8.67
Batteries sorted: [3, 3, 10, 10]
Check from end:
- battery[3] = 10 > 8.67? YES â†’ remove
  totalEnergy = 26 - 10 = 16, n = 2
- battery[2] = 10 > 16 / 2 = 8? YES â†’ remove
  totalEnergy = 16 - 10 = 6, n = 1
- battery[1] = 3 > 6 / 1 = 6? NO â†’ stop
```

**Step 3: Calculate result**
```
result = 6 / 1 = 6 minutes
```

**Verification:**
- Computer 1: Uses battery 0 (10) for 6 minutes (4 wasted)
- Computer 2: Uses battery 1 (10) for 6 minutes (4 wasted)
- Computer 3: Uses batteries 2,3 (3+3) for 6 minutes
Total used: 6 + 6 + 6 = 18 energy â‰¤ 26 available âœ“

---

## ðŸ”‘ Key Insights

### **Why the Greedy Approach Works**
1. **Overpowered Battery Definition**:
   - If `battery > totalEnergy / n`, it can power a computer alone
   - Including it in average calculation would underestimate capacity

2. **Mathematical Justification**:
   ```
   Let battery_i > totalEnergy / n
   Then using battery_i for one computer gives:
   Running time â‰¥ battery_i > average
   So it's better to dedicate it to one computer
   ```

3. **Optimal Distribution**:
   After removing overpowered batteries, remaining ones satisfy:
   ```
   battery_i â‰¤ remainingEnergy / remainingComputers
   ```
   So they can be perfectly distributed

---

## âš ï¸ Edge Cases
1. **n = 1**: Returns sum of all batteries
2. **All batteries equal**: Perfect distribution possible
3. **One very large battery**: It gets dedicated to one computer
4. **More computers than batteries**: Problem guarantees n â‰¤ batteries.length

---

## ðŸ”„ Alternative Approaches
| Approach | Time | Space | Description |
|----------|------|-------|-------------|
| **Greedy (this)** | O(m log m) | O(1) | Optimal, intuitive |
| **Binary Search** | O(m log K) | O(1) | K = sum(batteries)/n |
| **Priority Queue** | O(m log n) | O(n) | Simulate process |

---

## ðŸ’¡ Practical Applications
1. **Resource Allocation**: Distributing limited resources among tasks
2. **Battery Management**: Optimal use of battery banks
3. **Cloud Computing**: Assigning compute resources to VMs
4. **Task Scheduling**: Maximizing parallel task execution time

---

## ðŸš€ Optimization Details

### **Why Sorting Works**
- Sorting helps efficiently identify large batteries
- Process from largest to smallest
- Stop when condition fails (no need to check smaller batteries)

### **Mathematical Proof Sketch**
Let `S` be total energy, `n` computers, batteries sorted `bâ‚ â‰¤ bâ‚‚ â‰¤ ... â‰¤ bâ‚˜`.

Claim: Remove all batteries where `báµ¢ > S/n`.

Proof: 
1. If `bâ‚˜ > S/n`, dedicate it to one computer
2. New problem: `n-1` computers, total energy `S - bâ‚˜`
3. Continue inductively
4. Remaining batteries satisfy `báµ¢ â‰¤ S'/n'` where `S'` and `n'` are updated totals

---

## ðŸ›  Extensions
1. **Minimize waste**:
```java
// Track how much energy is wasted by overpowered batteries
```

2. **Variable computer requirements**:
```java
// Different computers need different energy rates
```

3. **Battery replacement constraints**:
```java
// Limit how often batteries can be swapped
```

This solution elegantly transforms a complex scheduling problem into a simple greedy strategy by focusing on total energy distribution rather than individual battery assignments.