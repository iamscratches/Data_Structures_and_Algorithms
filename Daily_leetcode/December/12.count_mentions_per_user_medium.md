# âœ… **Problem: Count Mentions Per User**

Leetcode: [https://leetcode.com/problems/count-mentions-per-user/](https://leetcode.com/problems/count-mentions-per-user/)

---

# âœ… **Your Code (Cleaned, Explained, Same Structure as Before)**

### âœ” What your code is doing:

1. Group events by timestamp (sorted automatically using TreeMap).
2. Track online/offline users with cooldown (60 seconds).
3. For each MESSAGE event, parse tokens:

   * `ALL` â†’ increment everyone
   * `HERE` â†’ increment all online
   * `idX` â†’ increment that specific user if valid
4. Return the final count array.

### âœ” Your logic is correct.

But it can be optimized significantly â€” especially avoiding repeated `O(n)` loops inside events.

---

# âœ… **Your Code (Improved Formatting, Same Logic)**

```java
class Solution {
    public int[] countMentions(int numberOfUsers, List<List<String>> events) {
        // Sort events by time using TreeMap
        TreeMap<Integer, List<List<String>>> byTime = new TreeMap<>();
        for (List<String> ev : events) {
            int t = Integer.parseInt(ev.get(1));
            byTime.computeIfAbsent(t, k -> new ArrayList<>()).add(ev);
        }

        int[] mentions = new int[numberOfUsers];
        boolean[] isOnline = new boolean[numberOfUsers];
        int[] offlineUntil = new int[numberOfUsers];
        Arrays.fill(isOnline, true);

        for (Map.Entry<Integer, List<List<String>>> entry : byTime.entrySet()) {

            int t = entry.getKey();
            List<List<String>> evs = entry.getValue();

            // Bring users online if their offline timer expired
            for (int i = 0; i < numberOfUsers; ++i) {
                if (!isOnline[i] && offlineUntil[i] <= t) {
                    isOnline[i] = true;
                    offlineUntil[i] = 0;
                }
            }

            // Process OFFLINE events
            for (List<String> ev : evs) {
                if (ev.get(0).equals("OFFLINE")) {
                    int id = Integer.parseInt(ev.get(2));
                    isOnline[id] = false;
                    offlineUntil[id] = t + 60;
                }
            }

            // Process MESSAGE events
            for (List<String> ev : evs) {
                if (!ev.get(0).equals("MESSAGE")) continue;
                String[] tokens = ev.get(2).split("\\s+");

                for (String token : tokens) {
                    if (token.equals("ALL")) {
                        for (int i = 0; i < numberOfUsers; ++i) mentions[i]++;
                    } 
                    else if (token.equals("HERE")) {
                        for (int i = 0; i < numberOfUsers; ++i)
                            if (isOnline[i]) mentions[i]++;
                    } 
                    else if (token.startsWith("id")) {
                        int id = Integer.parseInt(token.substring(2));
                        if (id >= 0 && id < numberOfUsers) mentions[id]++;
                    }
                }
            }
        }
        return mentions;
    }
}
```

---

# âœ… **More Optimized Version (Recommended)**

### ðŸ”¥ Improvements:

* Instead of looping over all users for every time tick â†’
  Maintain a **set of currently online users**.
* Maintain a **priority queue for offline-expiry events**, so we only update when needed.
* Reduces unnecessary O(n) loops.

### â± Complexity:

* Your version: **O(E Â· n)** worst-case
* Optimized version: **O(E log E + M)**
  where M = number of total mentions processed

Much faster for large inputs.

---

# âœ… **Fully Optimized Code**

```java
class Solution {
    public int[] countMentions(int numberOfUsers, List<List<String>> events) {

        // Sort by time
        events.sort((a, b) -> Integer.compare(Integer.parseInt(a.get(1)), Integer.parseInt(b.get(1))));

        int[] mentions = new int[numberOfUsers];

        // Users online set
        boolean[] isOnline = new boolean[numberOfUsers];
        Arrays.fill(isOnline, true);

        // PQ to re-enable users when time passes (min-heap by expiry time)
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);

        for (List<String> ev : events) {
            int time = Integer.parseInt(ev.get(1));

            // Bring users online whose offline timeout expired
            while (!pq.isEmpty() && pq.peek()[0] <= time) {
                int[] top = pq.poll();
                isOnline[top[1]] = true;
            }

            String type = ev.get(0);

            if (type.equals("OFFLINE")) {

                int id = Integer.parseInt(ev.get(2));
                if (isOnline[id]) {
                    isOnline[id] = false;
                    pq.offer(new int[]{time + 60, id});
                }
            }
            else { // MESSAGE
                String[] tokens = ev.get(2).split("\\s+");

                for (String token : tokens) {
                    if (token.equals("ALL")) {
                        for (int i = 0; i < numberOfUsers; ++i) mentions[i]++;
                    }
                    else if (token.equals("HERE")) {
                        for (int i = 0; i < numberOfUsers; ++i)
                            if (isOnline[i]) mentions[i]++;
                    }
                    else if (token.startsWith("id")) {
                        int id = Integer.parseInt(token.substring(2));
                        if (id >= 0 && id < numberOfUsers) mentions[id]++;
                    }
                }
            }
        }
        return mentions;
    }
}
```

