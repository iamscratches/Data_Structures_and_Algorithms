# ğŸ“ˆ Best Time to Buy and Sell Stock Using Strategy â€“ Sliding Window Optimization

## ğŸ“œ Problem Statement

**Link:** [LeetCode â€“ Best Time to Buy and Sell Stock Using Strategy](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-using-strategy/description/?envType=daily-question&envId=2025-12-18)

You are given:

* An integer array `prices` where `prices[i]` is the stock price on day `i`
* An integer array `strategy` of the same length:

  * `strategy[i] = 1` â†’ buy on day `i`
  * `strategy[i] = -1` â†’ sell on day `i`
  * `strategy[i] = 0` â†’ do nothing
* An integer `k` (even)

You may choose **one continuous segment of length `k`** and **override the strategy** in that segment as:

* First `k/2` days â†’ **buy**
* Last `k/2` days â†’ **sell**

Return the **maximum total profit** achievable.

---

## ğŸ§  Intuition

There are two parts to the profit:

### 1ï¸âƒ£ Base Profit (No Override)

Compute profit using the given `strategy`:

```
profit += prices[i] * strategy[i]
```

### 2ï¸âƒ£ Strategy Override (Window of Size k)

When overriding a window:

* First half contributes: `+prices[i]`
* Second half contributes: `-prices[i]`
* Original strategy profit inside the window must be **removed**

ğŸ‘‰ The goal is to **slide a window of size `k`** and efficiently update the profit difference.

---

## âš™ï¸ Approach

### **Step 1: Calculate Base Profit**

This is the profit without using the override at all.

### **Step 2: Apply Override to First Window**

* Buy for first `k/2`
* Sell for last `k/2`
* Outside the window â†’ original strategy

### **Step 3: Slide the Window**

When sliding by one position:

* Restore the old left elementâ€™s original strategy
* Add new right elementâ€™s override contribution
* Update profit in **O(1)** time

This avoids recalculating the entire window.

---

## âœ… Code Implementation

```java []
class Solution {
    public long maxProfit(int[] prices, int[] strategy, int k) {
        long maxProfit = 0;

        // Step 1: Base profit using original strategy
        for (int i = 0; i < prices.length; i++) {
            maxProfit += (long) prices[i] * strategy[i];
        }

        // Step 2: Apply override on the first window
        long currentProfit = 0;

        // First k/2 days â†’ buy
        for (int i = k / 2; i < k; i++) {
            currentProfit += prices[i];
        }

        // Rest of the array â†’ original strategy
        for (int i = k; i < prices.length; i++) {
            currentProfit += (long) prices[i] * strategy[i];
        }

        maxProfit = Math.max(maxProfit, currentProfit);

        // Step 3: Sliding window
        for (int i = k / 2; i < prices.length - (k / 2); i++) {
            currentProfit += (long) prices[i - k / 2] * strategy[i - k / 2]
                            - prices[i]
                            + prices[i + k / 2]
                            - (long) prices[i + k / 2] * strategy[i + k / 2];

            maxProfit = Math.max(maxProfit, currentProfit);
        }

        return maxProfit;
    }
}
```

---

## â³ Complexity Analysis

| Metric    | Complexity | Explanation               |
| --------- | ---------- | ------------------------- |
| **Time**  | O(n)       | One pass + sliding window |
| **Space** | O(1)       | Constant extra space      |

---

## ğŸ“Š Example Walkthrough

### Input

```text
prices   = [3, 5, 1, 6]
strategy = [1, -1, 0, 1]
k = 2
```

### Base Profit

```
3*1 + 5*(-1) + 1*0 + 6*1 = 4
```

### Override Window (size 2)

* Buy on day 0 â†’ +3
* Sell on day 1 â†’ -5

Compute and slide window â†’ track max.

---

## ğŸ’¡ Key Observations

* Only **one override window** allowed
* Sliding window avoids O(nÂ·k)
* Profit updates are **constant time**
* Uses long to avoid overflow

---

## ğŸš€ When to Use This Pattern

* Problems with **single interval override**
* Fixed-length window optimization
* Strategy replacement problems
* Sliding window with delta updates

---

## âš ï¸ Edge Cases

| Case               | Handling           |
| ------------------ | ------------------ |
| k = 0              | No override        |
| k = n              | Full replacement   |
| strategy all zeros | Override dominates |
| Large prices       | Uses `long` safely |

---

## ğŸ§  Final Takeaway

This solution combines:

* **Baseline computation**
* **Sliding window optimization**
* **Delta-based profit updates**

Result:
âœ” Optimal O(n)
âœ” No extra memory
âœ” Clean and scalable
âœ” Interview-ready logic