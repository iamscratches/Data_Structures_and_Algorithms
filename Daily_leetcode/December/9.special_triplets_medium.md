# üî¢ Count Special Triplets ‚Äî Clean Explanation + Optimal Solution

## üìú Problem Statement

**Link:** [https://leetcode.com/problems/count-special-triplets/](https://leetcode.com/problems/count-special-triplets/)

You are given an integer array `nums`.
Count the number of triplets `(i, j, k)` such that:

```
i < j < k
nums[i] + nums[j] = nums[k]
```

**Constraints**

* 3 ‚â§ nums.length ‚â§ 2√ó10‚Åµ
* 1 ‚â§ nums[i] ‚â§ 10‚Å∂
* Answer may need modulo 1e9+7

---

## üß† Intuition

We want:

```
nums[i] + nums[j] = nums[k]    where i < j < k
```

Think of each index `j` as the middle element.

For each position `j`, we need:

* Count of `nums[i] = 2*nums[j] - nums[k]` on the left
* Count of `nums[k] = nums[i] + nums[j]` on the right
* But since nums[k] must equal `nums[i] + nums[j]` and `nums[i] = nums[j]`, the special triplets reduce to:

‚úî Only one possible value can satisfy the condition:

```
nums[i] = nums[k] = 2 * nums[j]
```

So the condition simplifies to:

```
nums[i] = 2 * nums[j]   AND   nums[k] = 2 * nums[j]
```

Thus, for each middle element `nums[j]`:

```
triplets += (freq of 2*nums[j] on left) * (freq of 2*nums[j] on right)
```

We maintain:

* `preFreq` ‚Üí frequencies to the **left side**
* `postFreq` ‚Üí frequencies to the **right side**

---

## ‚öôÔ∏è Approach

### **1Ô∏è‚É£ Build Right Frequency Map**

Count how many times each number appears initially (postFreq).

### **2Ô∏è‚É£ Iterate Through the Array**

For each `nums[j]`:

1. Remove one occurrence from `postFreq`
2. Compute target = `2 * nums[j]`
3. Triplets contributed:

   ```
   preFreq[target] * postFreq[target]
   ```
4. Add `nums[j]` into `preFreq`

### **3Ô∏è‚É£ Maintain Modulo**

Use `1e9 + 7` as required.

---

## ‚úÖ Code

```java []
class Solution {
    public int specialTriplets(int[] nums) {
        Map<Integer, Integer> preFreq = new HashMap<>();
        Map<Integer, Integer> postFreq = new HashMap<>();

        long MOD = 1_000_000_007;
        long count = 0;

        // Build initial right frequency map
        for (int x : nums) {
            postFreq.put(x, postFreq.getOrDefault(x, 0) + 1);
        }

        // Iterate with each index acting as middle j
        for (int x : nums) {

            // Remove current element from right map
            postFreq.put(x, postFreq.get(x) - 1);
            if (postFreq.get(x) == 0) postFreq.remove(x);

            int t = x * 2;  // target = 2 * nums[j]

            // Add triplets contributed by x as middle element
            if (preFreq.containsKey(t) && postFreq.containsKey(t)) {
                count = (count + (long) preFreq.get(t) * postFreq.get(t)) % MOD;
            }

            // Add x to left frequency map
            preFreq.put(x, preFreq.getOrDefault(x, 0) + 1);
        }

        return (int) count;
    }
}
```

### ‚úî Fixes over your version:

* Correct default in `postFreq`: used `0`, not `1`
* Clean structure
* Correct modulo logic
* Safe `remove()` when count hits zero

---

## üöÄ Fully Optimized Version (Array-based, Maximum Performance)

Since `nums[i] ‚â§ 10‚Å∂`, we can use arrays instead of HashMaps:

### Fastest Possible O(n + max(nums)) Approach

```java []
class Solution {
    public int specialTriplets(int[] nums) {
        int max = 0;
        for (int x : nums) max = Math.max(max, x);

        long MOD = 1_000_000_007;
        long count = 0;

        int[] left = new int[2 * max + 1];
        int[] right = new int[2 * max + 1];

        // Build initial right frequency
        for (int x : nums) right[x]++;

        // Iterate with j as middle
        for (int x : nums) {
            right[x]--;   // move from right

            int t = x * 2;
            if (t <= 2 * max) {
                count = (count + (long) left[t] * right[t]) % MOD;
            }

            left[x]++;   // move to left
        }

        return (int) count;
    }
}
```

---

## ‚è≥ Complexity Analysis

| Metric    | Complexity                       |
| --------- | -------------------------------- |
| **Time**  | **O(n + max(nums))**             |
| **Space** | **O(max(nums))** (array version) |

Fastest possible given constraints.

---

## üìä Example Walkthrough

Let:

```
nums = [2, 4, 8, 4]
```

### Process:

| j | nums[j] | target = 2 √ó nums[j] | left[target] | right[target] | contributions |
| - | ------- | -------------------- | ------------ | ------------- | ------------- |
| 0 | 2       | 4                    | 0            | 2             | 0             |
| 1 | 4       | 8                    | 0            | 1             | 0             |
| 2 | 8       | 16                   | 0            | 0             | 0             |
| 3 | 4       | 8                    | 1            | 0             | 0             |

Final answer = **0**

Shows correct dependency on frequencies on both sides.

---

## üí° Key Features

* Single-pass
* Efficient frequency tracking
* O(1) operations per element
* Avoids expensive nested loops
* Uses modulo arithmetic correctly

---

## üîÑ Comparison with Approaches

| Approach                 | Time     | Space            | Notes        |
| ------------------------ | -------- | ---------------- | ------------ |
| Brute force              | O(n¬≥)    | O(1)             | Not feasible |
| Double loop + hashmap    | O(n¬≤)    | O(n)             | Slow         |
| Your hashmap fix         | O(n) avg | O(n)             | Good         |
| **Optimized array freq** | **O(n)** | **O(max(nums))** | Fastest      |

---
