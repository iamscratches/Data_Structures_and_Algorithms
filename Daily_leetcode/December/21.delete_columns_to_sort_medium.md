# ğŸ—‚ï¸ Delete Columns to Make Sorted II â€“ Greedy Lexicographic Resolution

## ğŸ“œ Problem Statement

**Link:** [LeetCode â€“ Delete Columns to Make Sorted II](https://leetcode.com/problems/delete-columns-to-make-sorted-ii/description/?envType=daily-question&envId=2025-12-21)

You are given an array of strings `strs`, all of the same length.

You may delete columns so that the array becomes **lexicographically sorted**
(`strs[0] â‰¤ strs[1] â‰¤ ... â‰¤ strs[n-1]`).

ğŸ‘‰ Return the **minimum number of columns** that must be deleted.

---

## ğŸ§  Core Insight (Why This Problem Is Tricky)

Unlike **Delete Columns I**, columns here are **not independent**.

* Earlier columns may already decide ordering
* Later columns should only be considered **if ordering is still undecided**
* Once two adjacent rows are ordered, they never need comparison again

ğŸ“Œ This naturally leads to a **greedy resolution strategy**

---

# ğŸš€ MOST OPTIMIZED SOLUTION (LeetCode Intended)

## ğŸ§  Greedy Idea

Maintain a boolean array `sorted[]` where:

* `sorted[i] = true` means
  `strs[i] < strs[i+1]` is already confirmed
* Once confirmed, that pair never needs future checks

### For each column:

1. Check if keeping the column **breaks lexicographic order**
2. If yes â†’ **delete column**
3. Otherwise â†’ **lock in resolved pairs**

---

## âš™ï¸ Optimized Approach

### Algorithm

1. Initialize `sorted[n-1] = false`
2. Iterate columns left â†’ right
3. If any unresolved pair violates order â†’ delete column
4. Else mark newly resolved pairs
5. Continue until all columns processed

---

## âœ… Optimized Code (Best Possible)

```java []
class Solution {
    public int minDeletionSize(String[] strs) {
        int n = strs.length;
        int m = strs[0].length();
        boolean[] sorted = new boolean[n - 1];
        int deletions = 0;

        for (int col = 0; col < m; col++) {
            boolean bad = false;

            // Check if this column breaks order
            for (int row = 0; row < n - 1; row++) {
                if (!sorted[row] &&
                    strs[row].charAt(col) > strs[row + 1].charAt(col)) {
                    bad = true;
                    break;
                }
            }

            if (bad) {
                deletions++;
            } else {
                // Lock resolved pairs
                for (int row = 0; row < n - 1; row++) {
                    if (!sorted[row] &&
                        strs[row].charAt(col) < strs[row + 1].charAt(col)) {
                        sorted[row] = true;
                    }
                }
            }
        }

        return deletions;
    }
}
```

---

## â³ Complexity Analysis (Optimized)

| Metric    | Complexity |
| --------- | ---------- |
| **Time**  | O(n Ã— m)   |
| **Space** | O(n)       |

âœ” Optimal
âœ” No restarts
âœ” No sets
âœ” Single pass over columns

---

## ğŸ“Š Example Walkthrough

### Input

```text
["ca","bb","ac"]
```

### Execution

| Column | Check       | Result   |
| ------ | ----------- | -------- |
| 0      | `c > b`     | âŒ delete |
| 1      | `a â‰¤ b â‰¤ c` | âœ” keep   |

### Output

```text
1
```

---

# ğŸ§ª Your Restart-Based Solution (For Learning)

Your solution works by:

* Tracking deleted columns (`HashSet`)
* Restarting comparisons whenever a column is removed
* Ensuring correctness via re-validation

### Your Code (Correct but Slower)

```java []
class Solution {
    public int minDeletionSize(String[] strs) {
        String prev = strs[0];
        Set<Integer> exclusions = new HashSet<>();
        int len = strs[0].length();
        boolean isExcluded;

        for (int i = 1; i < strs.length; i++) {
            isExcluded = false;

            for (int j = 0; j < len; j++) {
                if (exclusions.contains(j) || prev.charAt(j) == strs[i].charAt(j)) {
                    continue;
                } else if (prev.charAt(j) < strs[i].charAt(j)) {
                    break;
                } else {
                    exclusions.add(j);
                    isExcluded = true;
                }
            }

            prev = strs[i];

            if (isExcluded) {
                prev = strs[0];
                i = 0;
            }

            if (exclusions.size() == len) break;
        }

        return exclusions.size();
    }
}
```

---

## â³ Complexity (Your Version)

| Metric    | Complexity                  |
| --------- | --------------------------- |
| **Time**  | O(n Ã— mÂ²) (due to restarts) |
| **Space** | O(m)                        |

âœ” Correct
âŒ Not optimal
âŒ Multiple rescans

---

## ğŸ” Side-by-Side Comparison

| Feature         | Your Solution | Optimized Greedy |
| --------------- | ------------- | ---------------- |
| Correctness     | âœ…             | âœ…                |
| Restarts        | âŒ Yes         | âœ… No             |
| Time            | O(nmÂ²)        | **O(nm)**        |
| Space           | O(m)          | O(n)             |
| Interview-Ready | âš ï¸            | â­â­â­â­â­            |

---

## ğŸ Final Takeaway

* **Delete Columns II is about resolving order early**
* Once order is known, **never compare again**
* The greedy `sorted[]` technique is the key insight
