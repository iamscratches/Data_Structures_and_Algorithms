# ğŸ”¢ Count Odd Numbers in an Interval Range

## â€” Mathematical Parity Analysis

ğŸ“Œ **LeetCode Link:**
[https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/description/?envType=daily-question&envId=2025-12-07](https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/description/?envType=daily-question&envId=2025-12-07)

---

## ğŸ“œ Problem Statement

You're given two integers:

* `low`
* `high`

representing a **closed interval**: `[low, high]`.

ğŸ‘‰ **Return the count of odd numbers within the interval.**

---

## ğŸ§  Intuition

Odd numbers repeat every **2 integers**.
So in any range:

* Roughly half the numbers are odd.
* But the boundaries matter (whether `low` or `high` are odd).

Key observation:
**The number of odd integers between low and high inclusive is:**

[
\text{oddCount} = \left\lfloor\frac{high - low}{2}\right\rfloor + 1 \quad \text{if at least one of low/high is odd}
]

[
\text{oddCount} = \left\lfloor\frac{high - low}{2}\right\rfloor \quad \text{if both are even}
]

This simplifies the logic significantly.

---

## âš™ï¸ Approach

We analyze parity of:

* `low`: odd or even
* `high`: odd or even

Then compute odd count using small arithmetic adjustments.

### Key Parity Cases

| low   | high  | Count formula          |
| ----- | ----- | ---------------------- |
| even  | even  | `(high - low) / 2`     |
| odd   | odd   | `(high - low) / 2 + 1` |
| mixed | mixed | `(high - low) / 2 + 1` |

If both ends are **even**, interval starts and ends on even numbers â†’ no extra odd.
Otherwise â†’ at least 1 odd included.

---

## âœ… Optimized Solution (Your Code)

```java
class Solution {
    public int countOdds(int low, int high) {
        if (high == low) {
            if ((high & 1) == 0) {
                return 0;
            }
            return 1;
        }
        if ((low & 1) == 0 && (high & 1) == 0) {
            return (high - low) / 2;
        }
        else if ((low & 1) != 0 && (high & 1) != 0) {
            return (high - low - 1) / 2 + 2;
        }
        else {
            return (high - low - 1) / 2 + 1;
        }
    }
}
```

âœ” Very fast
âœ” Pure math
âœ” Avoids loops â€” O(1) complexity

---

## â³ Complexity Analysis

| Metric    | Complexity | Explanation            |
| --------- | ---------- | ---------------------- |
| **Time**  | O(1)       | Constant-time formulas |
| **Space** | O(1)       | No extra memory        |

---

## ğŸ“Š Example Walkthrough

### Example 1

**Input:**
`low = 3, high = 7`
Numbers: 3,4,5,6,7 â†’ odds = 3,5,7 â†’ **3 odds**

Both odd â†’ formula:
[
(7-3-1)/2 + 2 = 3
]

---

### Example 2

**Input:**
`low = 4, high = 10`
Numbers: 4..10 â†’ odds: 5,7,9 â†’ **3 odds**

Both even â†’ formula:
[
(10-4)/2 = 3
]

---

### Example 3

**Input:**
`low = 2, high = 3`
Numbers: 2,3 â†’ only 3 â†’ **1 odd**

---

## ğŸ’¡ Key Features

* **Pure mathematical reasoning**
* **Minimal conditions**
* Uses **bitwise &** for fast parity checks
* Elegant case handling
* No loops, no arrays

---

## ğŸ” Edge Cases

* Single number:

  * `low = high = 2` â†’ 0
  * `low = high = 7` â†’ 1
* Very large values (within constraints): works instantly
* Adjacent intervals: `(high - low)` handles correctly

---

## âœ¨ Even Simpler Formula (Alternative Version)

You can also replace all case logic with:

```java
return (high + 1) / 2 - low / 2;
```

This works because:

* `n/2` gives number of evens up to n
* `(n+1)/2` gives number of odds up to n
* Subtraction â†’ odds in range

But your version is perfectly valid and mathematically explicit.

---

If you want, I can also rewrite your solution into the **one-liner mathematical formula version** with full explanation.
