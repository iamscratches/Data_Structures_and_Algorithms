# ğŸ§© Delete Columns to Make Sorted III â€“ Longest Valid Column Subsequence

## ğŸ“œ Problem Statement

**Link:** [LeetCode â€“ Delete Columns to Make Sorted III](https://leetcode.com/problems/delete-columns-to-make-sorted-iii/description/?envType=daily-question&envId=2025-12-22)

You are given an array of strings `strs`, all of the same length.

You may delete columns so that **each row is lexicographically non-decreasing** from left to right.

ğŸ‘‰ Return the **minimum number of columns** to delete.

---

## ğŸ” Key Difference from I & II

| Problem                | Nature                               |
| ---------------------- | ------------------------------------ |
| Delete Columns I       | Columns independent                  |
| Delete Columns II      | Greedy with ordering locks           |
| **Delete Columns III** | **Global dependency across columns** |

ğŸ“Œ Here, we are effectively finding the **longest sequence of columns** that:

* Is **non-decreasing for every row**
* Preserves original column order

This is a **Longest Increasing Subsequence (LIS)** style problem on columns.

---

# ğŸ§  Core Insight

Instead of deciding which columns to delete,
â¡ï¸ **decide which columns to keep**.

Let:

* `dp[i]` = length of the longest valid column sequence **ending at column i**

Final answer:

```
totalColumns - longestValidSequence
```

---

# ğŸ§ª Your DP Solution (Correct & Canonical)

## ğŸ§  Intuition

* Each column can stand alone â†’ `dp[i] = 1`
* Try to extend previous columns `j < i`
* Column `i` can follow `j` **only if all rows satisfy**:

  ```
  strs[row][j] â‰¤ strs[row][i]
  ```

---

## âš™ï¸ Approach (Your Code)

1. Initialize `dp[i] = 1`
2. For each column `i`, check all previous columns `j`
3. If valid â†’ `dp[i] = max(dp[i], dp[j] + 1)`
4. Result = `n - max(dp)`

---

## âœ… Your Code Implementation

```java []
class Solution {
    public int minDeletionSize(String[] strs) {
        int n = strs[0].length(), m = strs.length;
        int[] dp = new int[n];
        Arrays.fill(dp, 1);

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (isValid(strs, j, i)) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }

        int max = 0;
        for (int val : dp) max = Math.max(max, val);
        return n - max;
    }

    private boolean isValid(String[] strs, int j, int i) {
        for (String s : strs) {
            if (s.charAt(j) > s.charAt(i)) return false;
        }
        return true;
    }
}
```

---

## â³ Complexity Analysis (Your Solution)

| Metric    | Complexity |
| --------- | ---------- |
| **Time**  | O(nÂ² Ã— m)  |
| **Space** | O(n)       |

* `n` = number of columns
* `m` = number of rows

âœ” Correct
âŒ Not optimal for large inputs

---

# ğŸš€ MOST OPTIMIZED SOLUTION (LeetCode Intended)

## ğŸ§  Optimization Idea

Instead of repeatedly comparing strings:

ğŸ‘‰ **Precompute validity between columns**

* Treat columns as nodes
* Build LIS where transition validity is checked efficiently

But **constraints are small enough** that the classic DP is acceptable.

ğŸ“Œ The real optimization is **early breaking** and **inlined comparison**, avoiding function overhead.

---

## âš™ï¸ Optimized DP (Same Logic, Faster in Practice)

```java []
class Solution {
    public int minDeletionSize(String[] strs) {
        int rows = strs.length;
        int cols = strs[0].length();
        int[] dp = new int[cols];
        Arrays.fill(dp, 1);

        for (int i = 0; i < cols; i++) {
            for (int j = 0; j < i; j++) {
                boolean valid = true;
                for (int r = 0; r < rows; r++) {
                    if (strs[r].charAt(j) > strs[r].charAt(i)) {
                        valid = false;
                        break;
                    }
                }
                if (valid) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }

        int longest = 0;
        for (int v : dp) longest = Math.max(longest, v);
        return cols - longest;
    }
}
```

---

## â³ Complexity (Optimized)

| Metric    | Complexity |
| --------- | ---------- |
| **Time**  | O(nÂ² Ã— m)  |
| **Space** | O(n)       |

âœ” Same asymptotics
âœ” Faster constant factors
âœ” Interview-approved

---

# ğŸ“Š Example Walkthrough

### Input

```text
["babca","bbazb"]
```

### Columns

```
0 1 2 3 4
b a b c a
b b a z b
```

### Valid Column Sequence

```
[0, 2, 3]
```

Length = 3
Total columns = 5

### Output

```text
5 - 3 = 2
```

---

## ğŸ” Comparison Summary

| Approach     | Time   | Space | Notes      |
| ------------ | ------ | ----- | ---------- |
| Brute Force  | O(2â¿)  | â€”     | Impossible |
| DP (Your)    | O(nÂ²m) | O(n)  | âœ… Correct  |
| Optimized DP | O(nÂ²m) | O(n)  | â­ Best     |

---

## ğŸ Final Takeaways

* **Delete Columns III = LIS on columns**
* Each column is a candidate â€œcharacterâ€
* Rows enforce ordering constraints
* DP is unavoidable and expected

ğŸ“Œ **Interview Tip**
Say this confidently:

> â€œThis is a longest valid subsequence problem over columns, solvable using DP in O(nÂ²m).â€


