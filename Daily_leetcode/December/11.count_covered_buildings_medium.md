# ğŸ™ï¸ Count Covered Buildings â€” Grid-Based Bounding Analysis

## ğŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/count-covered-buildings/description/](https://leetcode.com/problems/count-covered-buildings/description/)

You are given:

* An integer `n` (grid size is `n Ã— n`)
* A list of `buildings`, where each building is a coordinate `(x, y)`

A building is considered **covered** if:

* It is *not* the top-most or bottom-most building in its **column**, **and**
* It is *not* the left-most or right-most building in its **row**

Formally, for a building `(x, y)`:

```
Let Col[x] = all buildings with same x
Let Row[y] = all buildings with same y

A building is "covered" if:
    minY(x) < y < maxY(x)
AND minX(y) < x < maxX(y)
```

Your goal is to count how many buildings satisfy this condition.

---

## ğŸ§  Intuition

We want to determine buildings that are:

### âœ” Blocked vertically (not highest or lowest in its column)

### âœ” Blocked horizontally (not leftmost or rightmost in its row)

So the problem becomes:

### For each column `x`:

* Find smallest y-coordinate â†’ `colMinY[x]`
* Find largest y-coordinate â†’ `colMaxY[x]`

### For each row `y`:

* Find smallest x-coordinate â†’ `rowMinX[y]`
* Find largest x-coordinate â†’ `rowMaxX[y]`

Then a building `(x, y)` is covered if:

```
colMinY[x] < y < colMaxY[x]
AND
rowMinX[y] < x < rowMaxX[y]
```

This is a classic **bounding-box interior check**.

---

## âš™ï¸ Approach

### **1ï¸âƒ£ Identify coordinate bounds**

To avoid huge array sizes, compute:

* `minX`, `maxX`
* `minY`, `maxY`

Then compress coordinates to small ranges.

---

### **2ï¸âƒ£ Build vertical and horizontal bounds**

Use two arrays:

* `columnMinMax[x] = { minY, maxY }`
* `rowMinMax[y] = { minX, maxX }`

Initialize:

* `min = +âˆ`
* `max = -1`

Process all buildings to fill these bounds.

---

### **3ï¸âƒ£ Count covered buildings**

For each building `(x, y)`:

```
If y is strictly between minY[x] and maxY[x]
AND
x is strictly between minX[y] and maxX[y]
â†’ Count it.
```

Return the total.

---

## âœ… Clean & Polished Code Implementation

```java []
class Solution {
    public int countCoveredBuildings(int n, int[][] buildings) {

        int maxX = -1, minX = Integer.MAX_VALUE;
        int maxY = -1, minY = Integer.MAX_VALUE;

        // Step 1: Find coordinate bounds
        for (int[] b : buildings) {
            int x = b[0], y = b[1];
            maxX = Math.max(maxX, x);
            minX = Math.min(minX, x);
            maxY = Math.max(maxY, y);
            minY = Math.min(minY, y);
        }

        // Step 2: Prepare compressed arrays
        int[][] colMinMax = new int[maxX - minX + 1][2];
        int[][] rowMinMax = new int[maxY - minY + 1][2];

        // Initialize boundaries
        for (int[] col : colMinMax) {
            col[0] = Integer.MAX_VALUE; // minY
            col[1] = -1;                // maxY
        }
        for (int[] row : rowMinMax) {
            row[0] = Integer.MAX_VALUE; // minX
            row[1] = -1;                // maxX
        }

        // Step 3: Fill column and row ranges
        for (int[] b : buildings) {
            int x = b[0], y = b[1];

            int cx = x - minX;
            int ry = y - minY;

            colMinMax[cx][0] = Math.min(colMinMax[cx][0], y);
            colMinMax[cx][1] = Math.max(colMinMax[cx][1], y);

            rowMinMax[ry][0] = Math.min(rowMinMax[ry][0], x);
            rowMinMax[ry][1] = Math.max(rowMinMax[ry][1], x);
        }

        // Step 4: Count covered buildings
        int covered = 0;
        for (int[] b : buildings) {
            int x = b[0], y = b[1];

            int cx = x - minX;
            int ry = y - minY;

            boolean coveredVertically =
                y > colMinMax[cx][0] && y < colMinMax[cx][1];

            boolean coveredHorizontally =
                x > rowMinMax[ry][0] && x < rowMinMax[ry][1];

            if (coveredVertically && coveredHorizontally) {
                covered++;
            }
        }

        return covered;
    }
}
```

---

## â³ Complexity Analysis

| Metric    | Complexity | Explanation                         |
| --------- | ---------- | ----------------------------------- |
| **Time**  | O(m)       | m = number of buildings             |
| **Space** | O(U)       | U = range of x/y spans (compressed) |

---

## ğŸ“Š Example Walkthrough

Suppose:

```
buildings = [
  [2, 3],
  [2, 5],
  [2, 7],
  [1, 5],
  [3, 5]
]
```

### Columns:

* Column 2 â†’ y âˆˆ {3, 5, 7} â†’ min=3, max=7
* Column 1 â†’ y âˆˆ {5} â†’ min=max=5
* Column 3 â†’ y âˆˆ {5} â†’ min=max=5

### Rows:

* Row 5 â†’ x âˆˆ {1,2,3} â†’ min=1, max=3
* Row 3 â†’ x âˆˆ {2}
* Row 7 â†’ x âˆˆ {2}

### Covered?

Check building `(2,5)`:

```
3 < 5 < 7   âœ“ vertically inside
1 < 2 < 3   âœ“ horizontally inside

â†’ Covered
```

Answer = number of such buildings.

---

## ğŸ’¡ Key Takeaways

* A building is covered only if it is strictly within a bounding box in both dimensions
* Efficient because we only evaluate min/max in rows and columns
* Coordinate compression ensures memory efficiency
* Simple array-based solution â†’ no sorting required

