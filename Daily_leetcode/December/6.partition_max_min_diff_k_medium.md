Here is a clean, polished, full write-up **in the same style** as before â€” structured, detailed, intuitive, mathematical, and following the same formatting.

---

# ğŸ§© Count Partitions With Maxâ€“Min Difference â‰¤ k

### â€” Sliding Window + DP + Prefix Sum Optimization

ğŸ“Œ **Problem Link:**
[https://leetcode.com/problems/count-partitions-with-max-min-difference-at-most-k/description/?envType=daily-question&envId=2025-12-07](https://leetcode.com/problems/count-partitions-with-max-min-difference-at-most-k/description/?envType=daily-question&envId=2025-12-07)

---

## ğŸ“œ Problem Statement

Given:

* An integer array `nums`
* An integer `k`

You want to partition the array into a sequence of **contiguous subarrays**, such that in **every** partition:

[
\max(subarray) - \min(subarray) \le k
]

Return:

* The **number of valid ways** to partition the entire array
* Return value modulo (10^9 + 7)

Each partitioning is a way of inserting separators `|` between elements.

---

## ğŸ§  Intuition

This is a **DP with sliding window + monotonic queues** problem.

### Key ideas:

### **1. Sliding window maintains the largest valid subarray ending at index `i`.**

We want all `j` such that the subarray:

[
nums[j..i]
]

is valid:

[
\max(nums[j..i]) - \min(nums[j..i]) \le k
]

To identify the smallest valid `j`, we use:

* **Monotonic decreasing deque** â†’ tracks max
* **Monotonic increasing deque** â†’ tracks min

When constraint is violated, we move the `left` boundary forward.

---

### **2. DP formulation**

Define:

[
dp[i] = \text{# ways to partition prefix of length } i
]

If last segment starts at index `j`:

[
dp[i] = \sum_{j = left}^{i-1} dp[j]
]

But this sum is expensive â†’ **O(nÂ²)**.

---

### **3. Prefix-sum optimization**

Let:

[
prefix[i] = dp[0] + dp[1] + \dots + dp[i-1]
]

Then:

[
dp[i] = prefix[i] - prefix[left]
]

This reduces DP to **O(1)** per index.

---

### **4. MOD arithmetic is needed**

Because dp counts can be very large.

---

## âš™ï¸ Approach Breakdown

### **1. Maintain two deques:**

* `max`: decreasing, so front is current window maximum
* `min`: increasing, so front is current window minimum

### **2. Expand right pointer `i`:**

* Insert `nums[i]` while maintaining monotonicity.

### **3. Shrink left pointer while invalid:**

[
\max - \min > k
]

Remove outdated indices from deques as you move `left`.

### **4. Compute dp[i+1]:**

[
dp[i+1] = prefix[i+1] - prefix[left]
]

### **5. Update prefix:**

[
prefix[i+2] = prefix[i+1] + dp[i+1]
]

---

## âœ… Optimized Solution (Your Code)

```java
class Solution {
    public int countPartitions(int[] nums, int k) {
        int MOD = (int) 1e9 + 7, n = nums.length, left = 0;
        int[] dp = new int[n + 1], prefix = new int[n + 2]; 
        
        dp[0] = 1; 
        prefix[1] = 1; 
        
        Deque<Integer> min = new ArrayDeque<>(), max = new ArrayDeque<>();
                
        for (int i = 0; i < n; i++) {
            while (!max.isEmpty() && nums[max.peekLast()] <= nums[i]) {
                max.pollLast();
            }
            max.addLast(i);
            
            while (!min.isEmpty() && nums[min.peekLast()] >= nums[i]) {
                min.pollLast();
            }
            min.addLast(i);
            
            while (nums[max.peekFirst()] - nums[min.peekFirst()] > k) {
                if (max.peekFirst() == left) max.pollFirst();
                if (min.peekFirst() == left) min.pollFirst();
                
                left++;
            }
            
            dp[i + 1] = (prefix[i + 1] - prefix[left] + MOD) % MOD;
            
            prefix[i + 2] = (prefix[i + 1] + dp[i + 1]) % MOD;
        }
        
        return dp[n];
    }
}
```

---

## ğŸ“Š Complexity Analysis

| Metric    | Complexity | Explanation                                    |
| --------- | ---------- | ---------------------------------------------- |
| **Time**  | O(n)       | Each index is pushed/popped once in each deque |
| **Space** | O(n)       | dp + prefix + two deques                       |

---

## ğŸ” Example Walkthrough

Suppose:

```
nums = [3, 6, 4], k = 3
```

### i = 0 â†’ window = [3]

* max = 3, min = 3 â†’ valid
  dp[1] = prefix[1] âˆ’ prefix[0] = 1
  prefix[2] = 2

### i = 1 â†’ window = [3, 6]

* max = 6, min = 3 â†’ diff = 3 â†’ valid
  dp[2] = prefix[2] âˆ’ prefix[0] = 2
  prefix[3] = 4

### i = 2 â†’ window = [6, 4]

* max = 6, min = 4 â†’ diff = 2 â†’ valid
  dp[3] = prefix[3] âˆ’ prefix[1] = 3
  prefix[4] = 7

Answer: **dp[3] = 3 ways**

---

## ğŸ’¡ Why This Works

This solution uses the combination of:

* **Monotonic queues** to maintain valid windows in O(1)
* **Prefix-sum DP optimization** to avoid O(nÂ²)
* **Accurate modular arithmetic**
* **Sliding window strategy** for contiguous partitions

This is one of the most elegant combinations of algorithms on LeetCode.

---

## ğŸš€ When to Use This Pattern

Whenever you see:

* Contiguous subarray constraints
* Constraints based on **maxâ€“min**
* Counting all ways
* DP with large summation ranges
* Needs modulo arithmetic

This pattern is extremely reusable.

---

If you want, I can also generate:

âœ… A fully visual diagram of the sliding window
âœ… A simplified or alternative DP solution
âœ… A commented version of your code

Just tell me!
