# ğŸ—‚ï¸ Delete Columns to Make Sorted â€“ Column-Wise Greedy Check

## ğŸ“œ Problem Statement

**Link:** [LeetCode â€“ Delete Columns to Make Sorted](https://leetcode.com/problems/delete-columns-to-make-sorted/description/?envType=daily-question&envId=2025-12-20)

You are given an array of strings `strs`, all having the **same length**.

A column is considered **sorted** if the characters from top to bottom are in **non-decreasing lexicographical order**.

ğŸ‘‰ Your task is to **delete the minimum number of columns** such that the remaining columns are sorted.

---

## ğŸ§  Intuition

Each column is **independent** of others.

So instead of rearranging strings:

* We simply **scan each column**
* Check if it is sorted **top â†’ bottom**
* If **any inversion** occurs â†’ delete that column

Key observation:

> A column is invalid if there exists **any row `j`** such that
> `strs[j-1][i] > strs[j][i]`

---

## âš™ï¸ Approach

### **Column-Wise Validation**

1. Initialize `count = 0`
2. For each column `i`:

   * Compare characters from row `0 â†’ n-1`
   * If an inversion is found:

     * Increment `count`
     * Stop checking that column
3. Return `count`

This is a **greedy and optimal** approach.

---

## âœ… Code Implementation

```java []
class Solution {
    public int minDeletionSize(String[] strs) {
        int count = 0;

        for (int i = 0; i < strs[0].length(); i++) {
            char prev = strs[0].charAt(i);

            for (int j = 1; j < strs.length; j++) {
                if (prev > strs[j].charAt(i)) {
                    count++;
                    break;
                }
                prev = strs[j].charAt(i);
            }
        }

        return count;
    }
}
```

---

## â³ Complexity Analysis

| Metric    | Complexity | Explanation              |
| --------- | ---------- | ------------------------ |
| **Time**  | O(m Ã— n)   | `m` columns, `n` rows    |
| **Space** | O(1)       | No extra data structures |

---

## ğŸ“Š Example Walkthrough

### Input

```text
strs = ["cba","daf","ghi"]
```

### Column Analysis

| Column | Characters | Sorted? | Action |
| ------ | ---------- | ------- | ------ |
| 0      | c â†’ d â†’ g  | âœ”       | Keep   |
| 1      | b â†’ a â†’ h  | âŒ       | Delete |
| 2      | a â†’ f â†’ i  | âœ”       | Keep   |

### Output

```text
1
```

---

## ğŸ’¡ Key Observations

* Columns are **independent**
* One inversion is enough to delete a column
* No need for sorting or reordering
* Works perfectly with fixed-length strings

---

## ğŸš€ When to Use This Approach

* Column-wise validation problems
* Fixed-length string grids
* Greedy elimination problems
* Lexicographical order checks

---

## âš ï¸ Edge Cases

| Case                 | Output                         |
| -------------------- | ------------------------------ |
| Single string        | 0                              |
| Already sorted       | 0                              |
| All columns inverted | length of string               |
| Duplicate characters | Valid (non-decreasing allowed) |

---

## ğŸ”„ Comparison with Other Approaches

| Approach           | Time        | Space | Notes       |
| ------------------ | ----------- | ----- | ----------- |
| Column scan (this) | O(mn)       | O(1)  | Optimal     |
| Sorting columns    | O(mn log n) | O(n)  | Overkill    |
| DP / Graph         | âŒ           | âŒ     | Unnecessary |

---

## ğŸ§  Final Takeaway

This problem is a textbook example of:
âœ” Greedy thinking
âœ” Column-wise traversal
âœ” Early termination optimization

Once you recognize column independence, the solution becomes **simple, efficient, and elegant**.

