# ðŸ”¢ Count Square Sum Triples

### â€” Brute Force With Mathematical Insight

ðŸ“Œ **Problem Link:**
[https://leetcode.com/problems/count-square-sum-triples/description/?envType=daily-question&envId=2025-12-08](https://leetcode.com/problems/count-square-sum-triples/description/?envType=daily-question&envId=2025-12-08)

---

## ðŸ“œ Problem Statement

You are given an integer `n`.

A **square sum triple** is a set of **positive integers** `(a, b, c)` such that:

[
a^2 + b^2 = c^2
]

and:

* (1 \le a < b < c \le n)

Return the **number of valid triples**.

---

## ðŸ§  Intuition

This problem is about counting **Pythagorean triples** within a bound `n`.

### Key observations:

1. The constraint ((a^2 + b^2 = c^2)) means we're only searching for **Pythagorean triples**.
2. (1 \le a < b < c \le n) â€” ordered triples only.
3. If ((a, b, c)) is a valid triple, then so is ((b, a, c)) â€”
   but since the problem uses (a<b<c), we count **each unordered pair only once** unless the code explicitly doubles it.
4. A simple brute-force solution is perfectly fine for constraints (n â‰¤ 250 given by LeetCode).

Your code uses the naive approach:

* Loop `i` < `j` < `k`
* Check if `iÂ² + jÂ² = kÂ²`
* Count 2 permutations when `i != j` (because original logic attempted to count ordered pairs)

---

## âš™ï¸ Approach

### **1. Loop through all i, j, k such that**

```
1 â‰¤ i < j < k â‰¤ n
```

### **2. Check if**

[
i^2 + j^2 = k^2
]

### **3. Counting logic**

Your code uses:

* `count += 2` when `i != j`
* `count++` when `i == j`

However, since i < j always, `i == j` is impossible â€” but it does not break correctness.

---

## âœ… Brute-Force (Your Code)

```java
class Solution {
    public int countTriples(int n) {
        if(n <= 4){
            return 0;
        }
        int count = 0;
        for(int i = 1; i < n - 1; i++){
            for(int j = i + 1; j < n; j++){
                for(int k = j + 1; k <= n; k++){
                    if((i*i + j*j) == k*k){
                        if(i != j){
                            count += 2;
                        }
                        else{
                            count++;
                        }
                    }
                }
            }
        }
        return count;
    }
}
```

---

## ðŸ“Š Complexity Analysis

| Metric    | Complexity | Reason             |
| --------- | ---------- | ------------------ |
| **Time**  | (O(n^3))   | Three nested loops |
| **Space** | (O(1))     | Only uses counters |

Given `n â‰¤ 250` â†’ total operations â‰ˆ 15.6 million â†’ acceptable.

---

## ðŸ” Example Walkthrough

### Input:

```
n = 5
```

Valid triples:

* (3, 4, 5) â†’ 3Â² + 4Â² = 5Â²

Only one.

Since your code counts `(3,4,5)` and `(4,3,5)` separately:

```
output = 2
```

Which matches the problem requirement (count ordered triples).

---

## ðŸ’¡ Key Features of This Approach

* **Straightforward** and easy to write
* **Mathematically accurate** for Pythagorean triples
* Good for constraints provided
* Can be optimized using hash sets or precomputed squares, but brute-force is sufficient

---

## ðŸš€ When to Use This Pattern

* Small upper bounds (n â‰¤ 250)
* Pythagorean triple enumeration
* Educational brute-force search problems

---

## ðŸ›  Possible Optimizations (Optional)

1. Precompute `squares[]`
2. Reverse search: loop over `a`, `b`, compute `c = sqrt(aÂ² + bÂ²)`
3. Use integer square root function for faster checking

But brute force is clean, readable, and passes well.

---

If you want, I can also provide:

âœ… An optimized O(nÂ²âˆšn) version
âœ… A mathematics-based O(nÂ²) version
â‡ï¸ A fully visual explanation with diagram of Pythagorean triples

Just ask!
