# ğŸ“‰ Number of Smooth Descent Periods of a Stock â€“ Single Pass Counting

## ğŸ“œ Problem Statement

**Link:** [LeetCode â€“ Number of Smooth Descent Periods of a Stock](https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/description/?envType=daily-question&envId=2025-12-15)

You are given an integer array `prices`, where `prices[i]` is the stock price on day `i`.

A **smooth descent period** is defined as:

* A contiguous subarray where for every consecutive pair:

  ```
  prices[i] == prices[i+1] + 1
  ```

Return the **total number of smooth descent periods**.

---

## ğŸ§  Intuition

Every **individual day** forms a valid smooth descent period of length 1.

Longer descent periods can be built **incrementally**:

* If todayâ€™s price is exactly **1 less** than yesterdayâ€™s, the descent continues.
* Otherwise, the descent **breaks** and resets.

Key insight:

> For a descending streak of length `L`, the number of valid descent subarrays is:

```
1 + 2 + 3 + ... + L
```

Instead of computing this explicitly, we can **accumulate counts on the fly**.

---

## âš™ï¸ Approach

### **1ï¸âƒ£ Initialize Counters**

* `count` â†’ length of current smooth descent streak
* `ans` â†’ total number of descent periods

### **2ï¸âƒ£ Iterate Through Prices**

For each adjacent pair:

* If `prices[i] == prices[i+1] + 1`

  * Extend the descent â†’ `count++`
* Else

  * Reset descent â†’ `count = 1`

Add `count` to the answer at each step.

---

## âœ… Code Implementation

```java []
class Solution {
    public long getDescentPeriods(int[] prices) {
        long ans = 1, count = 1;

        for (int i = 0; i < prices.length - 1; i++) {
            if (prices[i] == prices[i + 1] + 1) {
                count++;
            } else {
                count = 1;
            }
            ans += count;
        }
        return ans;
    }
}
```

---

## â³ Complexity Analysis

| Metric    | Complexity | Explanation               |
| --------- | ---------- | ------------------------- |
| **Time**  | O(n)       | Single pass through array |
| **Space** | O(1)       | Constant extra space      |

---

## ğŸ“Š Example Walkthrough

### Example 1

```text
Input: prices = [3,2,1,4]
```

Step-by-step:

| Index | Price | Descent? | count | ans |
| ----- | ----- | -------- | ----- | --- |
| 0     | 3     | â€”        | 1     | 1   |
| 1     | 2     | Yes      | 2     | 3   |
| 2     | 1     | Yes      | 3     | 6   |
| 3     | 4     | No       | 1     | 7   |

âœ… Output:

```text
7
```

---

### Example 2

```text
Input: prices = [8,6,7,7]
```

Smooth periods:

* [8], [6], [7], [7]
* No valid descending chains

Output:

```text
4
```

---

## ğŸ’¡ Key Features

* âœ” One-pass solution
* âœ” No extra memory
* âœ” Handles large inputs efficiently
* âœ” Uses arithmetic accumulation instead of nested loops

---

## ğŸš€ When to Use This Pattern

* Counting subarrays with **local continuity**
* Problems involving **monotonic sequences**
* Efficient replacement for nested loops
* Dynamic counting with rolling state

---

## ğŸ”„ Why This Works

At each index:

* `count` represents **how many valid descent subarrays end here**
* Adding `count` accumulates all valid subarrays efficiently

This avoids:

* O(nÂ²) brute force
* Explicit summation formulas

---

## âš ï¸ Edge Cases

| Case                | Result   |
| ------------------- | -------- |
| Single element      | 1        |
| Strictly increasing | n        |
| Strictly decreasing | n(n+1)/2 |
| All equal values    | n        |

---

## ğŸ§  Final Takeaway

This is a **classic sliding streak problem**:

> Track the current streak length
> Add it to the total at each step