# ğŸ‰ Maximize Happiness of Selected Children

## ğŸ“œ Problem Statement

**Link:**
[https://leetcode.com/problems/maximize-happiness-of-selected-children/description/?envType=daily-question&envId=2025-12-25](https://leetcode.com/problems/maximize-happiness-of-selected-children/description/?envType=daily-question&envId=2025-12-25)

You are given:

* An integer array `happiness` where `happiness[i]` is the happiness value of the ith child.
* An integer `k` representing the number of children that can receive candies.

Rules:

* You must select **exactly k children**.
* When you select a child with happiness value `h`, the actual contribution to **total happiness** is:

  ```
  happiness[i] - (# of candies already given before this child)
  ```

  (This reduction increases by 1 per child you've already selected.)

Return the **maximum total happiness** you can achieve by selecting exactly `k` children.

---

## ğŸ§  Intuition

Each time you give a candy:

* The **happiness reduction increases by 1**.
* So the first child selected experiences no reduction, the next has a reduction of 1, and so on.

So if we sort happiness in descending order:

* We ideally want to give candies to the largest happiness values first,
* Because later selections will have bigger reduction penalties.

Then:

* The sum of `(happiness[i] - idx)` for the **top k** values (but stopping early if they become <= 0).

The strategy becomes:

1. Sort descending
2. Greedily take from largest to smallest
3. For each selected child at position `i`:

   ```
   effective = happiness[i] - (number of candies already given)
   ```
4. Add positive contributions only

---

## âš™ï¸ Your Implementation (Greedy + Sort)

```java []
class Solution {
    public long maximumHappinessSum(int[] happiness, int k) {
        int happinessReduction = 0;
        long sum = 0;

        Arrays.sort(happiness);
        int len = happiness.length;

        for (int i = len - 1; happinessReduction < k; i--) {
            int effective = happiness[i] - happinessReduction;
            if (effective > 0) {
                sum += effective;
                happinessReduction++;
            } else {
                break;
            }
        }
        return sum;
    }
}
```

---

## â³ Complexity Analysis

| Metric    | Complexity | Explanation          |
| --------- | ---------- | -------------------- |
| **Time**  | O(n log n) | Sorting `happiness`  |
| **Space** | O(1)       | Only a few variables |

* Sorting dominates cost.
* Greedy loop runs at most `k` times.

---

## ğŸ“Š Example Walkthrough

### Example

```
happiness = [5, 3, 7, 2]
k = 3
```

After sorting:

```
[2, 3, 5, 7]
```

Pick in this order:

| Selection | value | reduction | effective |
| --------- | ----- | --------- | --------- |
| 1st       | 7     | 0         | 7         |
| 2nd       | 5     | 1         | 4         |
| 3rd       | 3     | 2         | 1         |

Total = 7 + 4 + 1 = **12**

Output:

```
12
```

---

## ğŸ’¡ Key Observations

* Always take the **largest values first** because future selections are penalized by increasing reduction.
* Once increasing reduction makes a choice non-positive, we stop (because all smaller values afterward will also be non-positive).
* You donâ€™t need to consider values that become â‰¤ 0 after reduction.

---

## ğŸš€ Optimized Insight

Your solution is already optimal under the constraints:

* Sorting + greedy selection yields the best result.
* No need for more complex data structures because the reduction penalty is linear and predictable.

However, we can make a slight **clarification improvement** for readability and correctness:

---

## ğŸ§  Clarified Code (Same Logic, More Readable)

```java []
class Solution {
    public long maximumHappinessSum(int[] happiness, int k) {
        Arrays.sort(happiness);

        long total = 0;
        int reduction = 0;
        int n = happiness.length;

        for (int i = n - 1; i >= 0 && reduction < k; i--, reduction++) {
            int effective = happiness[i] - reduction;
            if (effective > 0) {
                total += effective;
            } else {
                break;
            }
        }
        return total;
    }
}
```

---

## ğŸ½ï¸ Edge Cases

| Case                                           | Output                                       |
| ---------------------------------------------- | -------------------------------------------- |
| All negative happiness                         | 0                                            |
| k = 0                                          | 0                                            |
| Large k greater than count of positive profits | Max possible based on positive contributions |
| Happiness values smaller than penalties        | 0                                            |

---

## ğŸ§  Final Takeaways

âœ” Sort descending
âœ” Greedy take top candidates
âœ” Linear reduction penalty
âœ” Stop when contribution â‰¤ 0

---

## ğŸ Interview Tip

When faced with a **penalty that increases with selections**:

* Try ordering by effectiveness
* Greedy with sorted values often works
* Check for early stopping to avoid unnecessary work

