# ðŸ“‰ Minimum Penalty for a Shop

## ðŸ“œ Problem Statement

**Link:** [https://leetcode.com/problems/minimum-penalty-for-a-shop/description/?envType=daily-question&envId=2025-12-26](https://leetcode.com/problems/minimum-penalty-for-a-shop/description/?envType=daily-question&envId=2025-12-26)

You are given a string `customers` of length `n` where:

* `customers[i] == 'Y'` â†’ a customer comes at hour `i`
* `customers[i] == 'N'` â†’ no customer at hour `i`

You can choose an hour `k` (0 â‰¤ `k` â‰¤ `n`) to **close the shop** such that:

* If the shop is open at hour `i` < `k` and no one comes â†’ penalty +1
* If the shop is closed at hour `i` â‰¥ `k` and someone comes â†’ penalty +1

Return the **earliest hour `k`** that minimizes the penalty.

---

## ðŸ§  Intuition

We want to choose a closing time `k` such that:

* All `'Y'` before `k` are **happy** (no penalty)
* All `'N'` after `k` are **happy**
* Any `'N'` before `k` â†’ penalty
* Any `'Y'` after `k` â†’ penalty

Equivalent formulation:

* Define penalty at time `k` =

  ```
  (# of 'N' in [0, k-1]) + (# of 'Y' in [k, n-1])
  ```

We can compute penalties efficiently using prefix/suffix counts and scan to find minimal.

---

## âš™ï¸ Approach Overview

### Key steps

1. Compute total number of `'N'`s (this is the penalty if `k = n`)
2. Start scanning from right to left

   * When moving `k` earlier:

     * Every `'Y'` we include now â†’ penalty increases by 1
     * Every `'N'` we exclude from the suffix â†’ penalty decreases by 1

This gives you the penalty for each `k` in O(n) time.

---

## âœ… Your Implementation

```java
class Solution {
    public int bestClosingTime(String customers) {
        int len = customers.length();
        char[] ch = customers.toCharArray();
        
        // Initial penalty when k = n (all hours closed)
        int penalty = 0;
        for (int i = 0; i < len; i++) {
            if (ch[i] == 'N') {
                penalty++;
            }
        }
        
        // Track the best minimum penalty and its corresponding hour
        int minPenalty = penalty;
        int optimalHour = len;
        
        // Move k leftwards
        for (int i = len - 1; i >= 0; i--) {
            if (ch[i] == 'Y') {
                // Now this Y is in the closed range â†’ penalty
                penalty++;
            } else {
                // This N was previously in closed range â†’ removing it reduces penalty
                penalty--;
            }
            // If we get a smaller or equal penalty we update the answer
            if (penalty <= minPenalty) {
                minPenalty = penalty;
                optimalHour = i;
            }
        }
        
        return optimalHour;
    }
}
```

---

## ðŸ§ª Example Walkthrough

### Example 1

```
customers = "YYNY"
```

Positions: 0:Y 1:Y 2:N 3:Y

Compute penalties:

| k | [0..k-1] N count | [k..3] Y count | Penalty |
| - | ---------------- | -------------- | ------- |
| 0 | 0                | Y,Y,N,Y (3 Y)  | 3       |
| 1 | 0                | Y,N,Y (2 Y)    | 2       |
| 2 | 0                | N,Y (1 Y)      | 1       |
| 3 | 1 N              | Y (1 Y)        | 2       |
| 4 | 1 N              | (0)            | 1       |

Minimum penalty = 1 â†’ earliest index = 2 or 4 â†’ **2**

---

## â³ Time & Space Complexity

| Metric    | Complexity | Reason                                                    |
| --------- | ---------- | --------------------------------------------------------- |
| **Time**  | O(n)       | Single pass + one backward scan                           |
| **Space** | O(n)       | For char array (can be O(1) if direct string access used) |

---

## ðŸ’¡ Key Observations

* Initializing with all `'N'`s assumes closing at end (`k = n`)
* Scanning backward correctly updates penalty
* Ties (equal penalty) take **earliest** closing time
* Two counters are enough â†’ no need for extra arrays

---

## âœ” Correctness Notes

* Your code handles equal penalty by scanning from the end and using `<=`, which ensures the **earliest** hour is kept.
* This logic is sound because when penalties at multiple `k` are equal, the algorithm will overwrite only if penalty â‰¤ `minPenalty`.

---

## ðŸš€ Alternative Explanation (Prefixâ€“Suffix Style)

### Prefix arrays

Define:

```
prefixN[i] = number of 'N' in [0..i-1]
suffixY[i] = number of 'Y' in [i..n-1]
```

Then penalty at `k`:

```
prefixN[k] + suffixY[k]
```

We want min of this over all `0 â‰¤ k â‰¤ n`.

This can be computed in one linear pass.

---

## ðŸ“Œ Simplest Version Using Prefix/Suffix (Clean)

```java
class Solution {
    public int bestClosingTime(String customers) {
        int n = customers.length();
        int[] prefixN = new int[n + 1];
        int[] suffixY = new int[n + 1];

        // Build prefix count of 'N'
        for (int i = 0; i < n; i++) {
            prefixN[i + 1] = prefixN[i] + (customers.charAt(i) == 'N' ? 1 : 0);
        }

        // Build suffix count of 'Y'
        for (int i = n - 1; i >= 0; i--) {
            suffixY[i] = suffixY[i + 1] + (customers.charAt(i) == 'Y' ? 1 : 0);
        }

        int minPenalty = Integer.MAX_VALUE;
        int bestHour = 0;

        for (int k = 0; k <= n; k++) {
            int penalty = prefixN[k] + suffixY[k];
            if (penalty < minPenalty) {
                minPenalty = penalty;
                bestHour = k;
            }
        }

        return bestHour;
    }
}
```

âœ” Slightly more intuitive
âœ” Same O(n) time and space

---

## âš  Edge Cases

| Input      | Output              |
| ---------- | ------------------- |
| "" (empty) | 0                   |
| "NNNN"     | 4                   |
| "YYYY"     | 0                   |
| "NYNYNY"   | computed by formula |

---

## ðŸ§  Final Takeaway

This problem is about translating the penalty definition into efficient counting.

* Whether you use backward cumulative updates or prefixâ€“suffix arrays,
* The key insight is that penalty at time `k` = (# of Ns before `k`) + (# of Ys after `k`).

