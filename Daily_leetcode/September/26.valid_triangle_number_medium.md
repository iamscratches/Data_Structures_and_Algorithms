# ðŸ“ Valid Triangle Number - Frequency Counting and Combinatorics

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/valid-triangle-number/description/?envType=daily-question&envId=2025-09-26)

Given:
- An integer array `nums`

Find:
- The number of triplets (i, j, k) such that:
  - nums[i] + nums[j] > nums[k]
  - nums[i] + nums[k] > nums[j]  
  - nums[j] + nums[k] > nums[i]
- Essentially, triplets that can form a triangle

**Constraints:**
- 1 â‰¤ nums.length â‰¤ 1000
- 0 â‰¤ nums[i] â‰¤ 1000

**Example:**
```text
Input: nums = [2,2,3,4]
Output: 3
Explanation: Valid triplets are:
[2,3,4] (2+3>4, 2+4>3, 3+4>2)
[2,3,4] (different indices)
[2,2,3] (2+2>3, 2+3>2, 2+3>2)
```

## ðŸ§  Intuition
The solution uses:
1. **Frequency Counting**: Count occurrences of each number
2. **Prefix Sum Array**: Quickly count numbers â‰¤ given value
3. **Combinatorics**: Calculate valid triplets using combinations
4. **Case Analysis**: Handle different multiplicity cases separately

Key Insights:
- Triangle inequality: sum of any two sides > third side
- For sorted sides a â‰¤ b â‰¤ c, only need to check a + b > c
- Use frequency counts to avoid O(nÂ³) triple loop

## âš™ï¸ Approach
1. **Frequency Analysis**:
   - Count occurrences of each number
   - Ignore zeros (can't form triangles)
2. **Prefix Sum Array**:
   - `sum[i]` = count of numbers â‰¤ i
   - Enables O(1) range queries
3. **Triplet Counting**:
   - Case 1: Two equal numbers + larger number
   - Case 2: Three distinct numbers
   - Case 3: Three equal numbers
   - Case 4: One number + two equal larger numbers

## âœ… Optimized Solution
```java
class Solution {
    public int triangleNumber(int[] nums) {
        int maxVal = Arrays.stream(nums).max().getAsInt();
        int[] frequency = new int[maxVal + 1];
        int[] prefixSum = new int[maxVal + 1];
        
        // Count frequencies (ignore zeros)
        for (int num : nums) {
            if (num > 0) frequency[num]++;
        }
        
        // Build prefix sum array
        for (int i = 1; i <= maxVal; i++) {
            prefixSum[i] = prefixSum[i - 1] + frequency[i];
        }
        
        int count = 0;
        
        // Count valid triangles
        for (int a = 1; a <= maxVal; a++) {
            if (frequency[a] == 0) continue;
            
            // Case 1: Two 'a's and one larger number
            if (frequency[a] >= 2) {
                int maxThird = Math.min(maxVal, 2 * a - 1);
                int possibleThirds = prefixSum[maxThird] - prefixSum[a];
                count += possibleThirds * frequency[a] * (frequency[a] - 1) / 2;
                
                // Case 2: Three 'a's (equilateral triangle)
                if (frequency[a] >= 3) {
                    count += frequency[a] * (frequency[a] - 1) * (frequency[a] - 2) / 6;
                }
            }
            
            // Case 3: Distinct numbers a < b < c with a + b > c
            for (int b = a + 1; b <= maxVal; b++) {
                if (frequency[b] == 0) continue;
                
                int maxC = Math.min(maxVal, a + b - 1);
                int possibleCs = prefixSum[maxC] - prefixSum[b];
                count += frequency[a] * frequency[b] * possibleCs;
                
                // Case 4: One 'a' and two 'b's
                if (frequency[b] >= 2) {
                    count += frequency[a] * frequency[b] * (frequency[b] - 1) / 2;
                }
            }
        }
        
        return count;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n + MÂ²)  | n = array length, M = max value |
| **Space**       | O(M)       | Frequency and prefix arrays |

## ðŸ“Š Example Walkthrough
**Input:** nums = [2,2,3,4]

**Frequency:** [0,0,2,1,1] (indices 0-4)
**Prefix Sum:** [0,0,2,3,4]

**Processing:**
- a=2 (frequency=2):
  - Two 2's + larger: maxThird=3, possibleThirds=prefix[3]-prefix[2]=3-2=1
  - Count += 1 Ã— 2 Ã— 1 / 2 = 1
- a=2, b=3:
  - Distinct: maxC=4, possibleCs=prefix[4]-prefix[3]=4-3=1
  - Count += 2 Ã— 1 Ã— 1 = 2
  - Two b's: frequency[3]=1 â†’ skip
- a=2, b=4: possibleCs=0 (maxC=5 but limited by maxVal=4)
- a=3: no pairs with itself (frequency=1)
- a=3, b=4: maxC=6, possibleCs=0

**Total:** 1 + 2 = 3

## ðŸ’¡ Key Features
- **Mathematical Approach**: Uses combinatorics instead of brute force
- **Efficient Range Queries**: Prefix sum enables O(1) count queries
- **Case Analysis**: Handles different multiplicity scenarios
- **Optimal Complexity**: Beats O(nÂ³) brute force

## ðŸš€ When to Use
- Combinatorial counting problems
- When input range is limited
- Problems involving triangle inequality
- Frequency analysis applications

## âš ï¸ Edge Cases
- **All zeros**: Return 0
- **Single element**: No triangles possible
- **Large values**: Handled by maxVal constraint
- **Duplicate numbers**: Properly counted using combinations

## ðŸ›  Variations
1. **Sorting + Two Pointers**:
```java
// Alternative O(nÂ²) approach
```

2. **Binary Search**:
```java
// For larger value ranges
```

3. **Parallel Processing**:
```java
// Process different value ranges concurrently
```

4. **Visualization**:
```java
// Show triangle validity for different triplets
```

5. **Generalization**:
```java
// Count other polygon formations
```

## Mathematical Insight
The solution leverages:
- Triangle inequality properties
- Combinatorial mathematics (nCr formulas)
- Prefix sum techniques
- Frequency distribution analysis

## Alternative Implementation (Sorting + Two Pointers)
```java
class Solution {
    public int triangleNumber(int[] nums) {
        Arrays.sort(nums);
        int count = 0, n = nums.length;
        
        for (int i = n - 1; i >= 2; i--) {
            int left = 0, right = i - 1;
            while (left < right) {
                if (nums[left] + nums[right] > nums[i]) {
                    count += right - left;
                    right--;
                } else {
                    left++;
                }
            }
        }
        return count;
    }
}
```
Note: This alternative sorts the array and uses two pointers for an O(nÂ²) solution. The frequency counting approach is more efficient when the value range is small compared to the array size.