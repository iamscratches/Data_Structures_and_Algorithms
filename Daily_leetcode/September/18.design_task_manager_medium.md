# üìã Design Task Manager - Lazy Deletion Priority Queue Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/design-task-manager/description/?envType=daily-question&envId=2025-09-18)

Design a task manager that supports:
1. **Initialization** with list of tasks [userId, taskId, priority]
2. **Adding** new tasks
3. **Editing** task priority
4. **Removing** tasks
5. **Executing** the highest priority task (with tie-breaker: larger taskId wins)

**Rules:**
- Highest priority first (priority descending)
- Same priority: larger taskId wins (taskId descending)
- Execute returns userId of executed task
- Support efficient operations

**Constraints:**
- 1 ‚â§ tasks.length ‚â§ 10‚Åµ
- 0 ‚â§ userId, taskId, priority ‚â§ 10‚Åµ

**Example:**
```text
Input:
["TaskManager", "execTop", "add", "execTop", "edit", "execTop"]
[[[[1, 101, 5], [2, 102, 5]]], [], [3, 103, 6], [], [102, 6], []]

Output: [null, 2, null, 3, null, 2]
```

## üß† Intuition
The solution uses:
1. **Lazy Deletion**: Mark tasks as invalid instead of removing from PQ
2. **Priority Queue**: Max-heap for efficient top task retrieval
3. **HashMap**: O(1) task lookup by taskId
4. **Validation Check**: Skip invalid tasks during execution

Key Insights:
- Direct PQ removal is inefficient (O(n))
- Lazy deletion with validation is O(1) for removal/edit
- execTop may need to skip multiple invalid tasks
- HashMap maintains current task state

## ‚öôÔ∏è Approach
1. **Data Structures**:
   - `HashMap<Integer, Tasks>`: taskId ‚Üí current Task object
   - `PriorityQueue<Tasks>`: max-heap by priority then taskId
2. **Operations**:
   - **add**: Create task, store in map, add to PQ
   - **edit**: Mark old task invalid, create new task, update map
   - **rmv**: Mark task invalid, remove from map
   - **execTop**: Poll PQ until valid task found, remove from map

## ‚úÖ Optimized Solution
```java
class TaskManager {
    private Map<Integer, Task> taskMap; // taskId -> current Task
    private PriorityQueue<Task> maxHeap; // Max-heap by priority then taskId

    public TaskManager(List<List<Integer>> tasks) {
        taskMap = new HashMap<>();
        maxHeap = new PriorityQueue<>((a, b) -> {
            if (a.priority != b.priority) {
                return Integer.compare(b.priority, a.priority); // Higher priority first
            }
            return Integer.compare(b.taskId, a.taskId); // Larger taskId first
        });
        
        for (List<Integer> task : tasks) {
            addTask(task.get(0), task.get(1), task.get(2));
        }
    }
    
    public void add(int userId, int taskId, int priority) {
        addTask(userId, taskId, priority);
    }
    
    private void addTask(int userId, int taskId, int priority) {
        Task task = new Task(userId, taskId, priority);
        taskMap.put(taskId, task);
        maxHeap.offer(task);
    }
    
    public void edit(int taskId, int newPriority) {
        // Mark old task invalid and create new one
        Task oldTask = taskMap.get(taskId);
        if (oldTask != null) {
            oldTask.invalidate();
        }
        addTask(oldTask.userId, taskId, newPriority);
    }
    
    public void rmv(int taskId) {
        Task task = taskMap.remove(taskId);
        if (task != null) {
            task.invalidate();
        }
    }
    
    public int execTop() {
        while (!maxHeap.isEmpty()) {
            Task task = maxHeap.poll();
            if (task.isValid()) {
                taskMap.remove(task.taskId);
                return task.userId;
            }
        }
        return -1;
    }
}

class Task {
    int userId;
    int taskId;
    int priority;
    boolean valid;
    
    public Task(int userId, int taskId, int priority) {
        this.userId = userId;
        this.taskId = taskId;
        this.priority = priority;
        this.valid = true;
    }
    
    public void invalidate() {
        this.valid = false;
    }
    
    public boolean isValid() {
        return valid;
    }
}
```

## ‚è≥ Complexity Analysis
| Operation       | Complexity | Description |
|-----------------|------------|-------------|
| **Constructor** | O(n log n) | n heap insertions |
| **add**         | O(log n)   | Heap insertion |
| **edit**        | O(log n)   | Invalidate + new insertion |
| **rmv**         | O(1)       | Invalidation + map removal |
| **execTop**     | O(k log n) | k invalid tasks skipped |

## üìä Example Walkthrough
**Initialization:** tasks = [[1,101,5], [2,102,5]]
- taskMap: {101: Task(1,101,5), 102: Task(2,102,5)}
- maxHeap: [Task(2,102,5), Task(1,101,5)] (same priority, larger taskId first)

**execTop():**
- Poll Task(2,102,5) ‚Üí valid ‚Üí return userId 2

**add(3,103,6):**
- taskMap: {101:..., 102:..., 103: Task(3,103,6)}
- maxHeap: [Task(3,103,6), Task(2,102,5), Task(1,101,5)]

**edit(102,6):**
- Invalidate Task(2,102,5)
- Add Task(2,102,6)
- maxHeap: [Task(3,103,6), Task(2,102,6), Task(2,102,5invalid), Task(1,101,5)]

**execTop():**
- Poll Task(3,103,6) ‚Üí valid ‚Üí return userId 3

## üí° Key Features
- **Lazy Deletion**: Efficient removal without heap restructuring
- **Heap Management**: Automatic ordering by priority and taskId
- **State Tracking**: Valid flag prevents stale task execution
- **Memory Efficiency**: Only one additional boolean per task

## üöÄ When to Use
- Priority-based task scheduling
- Systems with frequent updates and removals
- When lazy deletion is acceptable
- Real-time task management systems

## ‚ö†Ô∏è Edge Cases
- **Empty manager**: execTop returns -1
- **Duplicate taskIds**: Handled by invalidation
- **Large priorities**: Integer comparison handles
- **Concurrent access**: Not thread-safe in this implementation

## üõ† Variations
1. **Eager Deletion**:
```java
// Use TreeSet with custom comparator for O(log n) removal
```

2. **Timestamp Tie-breaker**:
```java
// Add timestamp for three-level ordering
```

3. **Persistent Storage**:
```java
// Database integration for large systems
```

4. **Visualization**:
```java
// Show task priority distributions
```

5. **Generalization**:
```java
// Support multiple priority criteria
```

## System Design Insight
The solution leverages:
- Lazy deletion pattern for efficient updates
- Priority queue for ordered access
- HashMap for direct task access
- Validation flags for state management

## Alternative Implementation (TreeSet)
```java
// Would support O(log n) removals but more complex
// Requires maintaining both TreeSet and HashMap
```
Note: The lazy deletion approach is more efficient for this problem since removals and edits are common, and the heap doesn't need to be restructured immediately. The TreeSet alternative would provide faster worst-case execTop but more complex implementation.