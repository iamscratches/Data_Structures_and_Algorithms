# 🔄 Fraction to Recurring Decimal - Long Division with Cycle Detection

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/fraction-to-recurring-decimal/description/?envType=daily-question&envId=2025-09-24)

Given:
- Two integers `numerator` and `denominator`

Find:
- The string representation of the fraction in decimal form
- If fractional part is repeating, enclose repeating part in parentheses

**Constraints:**
- -2³¹ ≤ numerator, denominator ≤ 2³¹ - 1
- denominator ≠ 0

**Example:**
```text
Input: numerator = 4, denominator = 333
Output: "0.(012)"
Explanation: 4/333 = 0.012012012... → "0.(012)"

Input: numerator = 1, denominator = 2
Output: "0.5"

Input: numerator = 2, denominator = 1
Output: "2"
```

## 🧠 Intuition
The solution uses:
1. **Long Division Simulation**: Manually perform division digit by digit
2. **Remainder Tracking**: Use HashMap to detect repeating remainders
3. **Cycle Detection**: When remainder repeats, fractional part repeats
4. **Sign Handling**: Determine sign before processing absolute values

Key Insights:
- Repeating decimals occur when remainder repeats
- HashMap stores remainder → position mapping
- Insert parentheses when repeating pattern detected
- Handle integer overflow with long conversion

## ⚙️ Approach
1. **Handle Edge Cases**:
   - Zero numerator → return "0"
   - Determine sign and work with absolute values
2. **Integer Part**:
   - Append integer division result
3. **Fractional Part**:
   - If remainder ≠ 0, append decimal point
   - Track remainders in HashMap
   - Multiply remainder by 10 for next digit
   - Detect cycles and insert parentheses

## ✅ Optimized Solution
```java
class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        if (numerator == 0) return "0";
        
        StringBuilder result = new StringBuilder();
        
        // Handle sign
        if ((numerator < 0) ^ (denominator < 0)) {
            result.append("-");
        }
        
        // Convert to long to avoid overflow
        long dividend = Math.abs((long) numerator);
        long divisor = Math.abs((long) denominator);
        
        // Integer part
        result.append(dividend / divisor);
        long remainder = dividend % divisor;
        
        // No fractional part
        if (remainder == 0) return result.toString();
        
        // Fractional part
        result.append(".");
        Map<Long, Integer> remainderPositions = new HashMap<>();
        
        while (remainder != 0) {
            // Check for repeating remainder
            if (remainderPositions.containsKey(remainder)) {
                int insertPosition = remainderPositions.get(remainder);
                result.insert(insertPosition, "(");
                result.append(")");
                break;
            }
            
            // Store current remainder position
            remainderPositions.put(remainder, result.length());
            
            // Get next digit
            remainder *= 10;
            result.append(remainder / divisor);
            remainder %= divisor;
        }
        
        return result.toString();
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(d)       | d = length of decimal part |
| **Space**       | O(d)       | HashMap for remainder tracking |

## 📊 Example Walkthrough
**Input:** numerator = 4, denominator = 333

**Execution:**
1. Sign: both positive → no "-"
2. Integer: 4/333 = 0 → "0"
3. Remainder: 4 → append "." → "0."
4. Remainder tracking:
   - Remainder 4 → position 2
   - 4×10=40 → 40/333=0 → "0.0"
   - Remainder 40 → position 3
   - 40×10=400 → 400/333=1 → "0.01"
   - Remainder 67 → position 4
   - 67×10=670 → 670/333=2 → "0.012"
   - Remainder 4 → found at position 2
5. Insert "(" at position 2 → "0.(012)"
6. Append ")" → "0.(012)"

## 💡 Key Features
- **Overflow Prevention**: Uses long for intermediate calculations
- **Cycle Detection**: HashMap efficiently finds repeating patterns
- **String Building**: Efficient StringBuilder operations
- **Sign Handling**: XOR for concise sign determination

## 🚀 When to Use
- Decimal conversion problems
- When cycle detection is needed
- Problems involving remainder mathematics
- Educational examples of long division

## ⚠️ Edge Cases
- **Zero numerator**: Return "0"
- **Negative numbers**: Proper sign handling
- **No fractional part**: Return integer only
- **Integer overflow**: Use long for intermediate values
- **Repeating zero**: e.g., 1/1000 = "0.001"

## 🛠 Variations
1. **Different Bases**:
```java
// Convert to other bases besides decimal
```

2. **Precision Limit**:
```java
// Limit decimal places for irrational numbers
```

3. **BigDecimal**:
```java
// Use BigDecimal for arbitrary precision
```

4. **Visualization**:
```java
// Show long division process step by step
```

5. **Generalization**:
```java
// Support for complex fractions
```

## Mathematical Insight
The solution leverages:
- Properties of rational numbers
- The fact that repeating decimals occur when remainder repeats
- Long division algorithm
- Hash-based cycle detection

## Alternative Implementation (Without StringBuilder Insert)
```java
class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        if (numerator == 0) return "0";
        
        StringBuilder result = new StringBuilder();
        if ((numerator < 0) ^ (denominator < 0)) result.append("-");
        
        long num = Math.abs((long) numerator);
        long den = Math.abs((long) denominator);
        
        result.append(num / den);
        long rem = num % den;
        if (rem == 0) return result.toString();
        
        result.append(".");
        Map<Long, Integer> map = new HashMap<>();
        
        while (rem != 0) {
            if (map.containsKey(rem)) {
                int index = map.get(rem);
                return result.substring(0, index) + "(" + result.substring(index) + ")";
            }
            map.put(rem, result.length());
            rem *= 10;
            result.append(rem / den);
            rem %= den;
        }
        return result.toString();
    }
}
```
Note: This version uses substring instead of insert, which may be more efficient for large repeating sequences. Both approaches have similar time complexity.