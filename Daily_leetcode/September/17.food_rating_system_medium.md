# üçΩÔ∏è Design a Food Rating System - Multi-Map with TreeSet Sorting

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/design-a-food-rating-system/description/?envType=daily-question&envId=2025-09-17)

Design a food rating system that supports:
1. **Initialization** with foods, their cuisines, and ratings
2. **Changing** the rating of any food
3. **Finding** the highest-rated food for a given cuisine

**Rules:**
- If multiple foods have same rating, return lexicographically smallest name
- Support efficient operations

**Constraints:**
- 1 ‚â§ n ‚â§ 2 √ó 10‚Å¥
- 1 ‚â§ foods.length, cuisines.length, ratings.length ‚â§ 2 √ó 10‚Å¥
- All strings consist of English letters

**Example:**
```text
Input:
["FoodRatings", "highestRated", "highestRated", "changeRating", "highestRated", "changeRating", "highestRated"]
[[["kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi"], ["korean", "japanese", "japanese", "greek", "japanese", "korean"], [9, 12, 8, 15, 14, 7]], ["korean"], ["japanese"], ["sushi", 16], ["japanese"], ["ramen", 16], ["japanese"]]

Output: [null, "kimchi", "ramen", null, "sushi", null, "ramen"]
```

## üß† Intuition
The solution uses:
1. **Food Mapping**: HashMap for O(1) food lookup
2. **Cuisine Grouping**: TreeSet per cuisine for sorted foods
3. **Custom Sorting**: Foods sorted by rating (descending) then name (ascending)
4. **Efficient Updates**: Remove and reinsert for rating changes

Key Insights:
- TreeSet provides automatic sorting and O(log n) operations
- Separate maps for food lookup and cuisine grouping
- Custom comparator handles rating and name priorities

## ‚öôÔ∏è Approach
1. **Initialization**:
   - Create `foodToFood` map: food name ‚Üí Food object
   - Create `cuisineToFoods` map: cuisine ‚Üí TreeSet of Foods
   - Use custom comparator: rating descending, then name ascending
2. **changeRating**:
   - Find food in `foodToFood`
   - Remove from its cuisine TreeSet
   - Update rating
   - Reinsert into TreeSet
3. **highestRated**:
   - Return first element of cuisine's TreeSet

## ‚úÖ Optimized Solution
```java
class Food {
    String name;
    String cuisine;
    int rating;
    
    Food(String name, String cuisine, int rating) {
        this.name = name;
        this.cuisine = cuisine;
        this.rating = rating;
    }
}

class FoodRatings {
    private Map<String, Food> foodMap; // food name -> Food object
    private Map<String, TreeSet<Food>> cuisineMap; // cuisine -> sorted foods

    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {
        foodMap = new HashMap<>();
        cuisineMap = new HashMap<>();
        
        for (int i = 0; i < foods.length; i++) {
            Food food = new Food(foods[i], cuisines[i], ratings[i]);
            foodMap.put(foods[i], food);
            
            cuisineMap.computeIfAbsent(cuisines[i], k -> 
                new TreeSet<>((a, b) -> {
                    if (a.rating != b.rating) {
                        return Integer.compare(b.rating, a.rating); // Descending rating
                    }
                    return a.name.compareTo(b.name); // Ascending name
                })
            ).add(food);
        }
    }
    
    public void changeRating(String foodName, int newRating) {
        Food food = foodMap.get(foodName);
        TreeSet<Food> cuisineSet = cuisineMap.get(food.cuisine);
        
        // Remove and reinsert to maintain sorted order
        cuisineSet.remove(food);
        food.rating = newRating;
        cuisineSet.add(food);
    }
    
    public String highestRated(String cuisine) {
        return cuisineMap.get(cuisine).first().name;
    }
}
```

## ‚è≥ Complexity Analysis
| Operation       | Complexity | Description |
|-----------------|------------|-------------|
| **Constructor** | O(n log n) | n insertions into TreeSets |
| **changeRating**| O(log n)   | TreeSet remove and insert |
| **highestRated**| O(1)       | TreeSet first element |

## üìä Example Walkthrough
**Initialization:**
- foods = ["kimchi"(9), "miso"(12), "sushi"(8), ...]
- cuisineMap: 
  - "korean": TreeSet([kimchi(9), bulgogi(7)])
  - "japanese": TreeSet([miso(12), ramen(14), sushi(8)])

**highestRated("korean"):**
- Returns "kimchi" (highest rating)

**changeRating("sushi", 16):**
- Remove sushi(8) from japanese TreeSet
- Update rating to 16
- Reinsert: japanese TreeSet now [sushi(16), ramen(14), miso(12)]

**highestRated("japanese"):**
- Returns "sushi" (rating 16)

## üí° Key Features
- **Efficient Design**: Optimal time complexity for all operations
- **Sorted Collections**: TreeSet maintains automatic ordering
- **Easy Updates**: Remove/reinsert pattern for rating changes
- **Comparator Design**: Handles rating and name priorities correctly

## üöÄ When to Use
- Rating system designs
- When frequent updates and queries are needed
- Problems requiring sorted groupings
- Real-time ranking systems

## ‚ö†Ô∏è Edge Cases
- **Empty cuisine**: Shouldn't occur per constraints
- **Same rating foods**: Lexicographical order tie-breaker
- **Duplicate foods**: Not allowed per problem
- **Large inputs**: Handles constraints efficiently

## üõ† Variations
1. **Priority Queue**:
```java
// Use max-heap with custom comparator
```

2. **Lazy Updates**:
```java
// Mark stale entries instead of immediate removal
```

3. **Database Backend**:
```java
// For persistent storage
```

4. **Visualization**:
```java
// Show real-time rating changes
```

5. **Generalization**:
```java
// Extend to multiple rating criteria
```

## System Design Insight
The solution leverages:
- HashMap for O(1) lookups
- TreeSet for sorted collections
- Comparator design pattern
- Efficient update strategies

## Alternative Implementation (PriorityQueue)
```java
// Would require more complex update handling
// Not as efficient for frequent updates
```
Note: TreeSet is ideal here because it supports efficient removal and insertion. PriorityQueue doesn't support efficient removal of arbitrary elements, making it less suitable for this use case.