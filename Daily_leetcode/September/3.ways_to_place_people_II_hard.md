# 👥 Number of Ways to Place People II - Geometric Sorting and Efficient Scanning

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/find-the-number-of-ways-to-place-people-ii/description/?envType=daily-question&envId=2025-09-03)

Given:
- An array `points` where `points[i] = [x_i, y_i]` represents coordinates of trees

Find:
- The number of ways to choose two trees such that:
  1. One person sits at tree A, another at tree B
  2. The rectangle formed by A and B as opposite corners contains no other trees
  3. The person at A must have a clear view of the person at B (no trees blocking)

**Constraints:**
- 2 ≤ points.length ≤ 1000
- points[i].length == 2
- 0 ≤ x_i, y_i ≤ 10⁹

**Example:**
```text
Input: points = [[1,1],[2,2],[3,3]]
Output: 1
Explanation: 
Only valid pair is [1,1] and [3,3] since the rectangle between them contains [2,2]
```

## 🧠 Intuition
The solution uses:
1. **Reverse Sorting**: Orders points by x-coordinate descending (and y ascending for same x)
2. **Efficient Pair Validation**: For each point, scans subsequent points and maintains minimum y
3. **Obstacle Avoidance**: Uses geometric properties to quickly identify valid pairs
4. **Early Termination**: Stops scanning when certain conditions are met

Key Insights:
- Sort by x descending allows efficient scanning from right to left
- For a pair (i,j) to be valid, no point should lie between them in both dimensions
- Maintaining minimum y during scanning helps quickly identify blocking points

## ⚙️ Approach
1. **Sort Points**:
   - Primary: x-coordinate descending
   - Secondary: y-coordinate ascending (for same x)
2. **Check Pairs**:
   - For each point i, scan points j > i
   - Track minimum y value encountered
   - If points[j] has y ≥ current point i's y and greater than current min y, it's valid
3. **Count Valid Pairs**: Increment count for each valid pair found

## ✅ Optimized Solution
```java
import java.util.Arrays;

class Solution {
    public int numberOfPairs(int[][] points) {
        // Sort points by x descending, and for same x by y ascending
        Arrays.sort(points, (p, q) -> {
            if (p[0] != q[0]) return q[0] - p[0]; // Descending x
            return p[1] - q[1]; // Ascending y for same x
        });
        
        int n = points.length;
        int count = 0;
        
        for (int i = 0; i < n; i++) {
            int currentY = points[i][1];
            int minY = Integer.MAX_VALUE;
            
            for (int j = i + 1; j < n; j++) {
                int otherY = points[j][1];
                
                // Check if points[j] is above current point and not blocked
                if (otherY >= currentY && otherY < minY) {
                    count++;
                    minY = otherY;
                    // If same y, no further points can be valid in this direction
                    if (otherY == currentY) break;
                }
            }
        }
        
        return count;
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n²)      | Nested loops over points |
| **Space**       | O(1)       | No extra space needed |

## 📊 Example Walkthrough
**Input:** points = [[3,1],[2,2],[1,3]]

**After sorting (x descending):** [[3,1],[2,2],[1,3]]

**Execution:**
1. i=0 (3,1): 
   - j=1 (2,2): 2≥1 and 2<∞ → valid, count=1, minY=2
   - j=2 (1,3): 3≥1 but 3>2 → invalid (blocked by (2,2))
2. i=1 (2,2):
   - j=2 (1,3): 3≥2 and 3<∞ → valid, count=2, minY=3
3. i=2 (1,3): no j → done
4. Final count: 2

## 💡 Key Features
- **Efficient Sorting**: Descending x-order enables optimal scanning
- **Smart Tracking**: Maintains minimum y to detect blocking points
- **Early Termination**: Breaks early when same y encountered
- **Geometric Insight**: Leverages spatial relationships between points

## 🚀 When to Use
- Geometric pair selection problems
- When O(n²) solution is acceptable (n ≤ 1000)
- Problems requiring spatial reasoning
- Computational geometry applications

## ⚠️ Edge Cases
- **Duplicate Points**: Handled by sorting
- **Collinear Points**: Properly detected as invalid if obstacles exist
- **Large Coordinates**: Handles up to 10⁹ values
- **Minimum Input**: 2 points always form 1 pair if valid

## 🛠 Variations
1. **Sweep Line Algorithm**:
```java
// Use plane sweep to reduce time complexity
```

2. **Spatial Indexing**:
```java
// Use data structures for faster range queries
```

3. **Parallel Processing**:
```java
// Process different point ranges concurrently
```

4. **Visualization**:
```java
// Plot points and valid pairs
```

5. **Generalization**:
```java
// Extend to 3D or higher dimensions
```

## Mathematical Insight
The solution leverages:
- Properties of coordinate ordering
- Monotonicity in geometric scanning
- Inclusion/exclusion principles
- Efficient pair counting techniques

## Alternative Implementation (Different Sorting)
```java
class Solution {
    public int numberOfPairs(int[][] points) {
        // Sort by x ascending, then y descending
        Arrays.sort(points, (a, b) -> {
            if (a[0] != b[0]) return a[0] - b[0];
            return b[1] - a[1];
        });
        
        int n = points.length;
        int count = 0;
        
        for (int i = 0; i < n; i++) {
            int maxY = Integer.MIN_VALUE;
            for (int j = i + 1; j < n; j++) {
                if (points[j][1] <= points[i][1] && points[j][1] > maxY) {
                    count++;
                    maxY = points[j][1];
                    if (points[j][1] == points[i][1]) break;
                }
            }
        }
        
        return count;
    }
}
```
Note: This alternative sorts by x ascending and y descending, then scans from left to right while tracking maximum y. Both approaches have the same time complexity but different scanning directions. The original solution's descending x-order may be more intuitive for this problem.