# üó£Ô∏è Minimum Number of People to Teach - Language Compatibility Analysis

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/minimum-number-of-people-to-teach/description/?envType=daily-question&envId=2025-09-10)

Given:
- `n`: number of languages (labeled 1 to n)
- `languages`: array where `languages[i]` contains languages known by user i
- `friendships`: array of pairs [u, v] representing friendships

Find:
- The minimum number of users you need to teach one language to so that every friendship has at least one common language

**Constraints:**
- 2 ‚â§ n ‚â§ 500
- 1 ‚â§ languages.length ‚â§ 500
- 1 ‚â§ friendships.length ‚â§ 500

**Example:**
```text
Input: n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]]
Output: 1
Explanation:
User 1 knows [1], user 2 knows [2], user 3 knows [1,2]
Friendship (1,2): no common language ‚Üí need to teach
Teach language 1 to user 2 or language 2 to user 1
```

## üß† Intuition
The solution uses:
1. **Identify Problematic Friendships**: Find pairs without common languages
2. **User Collection**: Gather all users involved in problematic friendships
3. **Language Trial**: For each language, count how many users need to learn it
4. **Optimal Selection**: Choose the language that requires teaching fewest users

Key Insights:
- Only users in problematic friendships need to be taught
- Teaching one common language to all affected users is sufficient
- The optimal language is the one already known by most users in the group

## ‚öôÔ∏è Approach
1. **Find Users Needing Help**:
   - For each friendship, check if users share a common language
   - If not, add both users to a set
2. **Determine Optimal Language**:
   - For each language (1 to n), count how many users in the set don't know it
   - The minimum count across all languages is the answer

## ‚úÖ Optimized Solution
```java
import java.util.*;

class Solution {
    public int minimumTeachings(int n, int[][] languages, int[][] friendships) {
        Set<Integer> needHelp = new HashSet<>();
        
        // Check each friendship for language compatibility
        for (int[] friendship : friendships) {
            int user1 = friendship[0] - 1; // Convert to 0-indexed
            int user2 = friendship[1] - 1;
            
            if (!shareCommonLanguage(languages[user1], languages[user2])) {
                needHelp.add(user1);
                needHelp.add(user2);
            }
        }
        
        // If no users need help, return 0
        if (needHelp.isEmpty()) {
            return 0;
        }
        
        // Find the language that requires teaching the fewest users
        int minTeachings = Integer.MAX_VALUE;
        for (int language = 1; language <= n; language++) {
            int count = 0;
            for (int user : needHelp) {
                if (!knowsLanguage(languages[user], language)) {
                    count++;
                }
            }
            minTeachings = Math.min(minTeachings, count);
        }
        
        return minTeachings;
    }
    
    private boolean shareCommonLanguage(int[] lang1, int[] lang2) {
        // Check if two users share any common language
        for (int l1 : lang1) {
            for (int l2 : lang2) {
                if (l1 == l2) {
                    return true;
                }
            }
        }
        return false;
    }
    
    private boolean knowsLanguage(int[] userLanguages, int targetLanguage) {
        // Check if user knows a specific language
        for (int lang : userLanguages) {
            if (lang == targetLanguage) {
                return true;
            }
        }
        return false;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(f √ó l¬≤ + n √ó u) | f friendships, l languages per user, n languages, u users |
| **Space**       | O(u)       | Storage for users needing help |

## üìä Example Walkthrough
**Input:** n=2, languages=[[1],[2],[1,2]], friendships=[[1,2],[1,3],[2,3]]

**Execution:**
1. Check friendships:
   - (1,2): [1] vs [2] ‚Üí no common ‚Üí add users 0,1
   - (1,3): [1] vs [1,2] ‚Üí common language 1 ‚Üí skip
   - (2,3): [2] vs [1,2] ‚Üí common language 2 ‚Üí skip
2. needHelp = {0,1}
3. Check languages:
   - Language 1: user0 knows it, user1 doesn't ‚Üí teach 1 user
   - Language 2: user0 doesn't know, user1 knows ‚Üí teach 1 user
4. minTeachings = 1

## üí° Key Features
- **Efficient Compatibility Check**: Early termination when common language found
- **Set Operations**: Avoids duplicate users efficiently
- **Optimal Language Selection**: Tries all possible languages
- **Clear Logic**: Easy to understand and verify

## üöÄ When to Use
- Social network analysis problems
- When language/skill compatibility is important
- Problems requiring minimal intervention
- Graph problems with node attributes

## ‚ö†Ô∏è Edge Cases
- **All friendships compatible**: Return 0
- **Single language**: Only one choice for teaching
- **All users need help**: Large teaching set
- **Duplicate languages**: Users may know multiple languages

## üõ† Variations
1. **Precompute Language Sets**:
```java
// Use HashSet for faster language lookups
```

2. **Bit Mask Representation**:
```java
// Represent languages as bit masks for faster operations
```

3. **Graph Analysis**:
```java
// Use graph theory to find connected components
```

4. **Parallel Processing**:
```java
// Check friendships or languages concurrently
```

5. **Visualization**:
```java
// Plot user-language relationships
```

## Mathematical Insight
The solution leverages:
- Set theory for user selection
- Combinatorial optimization for language choice
- Brute-force with early termination
- Worst-case acceptable due to constraints

## Alternative Implementation (Optimized Language Check)
```java
class Solution {
    public int minimumTeachings(int n, int[][] languages, int[][] friendships) {
        // Convert each user's languages to a set for faster lookup
        Set<Integer>[] userLangSets = new Set[languages.length];
        for (int i = 0; i < languages.length; i++) {
            userLangSets[i] = new HashSet<>();
            for (int lang : languages[i]) {
                userLangSets[i].add(lang);
            }
        }
        
        Set<Integer> needHelp = new HashSet<>();
        for (int[] f : friendships) {
            int u = f[0]-1, v = f[1]-1;
            if (!hasCommonLanguage(userLangSets[u], userLangSets[v])) {
                needHelp.add(u);
                needHelp.add(v);
            }
        }
        
        int minTeach = Integer.MAX_VALUE;
        for (int lang = 1; lang <= n; lang++) {
            int count = 0;
            for (int user : needHelp) {
                if (!userLangSets[user].contains(lang)) {
                    count++;
                }
            }
            minTeach = Math.min(minTeach, count);
        }
        return minTeach;
    }
    
    private boolean hasCommonLanguage(Set<Integer> set1, Set<Integer> set2) {
        for (int lang : set1) {
            if (set2.contains(lang)) return true;
        }
        return false;
    }
}
```
Note: This version uses HashSets for faster language containment checks, improving performance for users with many languages. The original solution is more memory-efficient for small language arrays.