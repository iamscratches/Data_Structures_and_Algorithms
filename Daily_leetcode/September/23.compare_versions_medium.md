# ğŸ”¢ Compare Version Numbers - String Parsing & Comparison

## ğŸ“œ Problem Statement

**Link:** [LeetCode Problem](https://leetcode.com/problems/compare-version-numbers/description/?envType=daily-question&envId=2025-09-23)

Given:

* Two version numbers `version1` and `version2` represented as strings.

Find:

* Return `1` if `version1 > version2`
* Return `-1` if `version1 < version2`
* Return `0` if they are equal

**Notes:**

* Versions consist of **revision numbers** separated by `.`
* Each revision number may contain leading zeros
* If a version has fewer revisions, treat missing ones as `0`

---

## ğŸ” Example

```text
Input: version1 = "1.01", version2 = "1.001"
Output: 0
Explanation: Both normalize to [1, 1]

Input: version1 = "1.0", version2 = "1.0.0"
Output: 0
Explanation: Trailing zero revisions are ignored

Input: version1 = "0.1", version2 = "1.1"
Output: -1
Explanation: 0 < 1
```

---

## ğŸ§  Intuition

The problem reduces to **comparing sequences of integers** parsed from strings separated by dots.
Steps:

1. Traverse each version string in parallel.
2. Extract integer chunks (revision numbers) separated by `.`.
3. Compare corresponding chunks.

   * If unequal â†’ return result immediately.
   * If equal â†’ move to next chunk.
4. Handle trailing revisions (treat as 0).

Key insight: Leading zeros donâ€™t matter, because we parse integers, not strings.

---

## âš™ï¸ Approach

1. Use **two pointers (`i1`, `i2`)** to traverse both version strings.
2. At each step:

   * Parse integer from current segment of `version1`
   * Parse integer from current segment of `version2`
3. Compare parsed integers:

   * Return `1` if `v1 > v2`
   * Return `-1` if `v1 < v2`
4. If both strings are processed with no differences â†’ return `0`.

---

## âœ… Optimized Solution

```java
class Solution {
    public int compareVersion(String version1, String version2) {
        int i1 = 0, i2 = 0;
        int n1 = version1.length(), n2 = version2.length();

        while (i1 < n1 || i2 < n2) {
            int v1 = 0, v2 = 0;

            // Parse integer from version1
            while (i1 < n1 && version1.charAt(i1) != '.') {
                v1 = v1 * 10 + (version1.charAt(i1) - '0');
                i1++;
            }

            // Parse integer from version2
            while (i2 < n2 && version2.charAt(i2) != '.') {
                v2 = v2 * 10 + (version2.charAt(i2) - '0');
                i2++;
            }

            // Compare revisions
            if (v1 < v2) return -1;
            if (v1 > v2) return 1;

            // Skip the '.' delimiter
            i1++;
            i2++;
        }

        return 0;
    }
}
```

---

## â³ Complexity Analysis

| Metric    | Complexity | Description                |
| --------- | ---------- | -------------------------- |
| **Time**  | O(n + m)   | Traverse both strings once |
| **Space** | O(1)       | Constant extra space       |

---

## ğŸ“Š Example Walkthrough

**Input:** version1 = `"1.0.1"`, version2 = `"1"`

* First chunk: `1` vs `1` â†’ equal
* Second chunk: `0` vs (no chunk â†’ 0) â†’ equal
* Third chunk: `1` vs (no chunk â†’ 0) â†’ `1 > 0` â†’ return `1`

**Output:** `1`

---

## ğŸ’¡ Key Features

* Handles **leading zeros** naturally by parsing integers
* Treats **missing revisions as zero**
* Works in **linear time** with constant space
* Simple parsing logic using two pointers

---

## âš ï¸ Edge Cases

* `"1.01"` vs `"1.001"` â†’ equal
* `"1.0"` vs `"1.0.0"` â†’ equal
* `"0.1"` vs `"1.1"` â†’ `-1`
* `"1.2"` vs `"1.10"` â†’ `-1` (since 2 < 10)
* `"0001"` vs `"1"` â†’ equal

---

## ğŸ›  Variations

1. **Split + Parse Approach**

```java
String[] v1 = version1.split("\\.");
String[] v2 = version2.split("\\.");
```

* Compare arrays element by element
* Simpler to implement but adds O(n) extra space

2. **BigInteger Handling**

* If revision numbers could be huge â†’ use `BigInteger`
* Not needed here since revisions fit in `int`

---

## ğŸ“ Mathematical Insight

This problem is equivalent to comparing two **integer vectors** with lexicographic ordering, extended with infinite trailing zeros.

---
