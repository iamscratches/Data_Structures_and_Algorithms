# 🔢 Compare Version Numbers - String Parsing & Comparison

## 📜 Problem Statement

**Link:** [LeetCode Problem](https://leetcode.com/problems/compare-version-numbers/description/?envType=daily-question&envId=2025-09-23)

Given:

* Two version numbers `version1` and `version2` represented as strings.

Find:

* Return `1` if `version1 > version2`
* Return `-1` if `version1 < version2`
* Return `0` if they are equal

**Notes:**

* Versions consist of **revision numbers** separated by `.`
* Each revision number may contain leading zeros
* If a version has fewer revisions, treat missing ones as `0`

---

## 🔎 Example

```text
Input: version1 = "1.01", version2 = "1.001"
Output: 0
Explanation: Both normalize to [1, 1]

Input: version1 = "1.0", version2 = "1.0.0"
Output: 0
Explanation: Trailing zero revisions are ignored

Input: version1 = "0.1", version2 = "1.1"
Output: -1
Explanation: 0 < 1
```

---

## 🧠 Intuition

The problem reduces to **comparing sequences of integers** parsed from strings separated by dots.
Steps:

1. Traverse each version string in parallel.
2. Extract integer chunks (revision numbers) separated by `.`.
3. Compare corresponding chunks.

   * If unequal → return result immediately.
   * If equal → move to next chunk.
4. Handle trailing revisions (treat as 0).

Key insight: Leading zeros don’t matter, because we parse integers, not strings.

---

## ⚙️ Approach

1. Use **two pointers (`i1`, `i2`)** to traverse both version strings.
2. At each step:

   * Parse integer from current segment of `version1`
   * Parse integer from current segment of `version2`
3. Compare parsed integers:

   * Return `1` if `v1 > v2`
   * Return `-1` if `v1 < v2`
4. If both strings are processed with no differences → return `0`.

---

## ✅ Optimized Solution

```java
class Solution {
    public int compareVersion(String version1, String version2) {
        int i1 = 0, i2 = 0;
        int n1 = version1.length(), n2 = version2.length();

        while (i1 < n1 || i2 < n2) {
            int v1 = 0, v2 = 0;

            // Parse integer from version1
            while (i1 < n1 && version1.charAt(i1) != '.') {
                v1 = v1 * 10 + (version1.charAt(i1) - '0');
                i1++;
            }

            // Parse integer from version2
            while (i2 < n2 && version2.charAt(i2) != '.') {
                v2 = v2 * 10 + (version2.charAt(i2) - '0');
                i2++;
            }

            // Compare revisions
            if (v1 < v2) return -1;
            if (v1 > v2) return 1;

            // Skip the '.' delimiter
            i1++;
            i2++;
        }

        return 0;
    }
}
```

---

## ⏳ Complexity Analysis

| Metric    | Complexity | Description                |
| --------- | ---------- | -------------------------- |
| **Time**  | O(n + m)   | Traverse both strings once |
| **Space** | O(1)       | Constant extra space       |

---

## 📊 Example Walkthrough

**Input:** version1 = `"1.0.1"`, version2 = `"1"`

* First chunk: `1` vs `1` → equal
* Second chunk: `0` vs (no chunk → 0) → equal
* Third chunk: `1` vs (no chunk → 0) → `1 > 0` → return `1`

**Output:** `1`

---

## 💡 Key Features

* Handles **leading zeros** naturally by parsing integers
* Treats **missing revisions as zero**
* Works in **linear time** with constant space
* Simple parsing logic using two pointers

---

## ⚠️ Edge Cases

* `"1.01"` vs `"1.001"` → equal
* `"1.0"` vs `"1.0.0"` → equal
* `"0.1"` vs `"1.1"` → `-1`
* `"1.2"` vs `"1.10"` → `-1` (since 2 < 10)
* `"0001"` vs `"1"` → equal

---

## 🛠 Variations

1. **Split + Parse Approach**

```java
String[] v1 = version1.split("\\.");
String[] v2 = version2.split("\\.");
```

* Compare arrays element by element
* Simpler to implement but adds O(n) extra space

2. **BigInteger Handling**

* If revision numbers could be huge → use `BigInteger`
* Not needed here since revisions fit in `int`

---

## 📐 Mathematical Insight

This problem is equivalent to comparing two **integer vectors** with lexicographic ordering, extended with infinite trailing zeros.

---
