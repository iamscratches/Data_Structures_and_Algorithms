# 🔢 Convert Integer to Sum of Two No-Zero Integers - Iterative Search Approach

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/convert-integer-to-the-sum-of-two-no-zero-integers/description/?envType=daily-question&envId=2025-09-08)

Given:
- An integer `n`

Find:
- Return two integers `[a, b]` such that:
  1. `a + b = n`
  2. Neither `a` nor `b` contains the digit '0' in their decimal representation
  3. Both are positive integers

**Constraints:**
- 2 ≤ n ≤ 10⁴

**Example:**
```text
Input: n = 11
Output: [2,9]
Explanation: 2 + 9 = 11, and neither 2 nor 9 contains digit '0'

Input: n = 1000
Output: [1,999]
Explanation: 1 + 999 = 1000, and neither contains digit '0'
```

## 🧠 Intuition
The solution uses:
1. **Iterative Search**: Try all possible pairs (i, n-i) where i ranges from 1 to n-1
2. **Digit Validation**: Check that both numbers don't contain digit '0'
3. **Early Termination**: Return first valid pair found
4. **Simple Validation**: Convert numbers to string or use modulus to check for '0'

Key Insights:
- Since n ≤ 10,000, brute force is feasible
- The digit '0' check can be done efficiently by examining each digit
- At least one valid pair always exists for n ≥ 2

## ⚙️ Approach
1. **Iterate Possible Values**:
   - For i from 1 to n-1, check if both i and n-i are no-zero numbers
2. **Check for Zero Digits**:
   - For each number, check each digit using modulus operations
   - If any digit is 0, skip the pair
3. **Return First Valid Pair**: Once found, return immediately

## ✅ Optimized Solution
```java
class Solution {
    public int[] getNoZeroIntegers(int n) {
        for (int a = 1; a < n; a++) {
            int b = n - a;
            if (isNoZero(a) && isNoZero(b)) {
                return new int[]{a, b};
            }
        }
        return new int[]{-1, -1}; // Should never reach here per constraints
    }
    
    private boolean isNoZero(int num) {
        while (num > 0) {
            if (num % 10 == 0) {
                return false;
            }
            num /= 10;
        }
        return true;
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n log n) | n iterations × log₁₀n digit checks |
| **Space**       | O(1)       | Constant extra space |

## 📊 Example Walkthrough
**Input:** n = 11

**Execution:**
1. a=1: b=10 → 10 contains 0 → invalid
2. a=2: b=9 → both no-zero → return [2,9]

**Input:** n = 1000
1. a=1: b=999 → both no-zero → return [1,999]

## 💡 Key Features
- **Simplicity**: Straightforward brute force approach
- **Efficiency**: Works within constraints (n ≤ 10,000)
- **Early Termination**: Stops at first valid pair
- **Digit Validation**: Efficient modulus-based zero check

## 🚀 When to Use
- Problems with digit constraints
- When brute force is acceptable due to small constraints
- Number decomposition problems
- Educational examples of digit manipulation

## ⚠️ Edge Cases
- **n=2**: Smallest possible input → [1,1]
- **n=10000**: Maximum constraint
- **Numbers with multiple zeros**: Properly rejected
- **Single-digit numbers**: Handled correctly

## 🛠 Variations
1. **String Conversion**:
```java
private boolean isNoZero(int num) {
    return !String.valueOf(num).contains("0");
}
```

2. **Optimized Search**:
```java
// Start from middle and expand outward
```

3. **Memoization**:
```java
// Cache no-zero results for repeated numbers
```

4. **Parallel Processing**:
```java
// Check multiple pairs concurrently
```

5. **Visualization**:
```java
// Plot valid pairs for different n values
```

## Mathematical Insight
The solution leverages:
- Properties of decimal digit representation
- Exhaustive search within feasible bounds
- Modular arithmetic for digit extraction
- Early termination optimization

## Alternative Implementation (Faster Validation)
```java
class Solution {
    public int[] getNoZeroIntegers(int n) {
        for (int a = 1; a < n; a++) {
            int b = n - a;
            if (isNoZeroFast(a) && isNoZeroFast(b)) {
                return new int[]{a, b};
            }
        }
        return new int[]{-1, -1};
    }
    
    private boolean isNoZeroFast(int num) {
        // Faster check by processing digits without division
        String s = Integer.toString(num);
        for (char c : s.toCharArray()) {
            if (c == '0') return false;
        }
        return true;
    }
}
```
Note: The string conversion version may be faster for some inputs due to optimized string operations, but the modulus approach avoids string creation overhead. Both are efficient for the given constraints.