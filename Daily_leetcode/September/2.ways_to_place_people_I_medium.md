# üë• Number of Ways to Place People I - Geometric Ordering and Validation

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/find-the-number-of-ways-to-place-people-i/description/?envType=daily-question&envId=2025-09-02)

Given:
- An array `points` where `points[i] = [x_i, y_i]` represents coordinates of trees

Find:
- The number of ways to choose two trees such that:
  1. One person sits at tree A, another at tree B
  2. The rectangle formed by A and B as opposite corners contains no other trees
  3. The person at A must have a clear view of the person at B (no trees blocking)

**Constraints:**
- 2 ‚â§ points.length ‚â§ 50
- points[i].length == 2
- 0 ‚â§ x_i, y_i ‚â§ 100

**Example:**
```text
Input: points = [[1,1],[2,2],[3,3]]
Output: 1
Explanation: 
Only valid pair is [1,1] and [3,3] since the rectangle between them contains [2,2]
```

## üß† Intuition
The solution uses:
1. **Sorting**: Orders points by x-coordinate (and y-coordinate for same x)
2. **Pair Validation**: Checks all possible pairs of points
3. **Obstacle Checking**: Verifies no other points lie in the rectangle between two points
4. **Efficient Scanning**: Early termination when obstacles found

Key Insights:
- Sort points by x, then for same x sort by y in descending order
- For a pair (i,j) to be valid, no point should lie between them in both x and y dimensions
- The rectangle condition requires no other points in the bounding box

## ‚öôÔ∏è Approach
1. **Sort Points**:
   - Primary: x-coordinate ascending
   - Secondary: y-coordinate descending (for same x)
2. **Check Pairs**:
   - For each pair (j,i) where j < i (after sorting)
   - If points[j] has higher y than points[i] (ensures proper ordering)
   - Check if any point between them lies within their bounding box
3. **Count Valid Pairs**: Increment count if no obstructing points found

## ‚úÖ Optimized Solution
```java
class Solution {
    public int numberOfPairs(int[][] points) {
        Arrays.sort(points, new Comparator<int[]>(){
            public int compare(int[] a, int[] b){
                if(a[0]!=b[0]){
                    return Integer.compare(a[0], b[0]);
                }
                else{
                    return Integer.compare(b[1], a[1]);
                }
            }
        });
        // System.out.println(Arrays.deepToString(points));
        int count = 0;
        for(int i=1; i<points.length; i++){
            for(int j=i-1; j>=0; j--){
                if(points[j][1] >= points[i][1]){
                    boolean isUnique = true;
                    for(int k=j+1; k<i; k++){
                        if(points[k][1]>=points[i][1] && points[k][1]<=points[j][1]){
                            isUnique = false;
                            break;
                        }
                    }
                    if(isUnique){
                        // System.out.print(Arrays.toString(points[j]) + "-");
                        // System.out.println(Arrays.toString(points[i]));
                        count++;
                    }
                }
            }
        }
        return count;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n¬≥)      | n¬≤ pairs √ó n checks per pair |
| **Space**       | O(1)       | No extra space needed |

## üìä Example Walkthrough
**Input:** points = [[1,1],[2,2],[3,3]]

**Execution:**
1. Sort points: [[1,1],[2,2],[3,3]] (already sorted)
2. Check pair (0,1): rectangle (1,1) to (2,2) ‚Üí no points inside ‚Üí valid
3. Check pair (0,2): rectangle (1,1) to (3,3) ‚Üí contains (2,2) ‚Üí invalid
4. Check pair (1,2): rectangle (2,2) to (3,3) ‚Üí no points inside ‚Üí valid
5. But wait: need to ensure proper ordering for sitting
6. Final count: 1 (only [1,1] and [3,3] is invalid due to obstruction)

## üí° Key Features
- **Geometric Sorting**: Proper ordering for efficient checking
- **Complete Validation**: Checks all points for each pair
- **Clear Logic**: Easy to understand and verify
- **Early Termination**: Stops checking when obstacle found

## üöÄ When to Use
- Geometric pair selection problems
- When constraints allow O(n¬≥) solution
- Problems requiring bounding box checks
- Computational geometry applications

## ‚ö†Ô∏è Edge Cases
- **Duplicate Points**: Handled by sorting
- **Collinear Points**: May form invalid pairs if obstacles exist
- **Minimum Input**: 2 points always form 1 pair if valid
- **Large Coordinates**: Within constraint limits (0-100)

## üõ† Variations
1. **Sweep Line Optimization**:
```java
// Use sweep line to reduce number of checks
```

2. **Spatial Partitioning**:
```java
// Use grid or quadtree for faster range queries
```

3. **Early Pruning**:
```java
// Skip pairs that cannot be valid based on sorting
```

4. **Visualization**:
```java
// Plot points and valid pairs
```

5. **Generalization**:
```java
// Extend to 3D or higher dimensions
```

## Mathematical Insight
The solution leverages:
- Properties of axis-aligned rectangles
- Combinatorial geometry
- Sorting and searching techniques
- Inclusion/exclusion principles

## Alternative Implementation (Optimized Checking)
```java
class Solution {
    public int numberOfPairs(int[][] points) {
        Arrays.sort(points, (a, b) -> {
            if (a[0] != b[0]) return a[0] - b[0];
            return b[1] - a[1]; // Descending y for same x
        });
        
        int count = 0;
        int n = points.length;
        
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (points[i][1] < points[j][1]) continue; // Ensure proper y-ordering
                
                boolean valid = true;
                // Only check points between i and j in sorted order
                for (int k = i + 1; k < j; k++) {
                    if (points[k][1] <= points[i][1] && points[k][1] >= points[j][1]) {
                        valid = false;
                        break;
                    }
                }
                if (valid) count++;
            }
        }
        return count;
    }
}
```
Note: This version optimizes by only checking points between i and j in the sorted order, leveraging the sorting to reduce unnecessary checks. The original solution is more general but less efficient.