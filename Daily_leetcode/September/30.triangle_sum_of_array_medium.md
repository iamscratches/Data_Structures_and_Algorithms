# 🔺 Triangular Sum of an Array - Iterative Reduction

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/find-triangular-sum-of-an-array/?envType=daily-question&envId=2025-09-30)

Given:
- An integer array `nums`

Find:
- The triangular sum of the array
- Triangular sum is obtained by repeatedly replacing the array with sums of adjacent elements (mod 10) until one element remains

**Operation:**
- new_nums[i] = (nums[i] + nums[i+1]) % 10
- Repeat until array has one element

**Constraints:**
- 1 ≤ nums.length ≤ 1000
- 0 ≤ nums[i] ≤ 9

**Example:**
```text
Input: nums = [1,2,3,4,5]
Output: 8
Explanation:
Step 1: [1,2,3,4,5] → [3,5,7,9] (1+2, 2+3, 3+4, 4+5)
Step 2: [3,5,7,9] → [8,2,6] (3+5, 5+7, 7+9)
Step 3: [8,2,6] → [0,8] (8+2, 2+6)
Step 4: [0,8] → [8] (0+8)
Result: 8
```

## 🧠 Intuition
The solution uses:
1. **Iterative Reduction**: Repeatedly reduce array size by summing adjacent elements
2. **In-Place Modification**: Update array in place to save space
3. **Modulo Operation**: Use %10 to keep values in range 0-9
4. **Length Tracking**: Track effective array length during reduction

Key Insights:
- Each iteration reduces array size by 1
- Process continues until single element remains
- Similar to Pascal's triangle but with modulo 10
- In-place updates avoid creating new arrays

## ⚙️ Approach
1. **Initialize**: Start with original array length
2. **Iterative Reduction**:
   - While length > 1, reduce array
   - For each position i, update nums[i] = (nums[i] + nums[i+1]) % 10
   - Decrease effective length by 1
3. **Termination**: When length == 1, return nums[0]

## ✅ Optimized Solution
```java
class Solution {
    public int triangularSum(int[] nums) {
        int currentLength = nums.length;
        
        // Continue reducing until one element remains
        while (currentLength > 1) {
            // Update each element with sum of itself and next element
            for (int i = 0; i < currentLength - 1; i++) {
                nums[i] = (nums[i] + nums[i + 1]) % 10;
            }
            currentLength--; // Array size reduces by 1
        }
        
        return nums[0];
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n²)      | n iterations with decreasing work |
| **Space**       | O(1)       | In-place modification |

## 📊 Example Walkthrough
**Input:** nums = [1,2,3,4,5]

**Iteration 1 (length=5):**
- nums = [3,5,7,9,5] (last element untouched but ignored)
- Effective: [3,5,7,9]

**Iteration 2 (length=4):**
- nums = [8,2,6,9,5] 
- Effective: [8,2,6]

**Iteration 3 (length=3):**
- nums = [0,8,6,9,5]
- Effective: [0,8]

**Iteration 4 (length=2):**
- nums = [8,8,6,9,5]
- Effective: [8]

**Result:** 8

## 💡 Key Features
- **Space Efficient**: Uses original array without extra storage
- **Simple Logic**: Easy to understand and implement
- **Modulo Handling**: Properly maintains digit range
- **Early Termination**: Stops when single element remains

## 🚀 When to Use
- Array reduction problems
- When simulating iterative processes
- Problems involving adjacent element operations
- Educational examples of iterative algorithms

## ⚠️ Edge Cases
- **Single element**: Return immediately
- **All zeros**: Result will be 0
- **Large arrays**: Handles maximum constraint (n=1000)
- **Modulo behavior**: Correctly handles sums ≥ 10

## 🛠 Variations
1. **New Array Creation**:
```java
// Create new arrays instead of in-place (uses O(n) space)
```

2. **Mathematical Formula**:
```java
// Use combinatorial mathematics (Pascal's triangle coefficients)
```

3. **Parallel Processing**:
```java
// Process different segments in parallel
```

4. **Visualization**:
```java
// Show each reduction step
```

5. **Generalization**:
```java
// Different modulo values or operations
```

## Mathematical Insight
The solution leverages:
- Properties of binomial coefficients (Pascal's triangle)
- Modular arithmetic properties
- Iterative reduction patterns
- The fact that final result = Σ(nums[i] × C(n-1, i)) mod 10

## Alternative Implementation (Mathematical Approach)
```java
class Solution {
    public int triangularSum(int[] nums) {
        int n = nums.length;
        int result = 0;
        
        // Using combinatorial formula: result = Σ(nums[i] * C(n-1, i)) mod 10
        for (int i = 0; i < n; i++) {
            int coefficient = binomialCoefficient(n - 1, i) % 10;
            result = (result + nums[i] * coefficient) % 10;
        }
        return result;
    }
    
    private int binomialCoefficient(int n, int k) {
        // Calculate C(n, k) mod 10
        if (k > n - k) k = n - k;
        int result = 1;
        for (int i = 0; i < k; i++) {
            result = result * (n - i) / (i + 1);
        }
        return result % 10;
    }
}
```
Note: The mathematical approach has better theoretical time complexity O(n) but requires careful implementation to avoid overflow and handle large binomial coefficients. The iterative approach is more practical and easier to implement correctly for the given constraints.