# üî∫ Triangle - Bottom-Up Dynamic Programming

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/triangle/description/?envType=daily-question&envId=2025-09-25)

Given:
- A triangle array where `triangle[i][j]` represents the value at row i, position j
- From each cell, you can move to adjacent cells in the next row

Find:
- The minimum path sum from top to bottom
- Adjacent cells: from (i,j) you can go to (i+1,j) or (i+1,j+1)

**Constraints:**
- 1 ‚â§ triangle.length ‚â§ 200
- triangle[0].length = 1
- triangle[i].length = triangle[i-1].length + 1
- -10‚Å¥ ‚â§ triangle[i][j] ‚â§ 10‚Å¥

**Example:**
```text
Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: 
Path 2‚Üí3‚Üí5‚Üí1 = 11 (minimum)
    2
   3 4
  6 5 7
 4 1 8 3
```

## üß† Intuition
The solution uses:
1. **Bottom-Up DP**: Start from bottom row and work upwards
2. **In-Place Modification**: Update triangle values with minimum path sums
3. **Local Optimization**: Each cell chooses minimum of two possible next steps
4. **Space Efficiency**: Modifies input triangle to avoid extra space

Key Insights:
- The minimum path to bottom can be computed from minimum paths of sub-triangles
- Bottom-up avoids recursion and memoization overhead
- Each cell's minimum path = cell value + min(below left, below right)

## ‚öôÔ∏è Approach
1. **Start from Second Last Row**:
   - Process rows from bottom to top
2. **Update Each Cell**:
   - For cell (i,j): triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])
3. **Propagate Minimum**:
   - Each cell accumulates the minimum path sum from its position to bottom
4. **Final Result**:
   - Top cell contains the overall minimum path sum

## ‚úÖ Optimized Solution
```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int rows = triangle.size();
        
        // Start from second last row and move upwards
        for (int row = rows - 2; row >= 0; row--) {
            List<Integer> currentRow = triangle.get(row);
            List<Integer> nextRow = triangle.get(row + 1);
            
            // Update each cell with minimum path sum
            for (int col = 0; col < currentRow.size(); col++) {
                int minPath = Math.min(nextRow.get(col), nextRow.get(col + 1));
                currentRow.set(col, currentRow.get(col) + minPath);
            }
        }
        
        return triangle.get(0).get(0);
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n¬≤)      | Process each cell once |
| **Space**       | O(1)       | In-place modification |

## üìä Example Walkthrough
**Input:** triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]

**Step 1 (Row 2 ‚Üí Row 1):**
- Row 2: [6,5,7], Row 3: [4,1,8,3]
- Update Row 2:
  - 6 + min(4,1) = 6 + 1 = 7
  - 5 + min(1,8) = 5 + 1 = 6  
  - 7 + min(8,3) = 7 + 3 = 10
- Triangle: [[2],[3,4],[7,6,10],[4,1,8,3]]

**Step 2 (Row 1 ‚Üí Row 0):**
- Row 1: [3,4], Row 2: [7,6,10]
- Update Row 1:
  - 3 + min(7,6) = 3 + 6 = 9
  - 4 + min(6,10) = 4 + 6 = 10
- Triangle: [[2],[9,10],[7,6,10],[4,1,8,3]]

**Step 3 (Row 0):**
- Row 0: [2], Row 1: [9,10]
- Update Row 0: 2 + min(9,10) = 2 + 9 = 11

**Result:** 11

## üí° Key Features
- **In-Place DP**: No extra space required
- **Bottom-Up Approach**: Avoids recursion stack
- **Efficient Updates**: Each cell processed once
- **Clear Logic**: Easy to understand and implement

## üöÄ When to Use
- Path optimization problems in grids/triangles
- When bottom-up DP is applicable
- Problems with overlapping subproblems
- Educational examples of dynamic programming

## ‚ö†Ô∏è Edge Cases
- **Single row**: Return the only element
- **Negative numbers**: Handled correctly by min function
- **Large values**: Integer arithmetic handles constraints
- **Minimum path**: Properly finds global minimum

## üõ† Variations
1. **Top-Down DP**:
```java
// Recursive approach with memoization
```

2. **Extra Space DP**:
```java
// Use separate DP array to preserve input
```

3. **Path Reconstruction**:
```java
// Track the actual path taken
```

4. **Visualization**:
```java
// Show the DP progression step by step
```

5. **Generalization**:
```java
// Extend to 3D triangles or different move patterns
```

## Mathematical Insight
The solution leverages:
- Optimal substructure property
- Principle of mathematical induction
- Dynamic programming principles
- Minimum path accumulation

## Alternative Implementation (Top-Down with Memoization)
```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        Integer[][] memo = new Integer[triangle.size()][triangle.size()];
        return dfs(triangle, 0, 0, memo);
    }
    
    private int dfs(List<List<Integer>> triangle, int row, int col, Integer[][] memo) {
        if (row == triangle.size()) return 0;
        if (memo[row][col] != null) return memo[row][col];
        
        int left = dfs(triangle, row + 1, col, memo);
        int right = dfs(triangle, row + 1, col + 1, memo);
        
        return memo[row][col] = triangle.get(row).get(col) + Math.min(left, right);
    }
}
```
Note: The top-down approach is more intuitive but uses O(n¬≤) space for memoization. The bottom-up solution is more space-efficient and avoids recursion overhead.