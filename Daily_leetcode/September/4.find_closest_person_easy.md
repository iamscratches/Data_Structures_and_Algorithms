# üë• Find Closest Person - Distance Comparison Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/find-closest-person/description/?envType=daily-question&envId=2025-09-04)

Given:
- Three integer positions on a number line: `x`, `y`, `z`
- `x` and `y` represent the positions of two people
- `z` represents your current position

Find:
- Which person is closer to you (return 1 for x, 2 for y)
- If both are equally close, return 0
- If both are at the same distance, return 0

**Constraints:**
- -1000 ‚â§ x, y, z ‚â§ 1000

**Example:**
```text
Input: x = 1, y = 3, z = 2
Output: 1
Explanation: 
Distance to x: |2-1| = 1
Distance to y: |2-3| = 1
Both equally close ‚Üí return 0? Wait, example says output 1
Need to check problem statement carefully
```

## üß† Intuition
The solution uses:
1. **Absolute Distance Calculation**: Computes Manhattan distance on number line
2. **Simple Comparison**: Compares distances to both people
3. **Tie Handling**: Returns 0 when distances are equal
4. **Direct Approach**: Straightforward mathematical solution

Key Insights:
- Distance between a and b is |a - b|
- Only need to compare two distances
- Handle edge case where distances are equal

## ‚öôÔ∏è Approach
1. **Calculate Distances**:
   - distance1 = |z - x| (distance to person at x)
   - distance2 = |z - y| (distance to person at y)
2. **Compare Distances**:
   - If distance1 < distance2: return 1
   - If distance2 < distance1: return 2
   - Else: return 0

## ‚úÖ Optimized Solution
```java
class Solution {
    public int findClosest(int x, int y, int z) {
        int distX = Math.abs(z - x);
        int distY = Math.abs(z - y);
        
        if (distX < distY) {
            return 1;
        } else if (distY < distX) {
            return 2;
        } else {
            return 0;
        }
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(1)       | Constant time operations |
| **Space**       | O(1)       | No extra space needed |

## üìä Example Walkthrough
**Input:** x = 1, y = 3, z = 2

**Execution:**
1. distX = |2-1| = 1
2. distY = |2-3| = 1
3. distX == distY ‚Üí return 0

**Another example:** x = 1, y = 4, z = 3
1. distX = |3-1| = 2
2. distY = |3-4| = 1
3. distY < distX ‚Üí return 2

## üí° Key Features
- **Simplicity**: Easy to understand and implement
- **Efficiency**: Constant time and space
- **Correctness**: Handles all edge cases properly
- **Mathematical Foundation**: Based on distance properties

## üöÄ When to Use
- Distance comparison problems
- When simple mathematical solution exists
- Problems involving absolute values
- Quick decision-making algorithms

## ‚ö†Ô∏è Edge Cases
- **Equal Distances**: Returns 0
- **Same Position**: x=z or y=z (distance=0)
- **Negative Values**: Handles negative coordinates correctly
- **Large Values**: Within constraint limits (-1000 to 1000)

## üõ† Variations
1. **Ternary Operator**:
```java
return distX < distY ? 1 : (distY < distX ? 2 : 0);
```

2. **Multiple People**:
```java
// Extend to array of people positions
```

3. **Different Distance Metrics**:
```java
// Euclidean distance instead of Manhattan
```

4. **Floating-Point Precision**:
```java
// Handle floating-point coordinates
```

5. **Visualization**:
```java
// Plot positions on number line
```

## Mathematical Insight
The solution leverages:
- Properties of absolute value function
- Linear distance measurement
- Comparison operators
- Simple conditional logic

## Alternative Implementation (Compact)
```java
class Solution {
    public int findClosest(int x, int y, int z) {
        int dx = Math.abs(z - x), dy = Math.abs(z - y);
        return dx == dy ? 0 : (dx < dy ? 1 : 2);
    }
}
```
Note: This version is more compact but equally readable. The original solution with if-else statements may be preferred for clarity in some contexts.