# üî¢ Replace Non-Coprime Numbers in Array - Stack-Based LCM Merging

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/replace-non-coprime-numbers-in-array/description/?envType=daily-question&envId=2025-09-16)

Given:
- An array `nums` of positive integers

Operation:
- Replace two adjacent non-coprime numbers with their LCM
- Repeat until no adjacent non-coprime pairs exist

Find:
- The final array after all possible replacements

**Constraints:**
- 1 ‚â§ nums.length ‚â§ 10‚Åµ
- 1 ‚â§ nums[i] ‚â§ 10‚Åµ

**Example:**
```text
Input: nums = [6,4,3,2,7,6,2]
Output: [12,7,6]
Explanation:
Step 1: Replace (6,4) with LCM(6,4)=12 ‚Üí [12,3,2,7,6,2]
Step 2: Replace (12,3) with LCM(12,3)=12 ‚Üí [12,2,7,6,2]
Step 3: Replace (12,2) with LCM(12,2)=12 ‚Üí [12,7,6,2]
Step 4: Replace (6,2) with LCM(6,2)=6 ‚Üí [12,7,6]
```

## üß† Intuition
The solution uses:
1. **Stack Processing**: Maintain a stack of coprime numbers
2. **GCD Checking**: Check coprimality between stack top and current number
3. **LCM Merging**: Replace non-coprime pairs with their LCM
4. **Backward Propagation**: Continue merging with stack until coprime

Key Insights:
- LCM(a,b) = (a √ó b) / GCD(a,b)
- Merging may create new non-coprime pairs with previous elements
- Stack allows efficient backward propagation of merges

## ‚öôÔ∏è Approach
1. **Initialize Stack**: Process numbers left to right
2. **Check Coprimality**:
   - For each number, check with stack top
   - If GCD > 1, merge using LCM
   - Continue until stack is empty or GCD=1
3. **Add to Stack**: Push the (possibly merged) number
4. **Return Result**: Stack contains final coprime sequence

## ‚úÖ Optimized Solution
```java
class Solution {
    public List<Integer> replaceNonCoprimes(int[] nums) {
        LinkedList<Integer> stack = new LinkedList<>();
        
        for (int num : nums) {
            int current = num;
            // Merge with stack top while non-coprime
            while (!stack.isEmpty()) {
                int top = stack.getLast();
                int gcd = gcd(top, current);
                if (gcd == 1) break; // Coprime, stop merging
                
                // Merge with LCM = (top * current) / gcd
                stack.removeLast();
                current = (int) ((long) top * current / gcd); // Prevent overflow
            }
            stack.add(current);
        }
        
        return stack;
    }
    
    private int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n log M) | n numbers, M is max value |
| **Space**       | O(n)       | Stack storage |

## üìä Example Walkthrough
**Input:** nums = [6,4,3,2,7,6,2]

**Execution:**
1. Process 6: stack = [6]
2. Process 4: GCD(6,4)=2 ‚Üí merge: LCM=12 ‚Üí stack = [12]
3. Process 3: GCD(12,3)=3 ‚Üí merge: LCM=12 ‚Üí stack = [12]
4. Process 2: GCD(12,2)=2 ‚Üí merge: LCM=12 ‚Üí stack = [12]
5. Process 7: GCD(12,7)=1 ‚Üí stack = [12,7]
6. Process 6: GCD(7,6)=1 ‚Üí stack = [12,7,6]
7. Process 2: GCD(6,2)=2 ‚Üí merge: LCM=6 ‚Üí stack = [12,7,6]

## üí° Key Features
- **Efficient Merging**: Stack enables backward propagation
- **GCD Optimization**: Euclidean algorithm for fast GCD computation
- **Overflow Prevention**: Uses long for intermediate LCM calculation
- **Early Termination**: Stops when coprime pair found

## üöÄ When to Use
- Problems requiring adjacent element merging
- When operations need backward propagation
- Number theory problems involving GCD/LCM
- Stack-based processing scenarios

## ‚ö†Ô∏è Edge Cases
- **All coprime numbers**: No merging occurs
- **Single element**: Returns original array
- **Large numbers**: LCM calculation may overflow without care
- **All identical numbers**: Merge into single LCM

## üõ† Variations
1. **Array List Stack**:
```java
// Use ArrayList instead of LinkedList
```

2. **Iterative GCD**:
```java
// Alternative GCD implementations
```

3. **Parallel Processing**:
```java
// Not suitable due to sequential dependencies
```

4. **Visualization**:
```java
// Show merging process step-by-step
```

5. **Generalization**:
```java
// Extend to other merge operations
```

## Mathematical Insight
The solution leverages:
- Properties of GCD and LCM
- Euclidean algorithm efficiency
- Stack data structure for sequential processing
- The fact that LCM(a,b) preserves divisibility relationships

## Alternative Implementation (ArrayList)
```java
class Solution {
    public List<Integer> replaceNonCoprimes(int[] nums) {
        List<Integer> stack = new ArrayList<>();
        for (int num : nums) {
            int current = num;
            while (!stack.isEmpty()) {
                int top = stack.get(stack.size() - 1);
                int g = gcd(top, current);
                if (g == 1) break;
                stack.remove(stack.size() - 1);
                current = (int) ((long) top * current / g);
            }
            stack.add(current);
        }
        return stack;
    }
    
    private int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}
```
Note: This version uses ArrayList and recursive GCD. The LinkedList version may be more efficient for frequent removals from the end. Both approaches have the same time complexity.