# üåê Router Implementation - Packet Management with Time-Window Queries

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/implement-router/description/?envType=daily-question&envId=2025-09-20)

Design a network router that supports:
1. **Adding packets** with source, destination, and timestamp
2. **Forwarding packets** in FIFO order
3. **Counting packets** for a destination within time windows
4. **Memory management** with fixed capacity

**Constraints:**
- Packets are unique (same source, destination, timestamp)
- Memory limit determines maximum stored packets
- Efficient time-window queries required

**Example:**
```text
Input:
["Router", "addPacket", "addPacket", "forwardPacket", "getCount"]
[[2], [1, 2, 100], [1, 2, 100], [], [2, 0, 200]]

Output: [null, true, false, [1,2,100], 1]
```

## üß† Intuition
The solution uses:
1. **Queue Management**: FIFO order for packet forwarding
2. **Destination Tracking**: Separate data structures per destination
3. **Duplicate Prevention**: Check for existing packets before addition
4. **Time-Window Queries**: Binary search for efficient range counting
5. **Memory Management**: Evict oldest packets when capacity exceeded

Key Insights:
- Maintain both queue-wide and destination-specific views
- Use hashing for duplicate detection
- Binary search enables efficient time-range queries
- Memory eviction follows FIFO policy

## ‚öôÔ∏è Approach
1. **Data Structures**:
   - `Queue<int[]>`: FIFO packet storage [source, destination, timestamp]
   - `Map<Integer, Destination>`: destination ‚Üí specialized container
2. **Destination Class**:
   - `List<int[]>`: packets stored in timestamp order
   - `Set<Long>`: quick duplicate detection
   - Binary search methods for time-range queries
3. **Operations**:
   - **addPacket**: Check duplicates, evict if needed, add to queue and destination
   - **forwardPacket**: Remove from queue and destination
   - **getCount**: Binary search for packets in time range

## ‚úÖ Optimized Solution
```java
class Router {
    private final Queue<Packet> queue;
    private final int maxMemory;
    private final Map<Integer, Destination> destinations;

    public Router(int memoryLimit) {
        queue = new LinkedList<>();
        maxMemory = memoryLimit;
        destinations = new HashMap<>();
    }

    public boolean addPacket(int source, int destination, int timestamp) {
        // Check for duplicate packet
        Destination dest = destinations.get(destination);
        if (dest != null && dest.contains(timestamp, source)) {
            return false;
        }

        // Evict if memory full
        if (queue.size() == maxMemory) {
            Packet oldest = queue.poll();
            destinations.get(oldest.destination).removePacket();
        }

        // Add to destination tracking
        if (dest == null) {
            dest = new Destination();
            destinations.put(destination, dest);
        }
        dest.addPacket(timestamp, source);

        // Add to main queue
        queue.add(new Packet(source, destination, timestamp));
        return true;
    }

    public int[] forwardPacket() {
        if (queue.isEmpty()) return new int[0];
        
        Packet packet = queue.poll();
        destinations.get(packet.destination).removePacket();
        return new int[]{packet.source, packet.destination, packet.timestamp};
    }

    public int getCount(int destination, int startTime, int endTime) {
        Destination dest = destinations.get(destination);
        return dest == null ? 0 : dest.getCount(startTime, endTime);
    }
}

class Packet {
    int source, destination, timestamp;
    Packet(int s, int d, int t) {
        source = s; destination = d; timestamp = t;
    }
}

class Destination {
    private final List<Packet> packets;
    private final Set<Long> fingerprintSet;
    private int start, end; // Sliding window indices

    Destination() {
        packets = new ArrayList<>();
        fingerprintSet = new HashSet<>();
        start = 0; end = -1;
    }

    public void addPacket(int timestamp, int source) {
        Packet packet = new Packet(source, 0, timestamp);
        packets.add(packet);
        end++;
        fingerprintSet.add(fingerprint(timestamp, source));
    }

    public void removePacket() {
        if (start > end) return;
        Packet packet = packets.get(start);
        fingerprintSet.remove(fingerprint(packet.timestamp, packet.source));
        start++;
    }

    public boolean contains(int timestamp, int source) {
        return fingerprintSet.contains(fingerprint(timestamp, source));
    }

    public int getCount(int startTime, int endTime) {
        if (start > end) return 0;
        
        // Binary search for lower bound
        int left = start, right = end;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (packets.get(mid).timestamp >= startTime) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        int lowerBound = left;

        // Binary search for upper bound
        left = start; right = end;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (packets.get(mid).timestamp <= endTime) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        int upperBound = right;

        return Math.max(0, upperBound - lowerBound + 1);
    }

    private long fingerprint(int timestamp, int source) {
        return ((long) timestamp << 32) | source;
    }
}
```

## ‚è≥ Complexity Analysis
| Operation       | Complexity | Description |
|-----------------|------------|-------------|
| **addPacket**   | O(1)       | Average case with hashing |
| **forwardPacket**| O(1)      | Queue operations |
| **getCount**    | O(log n)   | Binary search in destination |

## üìä Example Walkthrough
**Initialization:** memoryLimit = 2
- queue = [], destinations = {}

**addPacket(1, 2, 100):**
- destinations[2] = new Destination()
- Add to queue and destination
- queue = [(1,2,100)], destinations[2] = [100]

**addPacket(1, 2, 100):**
- Duplicate detected ‚Üí return false

**forwardPacket():**
- Remove (1,2,100) from queue and destination
- Return [1,2,100]

**getCount(2, 0, 200):**
- Binary search in destination[2] ‚Üí 1 packet in range

## üí° Key Features
- **Efficient Duplicate Detection**: Hash-based O(1) checks
- **Memory Management**: FIFO eviction policy
- **Fast Time Queries**: Binary search for range counts
- **Modular Design**: Separate Destination class for encapsulation

## üöÄ When to Use
- Network packet management systems
- Time-series data processing
- Systems with memory constraints
- Real-time analytics applications

## ‚ö†Ô∏è Edge Cases
- **Empty router**: Forward returns empty, count returns 0
- **Duplicate packets**: Properly rejected
- **Memory exhaustion**: FIFO eviction works correctly
- **Time range queries**: Handle out-of-range times

## üõ† Variations
1. **Priority Queue**:
```java
// Quality of Service (QoS) based forwarding
```

2. **Persistence**:
```java
// Database integration for large datasets
```

3. **Real-time Analytics**:
```java
// Streaming statistics calculation
```

4. **Visualization**:
```java
// Network traffic monitoring dashboard
```

5. **Security Features**:
```java
// Packet filtering and validation
```

## System Design Insight
The solution leverages:
- FIFO queue for packet ordering
- HashMap for destination-based grouping
- Binary search for efficient range queries
- Fingerprinting for duplicate detection
- Sliding window for memory management

## Alternative Implementation (TreeMap)
```java
// Use TreeMap for destination packets for easier range queries
// But would increase memory overhead
```
Note: The current implementation provides optimal performance for the required operations while maintaining memory efficiency. The binary search approach is well-suited for the time-range query requirements.