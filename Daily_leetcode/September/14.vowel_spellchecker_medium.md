# üîç Vowel Spellchecker - Multi-Level Dictionary Matching

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/vowel-spellchecker/description/?envType=daily-question&envId=2025-09-14)

Given:
- A `wordlist` of correct words
- A list of `queries` to check

Implement a spell checker that returns:
1. Exact match (case-sensitive)
2. Case-insensitive match
3. Case-insensitive match ignoring vowels (vowels can be replaced with any vowel)

**Constraints:**
- 1 ‚â§ wordlist.length, queries.length ‚â§ 3000
- 1 ‚â§ wordlist[i].length, queries[i].length ‚â§ 20
- All strings consist of English letters

**Example:**
```text
Input: 
wordlist = ["KiTe","kite","hare","Hare"]
queries = ["kite","Kite","KiTe","Hare","HARE","Hear","hear","keti","keet","keto"]

Output: ["kite","KiTe","KiTe","Hare","hare","","","KiTe","","KiTe"]
```

## üß† Intuition
The solution uses:
1. **Three-Level Matching**: Exact ‚Üí Case-insensitive ‚Üí Vowel-ignoring
2. **Dictionary Preprocessing**: Create mappings for different match types
3. **Efficient Lookups**: Hash-based O(1) lookups for each query
4. **Vowel Normalization**: Replace vowels with wildcards for fuzzy matching

Key Insights:
- Exact match takes highest priority
- Case-insensitive match uses lowercase normalization
- Vowel-ignoring match uses vowel‚Üíwildcard transformation
- First match in wordlist order is returned (using putIfAbsent)

## ‚öôÔ∏è Approach
1. **Preprocessing**:
   - `exactSet`: HashSet for exact matches
   - `caseInsensitiveMap`: Map lowercase to first original word
   - `vowelWildcardMap`: Map vowel-normalized to first original word
2. **Query Processing**:
   - Check exact match first
   - Then case-insensitive match
   - Then vowel-ignoring match
   - Return empty string if no match found

## ‚úÖ Optimized Solution
```java
class Solution {
    public String[] spellchecker(String[] wordlist, String[] queries) {
        // Level 1: Exact match (case-sensitive)
        Set<String> exactMatch = new HashSet<>(Arrays.asList(wordlist));
        
        // Level 2: Case-insensitive match (map lowercase to first occurrence)
        Map<String, String> caseInsensitive = new HashMap<>();
        
        // Level 3: Vowel-ignoring match (map vowel-normalized to first occurrence)
        Map<String, String> vowelIgnoring = new HashMap<>();
        
        // Preprocess wordlist
        for (String word : wordlist) {
            String lower = word.toLowerCase();
            // Store first occurrence for case-insensitive match
            caseInsensitive.putIfAbsent(lower, word);
            // Store first occurrence for vowel-ignoring match
            String devoweled = devowel(lower);
            vowelIgnoring.putIfAbsent(devoweled, word);
        }
        
        // Process queries
        String[] result = new String[queries.length];
        for (int i = 0; i < queries.length; i++) {
            String query = queries[i];
            String lower = query.toLowerCase();
            String devoweled = devowel(lower);
            
            if (exactMatch.contains(query)) {
                result[i] = query; // Exact match
            } else if (caseInsensitive.containsKey(lower)) {
                result[i] = caseInsensitive.get(lower); // Case-insensitive match
            } else if (vowelIgnoring.containsKey(devoweled)) {
                result[i] = vowelIgnoring.get(devoweled); // Vowel-ignoring match
            } else {
                result[i] = ""; // No match
            }
        }
        
        return result;
    }
    
    private String devowel(String word) {
        // Replace all vowels with '*' wildcard
        StringBuilder sb = new StringBuilder();
        for (char c : word.toCharArray()) {
            if (isVowel(c)) {
                sb.append('*');
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }
    
    private boolean isVowel(char c) {
        return "aeiouAEIOU".indexOf(c) != -1;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Preprocessing** | O(n √ó l) | n words of average length l |
| **Query Processing** | O(q √ó l) | q queries of average length l |
| **Space**       | O(n √ó l)   | Storage for mappings |

## üìä Example Walkthrough
**Preprocessing wordlist ["KiTe","kite","hare","Hare"]:**
- exactMatch: {"KiTe","kite","hare","Hare"}
- caseInsensitive: {"kite"‚Üí"KiTe", "hare"‚Üí"hare", "hare"‚Üí"Hare"}
- vowelIgnoring: {"k*t*"‚Üí"KiTe", "h*r*"‚Üí"hare"}

**Query "kite":**
- Exact match? No ("kite" ‚â† "KiTe")
- Case-insensitive: "kite" ‚Üí "KiTe" ‚Üí return "KiTe"

**Query "HARE":**
- Exact match? No
- Case-insensitive: "hare" ‚Üí "hare" ‚Üí return "hare"

**Query "Hear":**
- No exact or case-insensitive match
- Vowel-ignoring: "h**r" ‚Üí not in map ‚Üí return ""

## üí° Key Features
- **Priority-Based Matching**: Three levels of matching precedence
- **Efficient Preprocessing**: One-time dictionary processing
- **First Occurrence Preservation**: putIfAbsent maintains wordlist order
- **Wildcard Transformation**: Vowels replaced with * for fuzzy matching

## üöÄ When to Use
- Spell checking implementations
- Multi-level pattern matching
- String normalization problems
- Fuzzy search applications

## ‚ö†Ô∏è Edge Cases
- **Empty Wordlist**: All queries return ""
- **Duplicate Words**: putIfAbsent preserves first occurrence
- **All Vowels**: Complete wildcard transformation
- **No Matches**: Return empty string appropriately

## üõ† Variations
1. **Trie Structure**:
```java
// Use trie for more advanced pattern matching
```

2. **Weighted Matching**:
```java
// Prioritize more common words
```

3. **Levenshtein Distance**:
```java
// Add edit distance for closer matches
```

4. **Visualization**:
```java
// Show matching process and transformations
```

5. **Generalization**:
```java
// Extend to other character transformations
```

## Mathematical Insight
The solution leverages:
- Hash-based constant time lookups
- String transformation properties
- Priority ordering of match types
- Set and map operations efficiency

## Alternative Implementation (Stream API)
```java
class Solution {
    public String[] spellchecker(String[] wordlist, String[] queries) {
        Set<String> exact = Arrays.stream(wordlist).collect(Collectors.toSet());
        
        Map<String, String> caseInsensitive = Arrays.stream(wordlist)
            .collect(Collectors.toMap(
                String::toLowerCase,
                word -> word,
                (first, second) -> first // Keep first occurrence
            ));
            
        Map<String, String> vowelIgnoring = Arrays.stream(wordlist)
            .collect(Collectors.toMap(
                word -> devowel(word.toLowerCase()),
                word -> word,
                (first, second) -> first
            ));
        
        return Arrays.stream(queries)
            .map(query -> {
                if (exact.contains(query)) return query;
                String lower = query.toLowerCase();
                if (caseInsensitive.containsKey(lower)) return caseInsensitive.get(lower);
                String devoweled = devowel(lower);
                if (vowelIgnoring.containsKey(devoweled)) return vowelIgnoring.get(devoweled);
                return "";
            })
            .toArray(String[]::new);
    }
    
    private String devowel(String word) {
        return word.replaceAll("[aeiouAEIOU]", "*");
    }
}
```
Note: This version uses Java Streams for a more functional approach, but the original solution may be more efficient for large inputs due to fewer string operations.