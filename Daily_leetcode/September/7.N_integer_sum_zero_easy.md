# ‚ûï Find N Unique Integers Sum up to Zero - Symmetric Pairing Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/description/?envType=daily-question&envId=2025-09-07)

Given:
- An integer `n`

Find:
- Return any array containing exactly `n` unique integers that sum to 0

**Constraints:**
- 1 ‚â§ n ‚â§ 1000

**Example:**
```text
Input: n = 5
Output: [-7,-1,1,3,4]
Explanation: These 5 unique integers sum to -7-1+1+3+4=0
Other valid solutions: [-1,0,1] for n=3, etc.
```

## üß† Intuition
The solution uses:
1. **Symmetric Pairing**: Create pairs of positive and negative numbers that cancel each other
2. **Parity Handling**: Different strategies for odd and even n
3. **Zero Inclusion**: For odd n, include 0 to maintain uniqueness and sum
4. **Sequential Generation**: Use consecutive numbers for simplicity

Key Insights:
- Pairs of (k, -k) always sum to 0
- For even n: use n/2 pairs
- For odd n: use (n-1)/2 pairs plus 0
- This ensures all numbers are unique and sum to 0

## ‚öôÔ∏è Approach
1. **Check Parity**:
   - If n is odd, include 0 and create pairs for remaining n-1 elements
   - If n is even, create pairs for all n elements
2. **Generate Pairs**:
   - Use consecutive integers starting from 1
   - For each pair, assign positive and negative values
3. **Return Result**: Construct the array with generated numbers

## ‚úÖ Optimized Solution
```java
class Solution {
    public int[] sumZero(int n) {
        int[] result = new int[n];
        int index = 0;
        
        // If n is odd, include 0
        if (n % 2 != 0) {
            result[index++] = 0;
            n--; // Now we have even number of elements left
        }
        
        // Add symmetric pairs
        int value = 1;
        while (index < result.length) {
            result[index++] = value;
            result[index++] = -value;
            value++;
        }
        
        return result;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass to generate numbers |
| **Space**       | O(n)       | Output array storage |

## üìä Example Walkthrough
**Input:** n = 5 (odd)

**Execution:**
1. Add 0: [0]
2. Add pair 1, -1: [0, 1, -1]
3. Add pair 2, -2: [0, 1, -1, 2, -2]
4. Final array: [0, 1, -1, 2, -2] (sums to 0)

**Input:** n = 4 (even)
1. Add pair 1, -1: [1, -1]
2. Add pair 2, -2: [1, -1, 2, -2]
3. Final array: [1, -1, 2, -2] (sums to 0)

## üí° Key Features
- **Simplicity**: Easy to understand and implement
- **Efficiency**: Linear time and space complexity
- **Uniqueness**: All generated numbers are distinct
- **Correctness**: Guaranteed sum to zero

## üöÄ When to Use
- Problems requiring symmetric number generation
- When unique elements with zero sum are needed
- Quick array generation tasks
- Educational examples of symmetry

## ‚ö†Ô∏è Edge Cases
- **n = 1**: Returns [0]
- **n = 2**: Returns [1, -1]
- **Large n**: Handles maximum constraint (n=1000)
- **All Positive/Negative**: Not needed since sum must be zero

## üõ† Variations
1. **Different Number Ranges**:
```java
// Use larger numbers or different sequences
```

2. **Randomized Generation**:
```java
// Generate random pairs while maintaining sum
```

3. **Balanced Distribution**:
```java
// Ensure numbers are evenly distributed
```

4. **Visualization**:
```java
// Plot the symmetric number line
```

5. **Generalization**:
```java
// Sum to any target value (not just zero)
```

## Mathematical Insight
The solution leverages:
- Properties of additive inverses
- Symmetry in number systems
- Parity-based construction
- Arithmetic progression properties

## Alternative Implementation (Without Zero)
```java
class Solution {
    public int[] sumZero(int n) {
        int[] result = new int[n];
        for (int i = 0; i < n / 2; i++) {
            result[i] = i + 1;
            result[n - 1 - i] = -(i + 1);
        }
        return result;
    }
}
```
Note: This version works for both odd and even n without explicitly handling parity, but may be less intuitive. The original solution clearly shows the thought process behind including zero for odd n.