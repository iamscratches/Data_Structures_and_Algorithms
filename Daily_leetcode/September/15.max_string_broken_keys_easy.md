# ‚å®Ô∏è Maximum Number of Words You Can Type - Broken Keys Validation

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/maximum-number-of-words-you-can-type/description/?envType=daily-question&envId=2025-09-15)

Given:
- A string `text` containing words separated by spaces
- A string `brokenLetters` containing characters representing broken keys

Find:
- The number of words in `text` that can be fully typed using a keyboard with the broken keys

**Constraints:**
- 1 ‚â§ text.length ‚â§ 10‚Å¥
- 0 ‚â§ brokenLetters.length ‚â§ 26
- `text` consists of words separated by spaces
- All strings consist of lowercase English letters only

**Example:**
```text
Input: text = "hello world", brokenLetters = "ad"
Output: 1
Explanation:
"hello" contains 'd'? No ‚Üí can be typed
"world" contains 'd'? Yes ‚Üí cannot be typed
Only "hello" can be typed ‚Üí output 1
```

## üß† Intuition
The solution uses:
1. **Word Splitting**: Split text into individual words
2. **Broken Key Checking**: For each word, check if it contains any broken letters
3. **Counting Valid Words**: Count words without any broken letters
4. **Early Termination**: Stop checking a word once any broken letter is found

Key Insights:
- A word is typable only if it contains none of the broken letters
- The solution efficiently checks each word against all broken letters
- Simple string operations suffice due to constraints

## ‚öôÔ∏è Approach
1. **Split Text**: Convert input text into array of words
2. **Check Each Word**:
   - For each word, check if it contains any character from brokenLetters
   - If no broken letters found, count it as valid
3. **Return Result**: Total words minus words with broken letters

## ‚úÖ Optimized Solution
```java
class Solution {
    public int canBeTypedWords(String text, String brokenLetters) {
        // Split text into words
        String[] words = text.split(" ");
        int invalidCount = 0;
        
        // If no broken letters, all words are typable
        if (brokenLetters.isEmpty()) {
            return words.length;
        }
        
        // Check each word for broken letters
        for (String word : words) {
            for (char brokenChar : brokenLetters.toCharArray()) {
                if (word.indexOf(brokenChar) != -1) {
                    invalidCount++;
                    break; // No need to check other broken letters for this word
                }
            }
        }
        
        return words.length - invalidCount;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n √ó m)   | n words, m broken letters |
| **Space**       | O(n)       | Storage for words array |

## üìä Example Walkthrough
**Input:** text = "hello world", brokenLetters = "ad"

**Execution:**
1. Split: words = ["hello", "world"]
2. Check "hello":
   - Contains 'a'? No
   - Contains 'd'? No ‚Üí valid
3. Check "world":
   - Contains 'd'? Yes ‚Üí invalid
4. Result: 2 - 1 = 1

## üí° Key Features
- **Efficient Checking**: Uses indexOf for fast character search
- **Early Termination**: Breaks inner loop when broken letter found
- **Edge Case Handling**: Handles empty brokenLetters efficiently
- **Simple Logic**: Easy to understand and implement

## üöÄ When to Use
- String validation problems
- When checking for character containment
- Problems with constraint-based filtering
- Educational examples of string manipulation

## ‚ö†Ô∏è Edge Cases
- **Empty brokenLetters**: All words are typable
- **Single character words**: Handled correctly
- **All words invalid**: Return 0
- **Duplicate broken letters**: No issue due to break statement

## üõ† Variations
1. **Set Optimization**:
```java
// Use HashSet for broken letters for O(1) lookups
```

2. **Stream API**:
```java
// Functional programming approach
```

3. **Bit Mask**:
```java
// Use bit masks for character presence checking
```

4. **Parallel Processing**:
```java
// Process words concurrently for large texts
```

5. **Visualization**:
```java
// Highlight typable vs non-typable words
```

## Mathematical Insight
The solution leverages:
- String search algorithms
- Set operations (implicitly)
- Early termination optimization
- Linear scanning efficiency

## Alternative Implementation (HashSet)
```java
class Solution {
    public int canBeTypedWords(String text, String brokenLetters) {
        if (brokenLetters.isEmpty()) {
            return text.split(" ").length;
        }
        
        Set<Character> brokenSet = new HashSet<>();
        for (char c : brokenLetters.toCharArray()) {
            brokenSet.add(c);
        }
        
        String[] words = text.split(" ");
        int count = 0;
        
        for (String word : words) {
            boolean valid = true;
            for (char c : word.toCharArray()) {
                if (brokenSet.contains(c)) {
                    valid = false;
                    break;
                }
            }
            if (valid) count++;
        }
        
        return count;
    }
}
```
Note: This version uses a HashSet for O(1) broken letter lookups, which is more efficient when words are long. The original solution may be better when brokenLetters is very short.