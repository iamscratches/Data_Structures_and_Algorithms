# üé¨ Movie Rental System - Multi-Index Management with TreeSet

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/design-movie-rental-system/description/?envType=daily-question&envId=2025-09-21)

Design a movie rental system that supports:
1. **Initialization** with shops, movies, and prices
2. **Searching** for available movies (cheapest first, then by shop)
3. **Renting** movies (moving from available to rented)
4. **Dropping** movies (returning from rented to available)
5. **Reporting** rented movies (cheapest first, then shop, then movie)

**Constraints:**
- 1 ‚â§ n ‚â§ 3 √ó 10‚Å¥
- 1 ‚â§ entries.length ‚â§ 10‚Åµ
- Efficient operations required

**Example:**
```text
Input:
["MovieRentingSystem", "search", "rent", "rent", "report", "drop", "search"]
[[3, [[0,1,5],[0,2,6],[0,3,7],[1,1,4],[1,2,7],[2,1,5]]], [1], [0,1], [1,1], [], [1,1], [1]]

Output: [null, [1,0,2], null, null, [[0,1],[1,1]], null, [0,2]]
```

## üß† Intuition
The solution uses:
1. **Multi-Index Management**: Separate data structures for available and rented movies
2. **TreeSet Sorting**: Automatic ordering by price, shop, and movie
3. **Fast Lookup**: HashMap for quick (shop, movie) access
4. **Efficient Operations**: TreeSet provides O(log n) operations

Key Insights:
- Maintain available movies grouped by movie ID
- Use separate TreeSet for rented movies
- Custom comparator handles multi-field sorting
- Bit manipulation for efficient key generation

## ‚öôÔ∏è Approach
1. **Data Structures**:
   - `availableByMovie`: Map<Integer, TreeSet<Node>> - Available copies by movie
   - `rentedSet`: TreeSet<Node> - Currently rented copies
   - `byPair`: Map<Long, Node> - Quick (shop, movie) lookup
2. **Node Class**: Represents (shop, movie, price) triple
3. **Custom Comparator**: Orders by price‚Üë, shop‚Üë, movie‚Üë
4. **Key Generation**: 64-bit key from shop and movie IDs

## ‚úÖ Optimized Solution
```java
class MovieRentingSystem {
    static class Rental {
        int shop, movie, price;
        Rental(int s, int m, int p) {
            shop = s; movie = m; price = p;
        }
    }

    private final Comparator<Rental> comparator = (a, b) -> {
        if (a.price != b.price) return Integer.compare(a.price, b.price);
        if (a.shop != b.shop) return Integer.compare(a.shop, b.shop);
        return Integer.compare(a.movie, b.movie);
    };

    private final Map<Integer, TreeSet<Rental>> available = new HashMap<>();
    private final TreeSet<Rental> rented = new TreeSet<>(comparator);
    private final Map<Long, Rental> lookup = new HashMap<>();

    public MovieRentingSystem(int n, int[][] entries) {
        for (int[] entry : entries) {
            Rental rental = new Rental(entry[0], entry[1], entry[2]);
            long key = ((long) entry[0] << 32) | entry[1];
            lookup.put(key, rental);
            available.computeIfAbsent(entry[1], k -> new TreeSet<>(comparator))
                   .add(rental);
        }
    }

    public List<Integer> search(int movie) {
        List<Integer> result = new ArrayList<>();
        TreeSet<Rental> set = available.get(movie);
        if (set == null) return result;
        
        Iterator<Rental> it = set.iterator();
        for (int i = 0; i < 5 && it.hasNext(); i++) {
            result.add(it.next().shop);
        }
        return result;
    }

    public void rent(int shop, int movie) {
        long key = ((long) shop << 32) | movie;
        Rental rental = lookup.get(key);
        if (rental == null) return;
        
        TreeSet<Rental> set = available.get(movie);
        if (set != null) set.remove(rental);
        rented.add(rental);
    }

    public void drop(int shop, int movie) {
        long key = ((long) shop << 32) | movie;
        Rental rental = lookup.get(key);
        if (rental == null) return;
        
        rented.remove(rental);
        available.computeIfAbsent(movie, k -> new TreeSet<>(comparator))
                .add(rental);
    }

    public List<List<Integer>> report() {
        List<List<Integer>> result = new ArrayList<>();
        Iterator<Rental> it = rented.iterator();
        for (int i = 0; i < 5 && it.hasNext(); i++) {
            Rental rental = it.next();
            result.add(Arrays.asList(rental.shop, rental.movie));
        }
        return result;
    }
}
```

## ‚è≥ Complexity Analysis
| Operation       | Complexity | Description |
|-----------------|------------|-------------|
| **Constructor** | O(n log n) | Building TreeSets |
| **search**      | O(1)       | Iterator for first 5 |
| **rent/drop**   | O(log n)   | TreeSet operations |
| **report**      | O(1)       | Iterator for first 5 |

## üìä Example Walkthrough
**Initialization:** entries = [[0,1,5],[0,2,6],[1,1,4],[1,2,7]]
- available: 
  - movie1: [shop1@4, shop0@5]
  - movie2: [shop0@6, shop1@7]
- lookup: contains all entries

**search(1):**
- Return [1,0] (cheapest first: shop1@4, then shop0@5)

**rent(0,1):**
- Remove from available[movie1]
- Add to rented: [shop0@5]

**rent(1,1):**
- Remove from available[movie1] (now empty)
- Add to rented: [shop0@5, shop1@4] (sorted by price)

**report():**
- Return [[1,1],[0,1]] (shop1@4 first, then shop0@5)

**drop(1,1):**
- Remove from rented
- Add back to available[movie1]: [shop1@4]

## üí° Key Features
- **Efficient Sorting**: TreeSet maintains automatic ordering
- **Quick Access**: HashMap for O(1) rental lookup
- **Memory Efficient**: Single Node objects shared across structures
- **Clean API**: Well-separated methods for each operation

## üöÄ When to Use
- Inventory management systems
- Multi-index data access patterns
- Systems requiring sorted views of data
- Rental or reservation systems

## ‚ö†Ô∏è Edge Cases
- **Non-existent movies**: search returns empty list
- **Duplicate rentals**: Prevented by system design
- **Empty reports**: Return empty list
- **Large datasets**: Handles constraints efficiently

## üõ† Variations
1. **Database Backend**:
```java
// Persistent storage for large datasets
```

2. **Price Updates**:
```java
// Support for dynamic pricing
```

3. **User Management**:
```java
// Track which user rented which movie
```

4. **Visualization**:
```java
// Dashboard for rental analytics
```

5. **Recommendation System**:
```java
// Suggest movies based on rental history
```

## System Design Insight
The solution leverages:
- TreeSet for sorted collections
- HashMap for direct access
- Flyweight pattern with shared Node objects
- Comparator design for flexible sorting
- Bit manipulation for efficient keys

## Alternative Implementation (PriorityQueue)
```java
// Would require manual rebalancing and slower removals
// TreeSet is better for this use case
```
Note: TreeSet is ideal here because it supports efficient removal of arbitrary elements. PriorityQueue doesn't support efficient removal, making it unsuitable for this application.