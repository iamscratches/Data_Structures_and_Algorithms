# 📐 Largest Perimeter Triangle - Greedy with Sorting

## 📜 Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/largest-perimeter-triangle/?envType=daily-question&envId=2025-09-28)

Given:
- An integer array `nums` representing side lengths

Find:
- The largest possible perimeter of a triangle formed from three different elements
- Return 0 if no triangle can be formed

**Triangle Inequality:**
- For sides a, b, c: a + b > c, a + c > b, b + c > a
- For sorted sides a ≤ b ≤ c, only need to check a + b > c

**Constraints:**
- 3 ≤ nums.length ≤ 10⁴
- 1 ≤ nums[i] ≤ 10⁶

**Example:**
```text
Input: nums = [2,1,2]
Output: 5
Explanation: Sides 2, 2, 1 form a triangle with perimeter 5

Input: nums = [1,2,1]
Output: 0
Explanation: No triangle can be formed (1+1=2 ≤ 2)
```

## 🧠 Intuition
The solution uses:
1. **Sorting**: Arrange sides in ascending order
2. **Greedy Approach**: Check largest possible triplets first
3. **Triangle Inequality**: For sorted sides, only check if two smaller sides sum > largest side
4. **Early Termination**: Return first valid triangle found from largest end

Key Insights:
- Largest perimeter triangle will use the largest possible sides
- After sorting, if nums[i-2] + nums[i-1] > nums[i], triangle is valid
- Checking from largest to smallest ensures we find maximum perimeter quickly

## ⚙️ Approach
1. **Sort Array**: Ascending order
2. **Reverse Iteration**:
   - Start from the end and check triplets (i, i-1, i-2)
   - Check if nums[i-2] + nums[i-1] > nums[i]
   - If valid, return sum of all three sides
3. **No Triangle Found**: Return 0

## ✅ Optimized Solution
```java
class Solution {
    public int largestPerimeter(int[] nums) {
        Arrays.sort(nums);
        
        // Check triplets from largest to smallest
        for (int i = nums.length - 1; i >= 2; i--) {
            int side1 = nums[i];
            int side2 = nums[i - 1];
            int side3 = nums[i - 2];
            
            // Check triangle inequality for sorted sides
            if (side2 + side3 > side1) {
                return side1 + side2 + side3;
            }
        }
        
        return 0; // No valid triangle found
    }
}
```

## ⏳ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n log n) | Sorting dominates |
| **Space**       | O(1)       | In-place sorting |

## 📊 Example Walkthrough
**Input:** nums = [2,1,2]

**After sorting:** [1,2,2]

**Iteration (i=2):**
- side1=2, side2=2, side3=1
- Check: 2 + 1 > 2 → 3 > 2 ✓
- Return 2 + 2 + 1 = 5

**Input:** nums = [1,2,1,10]

**After sorting:** [1,1,2,10]

**Iterations:**
- i=3: 1+2 > 10? 3 > 10? ✗
- i=2: 1+1 > 2? 2 > 2? ✗
- Return 0

## 💡 Key Features
- **Optimal Greedy**: Always finds maximum perimeter if exists
- **Efficient**: O(n log n) time, O(1) space
- **Early Termination**: Stops at first valid triangle
- **Simple Logic**: Easy to understand and implement

## 🚀 When to Use
- Triangle formation problems
- When greedy approach applies to sorted data
- Problems involving triangle inequality
- Combinatorial optimization with constraints

## ⚠️ Edge Cases
- **No triangle possible**: Return 0
- **All sides equal**: Equilateral triangle valid if sides > 0
- **Very large numbers**: Integer arithmetic handles constraints
- **Minimum input**: 3 elements handled correctly

## 🛠 Variations
1. **Different Sorting**:
```java
// Could use counting sort for limited range
```

2. **All Triangles**:
```java
// Count all possible triangles instead of max perimeter
```

3. **Different Shapes**:
```java
// Extend to quadrilaterals or other polygons
```

4. **Visualization**:
```java
// Show which sides form the triangle
```

5. **Generalization**:
```java
// Find maximum perimeter polygon with k sides
```

## Mathematical Insight
The solution leverages:
- Triangle inequality theorem
- Properties of sorted sequences
- Greedy algorithm optimality
- Combinatorial optimization

## Alternative Implementation (Explicit Check)
```java
class Solution {
    public int largestPerimeter(int[] nums) {
        Arrays.sort(nums);
        for (int i = nums.length - 3; i >= 0; i--) {
            if (nums[i] + nums[i + 1] > nums[i + 2]) {
                return nums[i] + nums[i + 1] + nums[i + 2];
            }
        }
        return 0;
    }
}
```
Note: This version uses a different indexing approach but has the same logic. Both approaches are equally efficient and correct. The original solution may be slightly more intuitive for understanding the triangle inequality check.