# üìä Count Elements with Maximum Frequency - Frequency Analysis

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/count-elements-with-maximum-frequency/description/?envType=daily-question&envId=2025-09-22)

Given:
- An integer array `nums`

Find:
- The total number of elements that have the maximum frequency in the array
- If multiple elements have the same maximum frequency, count all of them

**Constraints:**
- 1 ‚â§ nums.length ‚â§ 100
- 1 ‚â§ nums[i] ‚â§ 100

**Example:**
```text
Input: nums = [1,2,2,3,1,4]
Output: 4
Explanation: 
Elements 1 and 2 both have frequency 2 (maximum)
Total count = 2 (for 1) + 2 (for 2) = 4

Input: nums = [1,2,3,4,5]
Output: 5
Explanation: All elements have frequency 1
```

## üß† Intuition
The solution uses:
1. **Frequency Counting**: Count occurrences of each number
2. **Maximum Tracking**: Find the highest frequency value
3. **Summation**: Sum frequencies of all elements with maximum frequency

Key Insights:
- Since numbers are in range [1,100], fixed-size array suffices
- Two passes: one to count frequencies, one to sum max frequencies
- Simple and efficient O(n) solution

## ‚öôÔ∏è Approach
1. **Initialize Frequency Array**: Size 101 (covers 1-100)
2. **Count Frequencies**:
   - Iterate through nums, increment corresponding frequency
   - Track maximum frequency encountered
3. **Sum Max Frequencies**:
   - Iterate through frequency array
   - Sum all frequencies equal to the maximum

## ‚úÖ Optimized Solution
```java
class Solution {
    public int maxFrequencyElements(int[] nums) {
        int[] frequency = new int[101]; // Index 1-100
        int maxFrequency = 0;
        
        // Count frequencies and find maximum
        for (int num : nums) {
            frequency[num]++;
            if (frequency[num] > maxFrequency) {
                maxFrequency = frequency[num];
            }
        }
        
        // Sum all elements with maximum frequency
        int total = 0;
        for (int count : frequency) {
            if (count == maxFrequency) {
                total += count;
            }
        }
        
        return total;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Two passes through array |
| **Space**       | O(1)       | Fixed-size frequency array |

## üìä Example Walkthrough
**Input:** nums = [1,2,2,3,1,4]

**Frequency Counting:**
- frequency[1] = 2
- frequency[2] = 2  
- frequency[3] = 1
- frequency[4] = 1
- maxFrequency = 2

**Summation:**
- frequency[1] = 2 ‚Üí add 2
- frequency[2] = 2 ‚Üí add 2
- Total = 4

## üí° Key Features
- **Simplicity**: Easy to understand and implement
- **Efficiency**: Optimal O(n) time complexity
- **Memory Efficient**: Uses fixed-size array
- **Clear Logic**: Separate counting and summation phases

## üöÄ When to Use
- Frequency analysis problems
- When input range is limited and known
- Problems requiring max value tracking
- Educational examples of array manipulation

## ‚ö†Ô∏è Edge Cases
- **Single element**: Returns 1
- **All unique elements**: Returns array length
- **All same elements**: Returns array length
- **Empty array**: Returns 0 (but constraints prevent this)

## üõ† Variations
1. **HashMap Approach**:
```java
// For arbitrary value ranges
```

2. **Single Pass**:
```java
// Track max frequency and count simultaneously
```

3. **Stream API**:
```java
// Functional programming approach
```

4. **Visualization**:
```java
// Display frequency distribution
```

5. **Generalization**:
```java
// Find top k frequencies
```

## Mathematical Insight
The solution leverages:
- Properties of frequency distributions
- Maximum value extraction
- Linear scanning efficiency
- Constant space operations

## Alternative Implementation (HashMap)
```java
class Solution {
    public int maxFrequencyElements(int[] nums) {
        Map<Integer, Integer> freqMap = new HashMap<>();
        int maxFreq = 0;
        
        for (int num : nums) {
            int count = freqMap.getOrDefault(num, 0) + 1;
            freqMap.put(num, count);
            maxFreq = Math.max(maxFreq, count);
        }
        
        int total = 0;
        for (int count : freqMap.values()) {
            if (count == maxFreq) {
                total += count;
            }
        }
        
        return total;
    }
}
```
Note: The HashMap version is more general and works for any integer values, but the array version is more efficient for the given constraints (values 1-100). The array solution avoids HashMap overhead and is thus preferred for this problem.