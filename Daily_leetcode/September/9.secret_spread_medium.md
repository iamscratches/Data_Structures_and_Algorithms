# ðŸ¤« Number of People Aware of a Secret - Dynamic Programming with Sliding Window

## ðŸ“œ Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/number-of-people-aware-of-a-secret/description/?envType=daily-question&envId=2025-09-09)

Given:
- Three integers `n`, `delay`, and `forget`
- On day 1, one person discovers a secret
- Each person who knows the secret:
  - Shares it with one new person every day after `delay` days
  - Forgets the secret after `forget` days (stops sharing)

Find:
- The number of people who know the secret at the end of day `n`

**Constraints:**
- 2 â‰¤ n â‰¤ 1000
- 1 â‰¤ delay < forget â‰¤ n

**Example:**
```text
Input: n = 6, delay = 2, forget = 4
Output: 5
Explanation:
Day 1: 1 person knows
Day 2: 1 person knows (can't share yet due to delay)
Day 3: 2 people know (first person starts sharing)
Day 4: 3 people know
Day 5: 4 people know (first person forgets after day 4)
Day 6: 5 people know
```

## ðŸ§  Intuition
The solution uses:
1. **Dynamic Programming**: `dp[t]` = number of new people who learn the secret on day t
2. **Sliding Window**: Maintains a running sum of people who can currently share
3. **Modulo Arithmetic**: Handles large numbers with modulo 10â¹+7
4. **Phase-Based Processing**: Different stages for delay, sharing, and forgetting

Key Insights:
- People start sharing after `delay` days and stop after `forget` days
- The number of new people on day t equals the number of people currently sharing
- The sliding window tracks active sharers (those between delay and forget days)

## âš™ï¸ Approach
1. **Initialize DP Array**:
   - `dp[1] = 1` (one person on day 1)
   - `share` variable tracks current active sharers
2. **Process Each Day**:
   - On day t, add people who started sharing (t-delay) to `share`
   - Subtract people who forget (t-forget) from `share`
   - Set `dp[t] = share` (new people learning on day t)
3. **Final Count**:
   - Sum people who learned in the last `forget` days (those who still remember)

## âœ… Optimized Solution
```java
class Solution {
    public int peopleAwareOfSecret(int n, int delay, int forget) {
        long[] dp = new long[n + 1];
        dp[1] = 1;
        long activeSharers = 0;
        final long MOD = (long) 1e9 + 7;
        
        for (int day = 2; day <= n; day++) {
            // Add people who become eligible to share today (started delay days ago)
            if (day - delay > 0) {
                activeSharers = (activeSharers + dp[day - delay]) % MOD;
            }
            // Remove people who forget today (started forget days ago)
            if (day - forget > 0) {
                activeSharers = (activeSharers - dp[day - forget] + MOD) % MOD;
            }
            // New people learning today equals current active sharers
            dp[day] = activeSharers;
        }
        
        // Sum people who learned in the last 'forget' days (those who still remember)
        long total = 0;
        for (int day = n - forget + 1; day <= n; day++) {
            total = (total + dp[day]) % MOD;
        }
        
        return (int) total;
    }
}
```

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n)       | Single pass through n days |
| **Space**       | O(n)       | DP array of size n+1 |

## ðŸ“Š Example Walkthrough
**Input:** n = 6, delay = 2, forget = 4

**Execution:**
- Day 1: dp[1]=1, share=0
- Day 2: share=0, dp[2]=0
- Day 3: add dp[1]=1 â†’ share=1, dp[3]=1
- Day 4: add dp[2]=0 â†’ share=1, dp[4]=1
- Day 5: subtract dp[1]=1 â†’ share=0, add dp[3]=1 â†’ share=1, dp[5]=1
- Day 6: subtract dp[2]=0 â†’ share=1, add dp[4]=1 â†’ share=2, dp[6]=2

**Final sum:** days 3-6: dp[3]=1 + dp[4]=1 + dp[5]=1 + dp[6]=2 = 5

## ðŸ’¡ Key Features
- **Efficient DP**: O(n) time complexity
- **Sliding Window**: Maintains active sharers in constant time per day
- **Modulo Handling**: Proper arithmetic for large numbers
- **Clear State Transitions**: Easy to understand day-by-day processing

## ðŸš€ When to Use
- Propagation problems with time constraints
- When state depends on recent history
- Problems with activation and expiration periods
- Viral spread modeling

## âš ï¸ Edge Cases
- **n=1**: Only initial person
- **delay=forget-1**: Minimal sharing window
- **Large n**: Handles up to 1000 with modulo
- **Boundary Conditions**: Careful day indexing

## ðŸ›  Variations
1. **Space Optimization**:
```java
// Use circular buffer to reduce space to O(forget)
```

2. **Different Propagation Rules**:
```java
// Multiple shares per person or different rates
```

3. **Visualization**:
```java
// Plot daily counts and active sharers
```

4. **Analytical Solution**:
```java
// Closed-form mathematical solution
```

5. **Stochastic Version**:
```java
// Probabilistic sharing and forgetting
```

## Mathematical Insight
The solution leverages:
- Recurrence relations with finite memory
- Sliding window techniques
- Dynamic programming principles
- Modular arithmetic properties

## Alternative Implementation (Space Optimized)
```java
class Solution {
    public int peopleAwareOfSecret(int n, int delay, int forget) {
        long[] recent = new long[forget]; // Circular buffer for last 'forget' days
        recent[0] = 1;
        long activeSharers = 0;
        final long MOD = (long) 1e9 + 7;
        
        for (int day = 2; day <= n; day++) {
            int idx = (day - 1) % forget;
            // Remove forgetting people from activeSharers
            activeSharers = (activeSharers - recent[idx] + MOD) % MOD;
            // Add newly eligible people (day-delay)
            if (day - delay > 0) {
                int eligibleIdx = (day - delay - 1) % forget;
                activeSharers = (activeSharers + recent[eligibleIdx]) % MOD;
            }
            recent[idx] = activeSharers;
        }
        
        long total = 0;
        for (long count : recent) {
            total = (total + count) % MOD;
        }
        return (int) total;
    }
}
```
Note: This version uses O(forget) space instead of O(n) by maintaining a circular buffer. The original solution is more straightforward for understanding the concept.