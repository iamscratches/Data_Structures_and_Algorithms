# üìà Maximum Average Pass Ratio - Greedy with Priority Queue

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/maximum-average-pass-ratio/description/?envType=daily-question&envId=2025-09-01)

Given:
- An array `classes` where `classes[i] = [pass_i, total_i]` represents a class with pass_i passing students and total_i total students
- An integer `extraStudents` representing additional brilliant students

Find:
- The maximum possible average pass ratio after assigning all extra students to classes
- Each brilliant student will always pass when added to a class

**Constraints:**
- 1 ‚â§ classes.length ‚â§ 10‚Åµ
- classes[i].length == 2
- 1 ‚â§ pass_i ‚â§ total_i ‚â§ 10‚Åµ
- 1 ‚â§ extraStudents ‚â§ 10‚Åµ

**Example:**
```text
Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2
Output: 0.78333
Explanation: 
Assign both extra students to second class: 
[[1,2],[5,7],[2,2]] ‚Üí pass ratios: 0.5 + 0.714 + 1.0 = 2.214 ‚Üí average = 0.738
Better: assign one to first class and one to second class:
[[2,3],[4,6],[2,2]] ‚Üí 0.667 + 0.667 + 1.0 = 2.334 ‚Üí average = 0.778
Optimal: [[2,3],[4,6],[2,2]] ‚Üí average ‚âà 0.783
```

## üß† Intuition
The solution uses:
1. **Greedy Algorithm**: Always assign extra students to the class that gives maximum pass ratio improvement
2. **Priority Queue**: Max-heap that prioritizes classes by marginal gain
3. **Marginal Gain Calculation**: The improvement from adding one student to a class
4. **Iterative Assignment**: Process extra students one by one optimally

Key Insights:
- The marginal gain decreases as more students are added to a class (diminishing returns)
- Priority queue ensures we always add to the most beneficial class
- Average pass ratio is maximized by greedy assignment

## ‚öôÔ∏è Approach
1. **Initialize Priority Queue**:
   - Max-heap ordered by marginal gain: (pass+1)/(total+1) - pass/total
2. **Precompute Initial Gains**:
   - Calculate marginal gain for each class and add to queue
3. **Assign Extra Students**:
   - Extract class with maximum marginal gain
   - Add one student to this class
   - Recalculate new marginal gain and push back to queue
4. **Compute Final Average**:
   - After processing all extra students, calculate average pass ratio

## ‚úÖ Optimized Solution
```java
class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        // Max-heap based on marginal gain (priority: highest gain first)
        PriorityQueue<double[]> pq = new PriorityQueue<>((a, b) -> 
            Double.compare(b[0], a[0]) // Reverse order for max-heap
        );
        
        // Initialize priority queue with marginal gains
        for (int[] cls : classes) {
            double pass = cls[0];
            double total = cls[1];
            double marginalGain = (pass + 1) / (total + 1) - pass / total;
            pq.offer(new double[]{marginalGain, pass, total});
        }
        
        // Assign extra students optimally
        while (extraStudents-- > 0) {
            double[] current = pq.poll();
            double pass = current[1] + 1;
            double total = current[2] + 1;
            
            // Calculate new marginal gain after adding one student
            double newMarginalGain = (pass + 1) / (total + 1) - pass / total;
            pq.offer(new double[]{newMarginalGain, pass, total});
        }
        
        // Calculate final average pass ratio
        double totalRatio = 0.0;
        while (!pq.isEmpty()) {
            double[] cls = pq.poll();
            totalRatio += cls[1] / cls[2];
        }
        
        return totalRatio / classes.length;
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O((n + k) log n) | n classes, k extra students, heap operations |
| **Space**       | O(n)       | Priority queue storage |

## üìä Example Walkthrough
**Input:** classes = [[1,2],[3,5],[2,2]], extraStudents = 2

**Initial Marginal Gains:**
- Class 1: (2/3) - (1/2) = 0.1667
- Class 2: (4/6) - (3/5) = 0.0667  
- Class 3: (3/3) - (2/2) = 0.0 (already full)

**First Assignment:**
- Add to Class 1: becomes [2,3]
- New gain: (3/4) - (2/3) = 0.0833

**Second Assignment:**
- Compare gains: Class 1: 0.0833, Class 2: 0.0667, Class 3: 0.0
- Add to Class 1 again: becomes [3,4]
- Final ratios: 3/4=0.75, 3/5=0.6, 2/2=1.0 ‚Üí average=0.783

## üí° Key Features
- **Optimal Greedy**: Always chooses best marginal improvement
- **Efficient Data Structure**: Priority queue for fast max extraction
- **Diminishing Returns**: Properly handles decreasing gains
- **Precision Handling**: Uses double arithmetic for accurate ratios

## üöÄ When to Use
- Resource allocation problems
- When greedy choice leads to global optimum
- Problems with diminishing returns
- Optimization with multiple choices

## ‚ö†Ô∏è Edge Cases
- **Full Classes**: Already 100% pass ratio (no gain)
- **Single Class**: All extra students go to one class
- **Large Numbers**: Handles constraints up to 10‚Åµ
- **Precision Issues**: Floating-point arithmetic carefulness

## üõ† Variations
1. **Batch Processing**:
```java
// Add multiple students at once when gains are similar
```

2. **Mathematical Optimization**:
```java
// Use calculus to find optimal distribution
```

3. **Parallel Processing**:
```java
// Process multiple classes concurrently
```

4. **Visualization**:
```java
// Plot marginal gain curves
```

5. **Generalization**:
```java
// Extend to multiple types of students
```

## Mathematical Insight
The solution leverages:
- Diminishing marginal returns principle
- Greedy algorithm optimality for additive improvements
- Priority queue efficiency for maximum extraction
- Convergence properties of ratio improvements

## Alternative Implementation (Efficient Polling)
```java
class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        PriorityQueue<double[]> pq = new PriorityQueue<>(
            (a, b) -> Double.compare(
                (b[1] + 1) / (b[2] + 1) - b[1] / b[2], 
                (a[1] + 1) / (a[2] + 1) - a[1] / a[2]
            )
        );
        
        for (int[] cls : classes) {
            pq.offer(new double[]{0, cls[0], cls[1]});
        }
        
        while (extraStudents-- > 0) {
            double[] curr = pq.poll();
            pq.offer(new double[]{0, curr[1] + 1, curr[2] + 1});
        }
        
        double sum = 0;
        while (!pq.isEmpty()) {
            double[] cls = pq.poll();
            sum += cls[1] / cls[2];
        }
        
        return sum / classes.length;
    }
}
```
Note: This version avoids recalculating marginal gain in the comparator by using a lambda, but may be less efficient due to repeated calculation. The original solution stores marginal gain to avoid recomputation.