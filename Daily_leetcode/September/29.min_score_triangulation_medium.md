# üî∫ Minimum Score Triangulation of Polygon - Dynamic Programming

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/minimum-score-triangulation-of-polygon/description/?envType=daily-question&envId=2025-09-29)

Given:
- A convex polygon with `n` vertices labeled 0 to n-1 in clockwise order
- Array `values` where `values[i]` is the value at vertex i

Find:
- The minimum score of triangulating the polygon
- Score = sum of products of values in each triangle
- Triangulation: divide polygon into n-2 triangles using n-3 diagonals

**Constraints:**
- n == values.length
- 3 ‚â§ n ‚â§ 50
- 1 ‚â§ values[i] ‚â§ 100

**Example:**
```text
Input: values = [1,2,3]
Output: 6
Explanation: Polygon is already a triangle ‚Üí score = 1√ó2√ó3 = 6

Input: values = [3,7,4,5]
Output: 144
Explanation: Two possible triangulations:
- Triangle (0,1,3) + (1,2,3): 3√ó7√ó5 + 7√ó4√ó5 = 105 + 140 = 245
- Triangle (0,1,2) + (0,2,3): 3√ó7√ó4 + 3√ó4√ó5 = 84 + 60 = 144
Minimum = 144
```

## üß† Intuition
The solution uses:
1. **Dynamic Programming**: Solve smaller subproblems and combine
2. **Interval DP**: Process polygons of increasing lengths
3. **Triangle Decomposition**: For edge (i,j), try all possible third vertices k
4. **Optimal Substructure**: Minimum triangulation can be built from minimum triangulations of sub-polygons

Key Insights:
- For edge (i,j), choosing vertex k creates triangle (i,k,j) and divides polygon into two sub-polygons
- DP[i][j] = minimum triangulation cost for polygon from vertex i to j
- Base case: triangles (len=3) have cost values[i]√óvalues[k]√óvalues[j]

## ‚öôÔ∏è Approach
1. **DP State**: `dp[i][j]` = min triangulation cost from vertex i to j
2. **DP Transition**:
   - For each possible vertex k between i and j
   - Cost = dp[i][k] + dp[k][j] + values[i]√óvalues[k]√óvalues[j]
   - Take minimum over all k
3. **Fill Order**: Process polygons by increasing length
4. **Result**: dp[0][n-1] contains answer for entire polygon

## ‚úÖ Optimized Solution
```java
class Solution {
    public int minScoreTriangulation(int[] values) {
        int n = values.length;
        int[][] dp = new int[n][n];
        
        // Process polygons of increasing lengths
        for (int length = 3; length <= n; length++) {
            for (int i = 0; i + length - 1 < n; i++) {
                int j = i + length - 1;
                dp[i][j] = Integer.MAX_VALUE;
                
                // Try all possible third vertices to form triangle (i,k,j)
                for (int k = i + 1; k < j; k++) {
                    int cost = dp[i][k] + dp[k][j] + values[i] * values[k] * values[j];
                    dp[i][j] = Math.min(dp[i][j], cost);
                }
            }
        }
        
        return dp[0][n - 1];
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n¬≥)      | Three nested loops |
| **Space**       | O(n¬≤)      | DP table storage |

## üìä Example Walkthrough
**Input:** values = [3,7,4,5]

**DP Table Filling:**
- **Length 3:**
  - dp[0][2] = 3√ó7√ó4 = 84
  - dp[1][3] = 7√ó4√ó5 = 140

- **Length 4 (i=0, j=3):**
  - k=1: dp[0][1] + dp[1][3] + 3√ó7√ó5 = 0 + 140 + 105 = 245
  - k=2: dp[0][2] + dp[2][3] + 3√ó4√ó5 = 84 + 0 + 60 = 144
  - dp[0][3] = min(245, 144) = 144

**Result:** 144

## üí° Key Features
- **Classic Interval DP**: Standard pattern for polygon triangulation
- **Bottom-Up Approach**: Build solutions for smaller intervals first
- **Efficient State Transitions**: O(1) transitions with precomputed subproblems
- **Clear Base Cases**: Triangles (length=3) have direct costs

## üöÄ When to Use
- Polygon triangulation problems
- Interval dynamic programming patterns
- Problems with optimal substructure
- Combinatorial optimization on sequences

## ‚ö†Ô∏è Edge Cases
- **Triangle (n=3)**: Direct product calculation
- **Large n**: Handles maximum constraint (n=50)
- **All equal values**: Still finds optimal triangulation
- **Convex polygon**: Input guaranteed to be convex

## üõ† Variations
1. **Memoization (Top-Down)**:
```java
// Recursive approach with memoization
```

2. **Different Cost Functions**:
```java
// Modify the triangle cost calculation
```

3. **Path Reconstruction**:
```java
// Track the actual triangulation
```

4. **Visualization**:
```java
// Show the triangulation process
```

5. **Generalization**:
```java
// Extend to 3D polyhedra triangulation
```

## Mathematical Insight
The solution leverages:
- Dynamic programming principles
- Catalan number properties (number of triangulations)
- Optimal substructure of convex polygons
- Combinatorial optimization techniques

## Alternative Implementation (Top-Down with Memoization)
```java
class Solution {
    public int minScoreTriangulation(int[] values) {
        int n = values.length;
        Integer[][] memo = new Integer[n][n];
        return dfs(values, 0, n - 1, memo);
    }
    
    private int dfs(int[] values, int i, int j, Integer[][] memo) {
        if (j - i < 2) return 0; // Not a polygon
        if (memo[i][j] != null) return memo[i][j];
        
        int minCost = Integer.MAX_VALUE;
        for (int k = i + 1; k < j; k++) {
            int cost = dfs(values, i, k, memo) + dfs(values, k, j, memo) 
                     + values[i] * values[k] * values[j];
            minCost = Math.min(minCost, cost);
        }
        
        return memo[i][j] = minCost;
    }
}
```
Note: The top-down approach is more intuitive but may have recursion overhead. The bottom-up solution is generally more efficient and avoids recursion stack limits. Both have the same time complexity O(n¬≥).