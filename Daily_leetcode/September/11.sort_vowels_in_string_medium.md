# üî§ Sort Vowels in a String - Priority Queue Approach

## üìú Problem Statement
**Link:** [LeetCode Problem](https://leetcode.com/problems/sort-vowels-in-a-string/description/?envType=daily-question&envId=2025-09-11)

Given:
- A string `s`

Task:
- Sort all the vowels in the string in ascending order (non-vowels remain in their original positions)
- Vowels are 'a', 'e', 'i', 'o', 'u' (both lowercase and uppercase)

**Constraints:**
- 1 ‚â§ s.length ‚â§ 10‚Åµ
- `s` consists of printable ASCII characters

**Example:**
```text
Input: s = "lEetcOde"
Output: "lEOtcede"
Explanation:
Vowels: ['E','e','O','e'] ‚Üí sorted: ['E','O','e','e']
Non-vowels remain in place: l _ _ t c _ d _
Result: "lEOtcede"
```

## üß† Intuition
The solution uses:
1. **Vowel Identification**: Separate vowels from consonants
2. **Sorting Vowels**: Collect vowels and sort them in ascending order
3. **Reconstruction**: Place sorted vowels back into their original positions
4. **Efficient Sorting**: Use priority queue for automatic ordering

Key Insights:
- Only vowels need to be sorted; consonants stay fixed
- Vowels should be sorted in ASCII order (A < E < I < O < U < a < e < i < o < u)
- Priority queue provides sorted order automatically

## ‚öôÔ∏è Approach
1. **Identify and Collect Vowels**:
   - Scan the string and identify vowel characters
   - Add vowels to a priority queue (min-heap)
2. **Reconstruct String**:
   - Scan the string again
   - When encountering a vowel, replace it with the next vowel from the sorted queue
   - Keep consonants in their original positions

## ‚úÖ Optimized Solution
```java
class Solution {
    public String sortVowels(String s) {
        // Priority queue to sort vowels in natural order (ASCII order)
        PriorityQueue<Character> vowelQueue = new PriorityQueue<>();
        char[] characters = s.toCharArray();
        
        // First pass: collect all vowels into the priority queue
        for (char c : characters) {
            if (isVowel(c)) {
                vowelQueue.offer(c);
            }
        }
        
        // Second pass: replace vowels with sorted ones
        for (int i = 0; i < characters.length; i++) {
            if (isVowel(characters[i])) {
                characters[i] = vowelQueue.poll();
            }
        }
        
        return new String(characters);
    }
    
    private boolean isVowel(char c) {
        // Check if character is a vowel (case-sensitive)
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||
               c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';
    }
}
```

## ‚è≥ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n log n) | Priority queue operations for vowels |
| **Space**       | O(n)       | Storage for priority queue and char array |

## üìä Example Walkthrough
**Input:** s = "lEetcOde"

**Execution:**
1. Identify vowels: ['E','e','O','e']
2. Add to priority queue: sorted order ['E','O','e','e']
3. Reconstruct string:
   - l (consonant) ‚Üí keep
   - E (vowel) ‚Üí replace with 'E'
   - e (vowel) ‚Üí replace with 'O'
   - t (consonant) ‚Üí keep
   - c (consonant) ‚Üí keep
   - O (vowel) ‚Üí replace with 'e'
   - d (consonant) ‚Üí keep
   - e (vowel) ‚Üí replace with 'e'
4. Result: "lEOtcede"

## üí° Key Features
- **Efficient Sorting**: Priority queue handles vowel ordering
- **Two-Pass Algorithm**: Clean separation of collection and reconstruction
- **Case Sensitivity**: Properly handles uppercase and lowercase vowels
- **In-Place Modification**: Uses char array for efficient string building

## üöÄ When to Use
- String manipulation problems
- When selective sorting is required
- Problems involving character classification
- ASCII character processing

## ‚ö†Ô∏è Edge Cases
- **No Vowels**: Original string returned unchanged
- **All Vowels**: Entire string gets sorted
- **Mixed Case**: Vowels sorted in ASCII order (A-Z before a-z)
- **Special Characters**: Non-alphabetic characters are not vowels

## üõ† Variations
1. **Custom Comparator**:
```java
// Sort vowels case-insensitively
PriorityQueue<Character> pq = new PriorityQueue<>((a,b) -> 
    Character.toLowerCase(a) - Character.toLowerCase(b)
);
```

2. **Array Sorting**:
```java
// Collect vowels in list and use Arrays.sort()
```

3. **Bucket Sort**:
```java
// Use frequency array for fixed vowel set
```

4. **In-Place**:
```java
// Modify string without extra data structures
```

5. **Visualization**:
```java
// Show vowel positions and sorting process
```

## Mathematical Insight
The solution leverages:
- Priority queue properties for automatic sorting
- ASCII character ordering
- String manipulation techniques
- Efficient collection and replacement strategies

## Alternative Implementation (Array Sort)
```java
class Solution {
    public String sortVowels(String s) {
        List<Character> vowels = new ArrayList<>();
        char[] arr = s.toCharArray();
        
        // Collect vowels
        for (char c : arr) {
            if (isVowel(c)) {
                vowels.add(c);
            }
        }
        
        // Sort vowels
        Collections.sort(vowels);
        
        // Replace vowels in original order
        int index = 0;
        for (int i = 0; i < arr.length; i++) {
            if (isVowel(arr[i])) {
                arr[i] = vowels.get(index++);
            }
        }
        
        return new String(arr);
    }
    
    private boolean isVowel(char c) {
        return "AEIOUaeiou".indexOf(c) != -1;
    }
}
```
Note: This version uses ArrayList and Collections.sort() which may be slightly more efficient for large vowel sets. The priority queue approach is more elegant and has similar time complexity.