# ğŸ” Interval List Intersections - Two Pointer Approach

## ğŸ“œ Problem Statement
**Link:** [GeeksforGeeks Problem](https://www.geeksforgeeks.org/problems/interval-list-intersections/1?page=1&company=Google&sortBy=latest)

Given two lists of closed intervals, where each interval is represented as [start, end], return the intersection of these two interval lists.

**Constraints:**
- 1 â‰¤ arr1.length, arr2.length â‰¤ 1000
- 0 â‰¤ start â‰¤ end â‰¤ 10â¹
- Input intervals are non-overlapping and sorted by start time

**Example:**
```text
Input:
arr1 = [[0,2],[5,10],[13,23],[24,25]]
arr2 = [[1,5],[8,12],[15,24],[25,26]]

Output:
[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]
```

---

## ğŸ§  Intuition
The solution uses:
1. **Two Pointers**: Efficiently scans both interval lists
2. **Interval Math**: Calculates intersection using max/min
3. **Pointer Advancement**: Always moves the pointer with earlier end time

Key Insights:
- Intersection exists when start â‰¤ end
- Inputs are already sorted (optimization possible)
- O(n + m) time complexity (n, m = list lengths)

---

## âš™ï¸ Approach
### **1ï¸âƒ£ Initialize Pointers**
1. Start at beginning of both lists

### **2ï¸âƒ£ Calculate Intersection**
1. For current intervals:
   - Intersection start = max(start1, start2)
   - Intersection end = min(end1, end2)
2. Add to result if valid (start â‰¤ end)

### **3ï¸âƒ£ Advance Pointers**
1. Move pointer whose interval ends first
2. Repeat until one list is exhausted

---

## âœ… Optimized Solution
```java
class Solution {
    public List<List<Integer>> findIntersection(List<List<Integer>> arr1, List<List<Integer>> arr2) {
        List<List<Integer>> result = new ArrayList<>();
        int i = 0, j = 0;

        while (i < arr1.size() && j < arr2.size()) {
            // Get current interval bounds
            int start1 = arr1.get(i).get(0), end1 = arr1.get(i).get(1);
            int start2 = arr2.get(j).get(0), end2 = arr2.get(j).get(1);

            // Calculate potential intersection
            int intersectStart = Math.max(start1, start2);
            int intersectEnd = Math.min(end1, end2);

            // Add valid intersections
            if (intersectStart <= intersectEnd) {
                result.add(Arrays.asList(intersectStart, intersectEnd));
            }

            // Move pointer based on which interval ends first
            if (end1 < end2) {
                i++;
            } else {
                j++;
            }
        }

        return result;
    }
}
```

Key Features:
- **Efficient Scanning**: Single pass through both lists
- **Clear Intersection Logic**: Simple max/min operations
- **Optimal Pointer Movement**: Always advances earlier-ending interval
- **No Sorting Needed**: Inputs are pre-sorted

---

## â³ Complexity Analysis
| Metric          | Complexity | Description |
|-----------------|------------|-------------|
| **Time**        | O(n + m)   | Linear scan of both lists |
| **Space**       | O(1)       | Constant space (excluding output) |

---

## ğŸ“Š Example Walkthrough

**Input:**
```
arr1 = [[0,2],[5,10],[13,23],[24,25]]
arr2 = [[1,5],[8,12],[15,24],[25,26]]
```

**Execution:**
1. **First Pair** (i=0,j=0):
   - [0,2] âˆ© [1,5] â†’ [1,2] (added)
   - Advance i (ends first)
2. **Second Pair** (i=1,j=0):
   - [5,10] âˆ© [1,5] â†’ [5,5] (added)
   - Advance j (ends first)
3. **Third Pair** (i=1,j=1):
   - [5,10] âˆ© [8,12] â†’ [8,10] (added)
   - Advance i
4. **Continues** until all intersections found

**Result:** [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]

---

## ğŸ’¡ Key Features
- **Complete Intersection**: Finds all valid overlaps
- **Input Preservation**: Doesn't modify input lists
- **Efficiency**: Linear time complexity
- **Readable Output**: Clear interval format

---

## ğŸš€ When to Use
- Calendar/scheduling applications
- Time-based resource allocation
- Interval merging/overlap detection
- Any problem requiring interval comparisons

## âš ï¸ Edge Cases
- **No intersections**: Returns empty list
- **Identical intervals**: Returns same intervals
- **Single-point overlaps**: Handles [x,x] intervals
- **Large intervals**: Handles maximum constraints

## ğŸ›  Variations
1. **Unsorted Inputs**:
```java
// Add sorting step if inputs aren't pre-sorted
```

2. **Multiple Lists**:
```java
// Extend to N interval lists
```

3. **Custom Overlap Logic**:
```java
// Implement minimum overlap duration requirement
```