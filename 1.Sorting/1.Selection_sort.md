# 🔍 **Selection Sort: Complete Analysis**  

## **📌 Problem Description**  
Given an unsorted array `arr[]` of size `N`, sort it in **ascending order** using **Selection Sort**.  

**Example:**  
- **Input:** `[64, 25, 12, 22, 11]`  
- **Output:** `[11, 12, 22, 25, 64]`  

**Link:** [GFG Problem](https://www.geeksforgeeks.org/problems/selection-sort/1)  

---

## **💡 Intuition**  
Selection Sort works by **repeatedly finding the smallest (or largest) element from the unsorted part and swapping it with the first unsorted element**.  

- **Key Idea:**  
  - Divide the array into a **sorted** and **unsorted** part.  
  - In each iteration, the smallest element from the unsorted part is selected and placed in its correct position.  

---

## **⚙️ Approach**  
1. **Iterate** through the array from `i = 0` to `N-1`.  
2. **Find the minimum element** in the remaining unsorted array (`i` to `N-1`).  
3. **Swap** the found minimum element with the element at `i`.  
4. **Repeat** until the entire array is sorted.  

---

## **🧮 Mathematical Derivation**  
Selection Sort performs:  
- **Total comparisons** = `(N-1) + (N-2) + ... + 1 = N(N-1)/2`  
- **Total swaps** = `N-1` (exactly one swap per iteration).  

**Total Operations ≈ O(N²)** (since comparisons dominate swaps).  

---

## **⏱ Time Complexity**  
- **Best Case:** `O(N²)` (Already sorted, but still checks all elements).  
- **Average Case:** `O(N²)`.  
- **Worst Case:** `O(N²)`.  

**Reason:**  
- **Nested loops** → Outer loop runs `N` times, inner loop runs `N-i` times.  
- Total comparisons = `Σ (N-i) ≈ N²/2` → **Quadratic complexity**.  

---

## **💾 Space Complexity**  
- **O(1)** (In-place sorting, no extra space used except for temporary variables).  

---

## **📝 Example Walkthrough**  
**Input:** `[64, 25, 12, 22, 11]`  

1. **i=0:**  
   - Find min in `[64,25,12,22,11]` → `11` (index `4`).  
   - Swap `64` and `11` → `[11, 25, 12, 22, 64]`.  

2. **i=1:**  
   - Find min in `[25,12,22,64]` → `12` (index `2`).  
   - Swap `25` and `12` → `[11, 12, 25, 22, 64]`.  

3. **i=2:**  
   - Find min in `[25,22,64]` → `22` (index `3`).  
   - Swap `25` and `22` → `[11, 12, 22, 25, 64]`.  

4. **i=3:**  
   - Find min in `[25,64]` → `25` (already in place).  

5. **i=4:**  
   - Only one element left → **Array is sorted!**  

**Final Output:** `[11, 12, 22, 25, 64]` ✅  

---

## **🚀 Key Takeaways**  
✔ **Simple but inefficient** for large datasets (due to `O(N²)` time).  
✔ **Minimal swaps** (useful when writes are expensive).  
✔ **In-place sorting** (no extra memory needed).  

**Upvote if this helped!** 👍 Happy coding! 🚀