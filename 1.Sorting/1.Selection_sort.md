# ğŸ” **Selection Sort: Complete Analysis**  

## **ğŸ“Œ Problem Description**  
Given an unsorted array `arr[]` of size `N`, sort it in **ascending order** using **Selection Sort**.  

**Example:**  
- **Input:** `[64, 25, 12, 22, 11]`  
- **Output:** `[11, 12, 22, 25, 64]`  

**Link:** [GFG Problem](https://www.geeksforgeeks.org/problems/selection-sort/1)  

---

## **ğŸ’¡ Intuition**  
Selection Sort works by **repeatedly finding the smallest (or largest) element from the unsorted part and swapping it with the first unsorted element**.  

- **Key Idea:**  
  - Divide the array into a **sorted** and **unsorted** part.  
  - In each iteration, the smallest element from the unsorted part is selected and placed in its correct position.  

---

## **âš™ï¸ Approach**  
1. **Iterate** through the array from `i = 0` to `N-1`.  
2. **Find the minimum element** in the remaining unsorted array (`i` to `N-1`).  
3. **Swap** the found minimum element with the element at `i`.  
4. **Repeat** until the entire array is sorted.  

---

## **ğŸ§® Mathematical Derivation**  
Selection Sort performs:  
- **Total comparisons** = `(N-1) + (N-2) + ... + 1 = N(N-1)/2`  
- **Total swaps** = `N-1` (exactly one swap per iteration).  

**Total Operations â‰ˆ O(NÂ²)** (since comparisons dominate swaps).  

---

## **â± Time Complexity**  
- **Best Case:** `O(NÂ²)` (Already sorted, but still checks all elements).  
- **Average Case:** `O(NÂ²)`.  
- **Worst Case:** `O(NÂ²)`.  

**Reason:**  
- **Nested loops** â†’ Outer loop runs `N` times, inner loop runs `N-i` times.  
- Total comparisons = `Î£ (N-i) â‰ˆ NÂ²/2` â†’ **Quadratic complexity**.  

---

## **ğŸ’¾ Space Complexity**  
- **O(1)** (In-place sorting, no extra space used except for temporary variables).  

---

## **ğŸ“ Example Walkthrough**  
**Input:** `[64, 25, 12, 22, 11]`  

1. **i=0:**  
   - Find min in `[64,25,12,22,11]` â†’ `11` (index `4`).  
   - Swap `64` and `11` â†’ `[11, 25, 12, 22, 64]`.  

2. **i=1:**  
   - Find min in `[25,12,22,64]` â†’ `12` (index `2`).  
   - Swap `25` and `12` â†’ `[11, 12, 25, 22, 64]`.  

3. **i=2:**  
   - Find min in `[25,22,64]` â†’ `22` (index `3`).  
   - Swap `25` and `22` â†’ `[11, 12, 22, 25, 64]`.  

4. **i=3:**  
   - Find min in `[25,64]` â†’ `25` (already in place).  

5. **i=4:**  
   - Only one element left â†’ **Array is sorted!**  

**Final Output:** `[11, 12, 22, 25, 64]` âœ…  

---

## **ğŸš€ Key Takeaways**  
âœ” **Simple but inefficient** for large datasets (due to `O(NÂ²)` time).  
âœ” **Minimal swaps** (useful when writes are expensive).  
âœ” **In-place sorting** (no extra memory needed).  

**Upvote if this helped!** ğŸ‘ Happy coding! ğŸš€